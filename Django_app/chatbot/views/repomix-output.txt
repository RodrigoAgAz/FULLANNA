This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
api/
  endpoints.py
  test_explicit.py
  webhooks.py
handlers/
  appointment_handler.py
  chat_handler.py
  context_manager.py
  medical_handler.py
  medication_reminder_handler.py
  symptom_guidance_handler.py
services/
  explanation_service.py
  fhir_service.py
  intent_service.py
  language_service.py
  medication_service.py
  personalized_medical_advice_service.py
  post_appointment_checkin_service.py
  post_discharge_service.py
  preventive_care_reminder_service.py
  scheduler.py
  screening_guideline_service.py
  session.py
  symptom_guidance_service.py
utils/
  constants.py
  datetime_utils.py
  formatters.py
  medical_info_templates.py
  response_formatter.py
  shared.py
config.py
utils.py

================================================================
Files
================================================================

================
File: api/endpoints.py
================
from django.http import JsonResponse
import json
import logging
from asgiref.sync import sync_to_async
import inspect  # Using this for iscoroutine and other functions

from chatbot.views.services.session import get_session
from chatbot.views.handlers.chat_handler import ChatHandler

logger = logging.getLogger('chatbot')


async def chat(request):
    """Async endpoint that processes chat messages using ChatHandler"""
    logger.debug("Starting chat endpoint function")
    logger.debug(f"Request: URL={request.path}, METHOD={request.method}")
    
    # Debug logging to confirm we're hitting this function
    if request.path == "/chatbot/chat/":
        logger.debug("Passing request to chat handler")
    
    try:
        logger.debug("chat function called")
        logger.debug("About to read request body")
        body = request.body  # This is bytes
        logger.debug("Parsed request body")
        data = json.loads(body.decode('utf-8'))  # Decode to string and parse JSON
        user_id = data.get('user_id')
        user_message = data.get('message', '')
        logger.debug(f"Got user_id={user_id}, message={user_message}")

        logger.debug("Getting session data")
        session_data = await get_session(user_id)
        logger.debug(f"Is ChatHandler.__init__ a coroutine function? {inspect.iscoroutinefunction(ChatHandler.__init__)}")
        logger.debug("Creating ChatHandler")
        handler = ChatHandler(session_data, user_message, user_id)
        logger.debug("About to initialize handler")
        await handler.initialize()  # Initialize handler
        logger.debug("Handler initialized")
        
        logger.debug("About to call handle_message")
        result = await handler.handle_message()  # This needs to be awaited
        logger.debug(f"handle_message returned, type={type(result)}, is coroutine={inspect.iscoroutine(result)}")
        
        logger.debug("Processing result")
        # Check if result is a tuple (response, session) or just response
        if isinstance(result, tuple) and len(result) == 2:
            logger.debug("Result is a tuple")
            response, updated_session = result
        else:
            logger.debug("Result is not a tuple")
            response = result
            updated_session = session_data
        
        # Ensure we return a JsonResponse object
        logger.debug(f"Response type is {type(response)}")
        if isinstance(response, dict):
            logger.debug("Converting dict to JsonResponse")
            final_response = JsonResponse(response)
        elif isinstance(response, JsonResponse):
            logger.debug("Using JsonResponse directly")
            final_response = response
        else:
            logger.debug(f"Unexpected response type: {type(response)}")
            logger.error(f"Unexpected response type: {type(response)}")
            final_response = JsonResponse({"messages": ["An unexpected error occurred."]})
            
        logger.debug("About to return final response")
        logger.debug(f"Final response type: {type(final_response)}, is coroutine={inspect.iscoroutine(final_response)}")
        return final_response
            
    except Exception as e:
        logger.error(f"Exception in chat endpoint: {str(e)}")
        logger.error(f"Exception type: {type(e)}")
        import traceback
        logger.error(f"Exception traceback: {traceback.format_exc()}")
        logger.error(f"Error handling chat request: {str(e)}", exc_info=True)
        return JsonResponse({"messages": ["Sorry, something went wrong."]})

================
File: api/test_explicit.py
================
"""
Explicit test endpoint to diagnose routing issues
"""
from django.http import JsonResponse

import logging
logger = logging.getLogger(__name__)

async def explicit_test(request):
    """A very simple test endpoint that returns a specific response"""
    logger.debug("Explicit test endpoint called")
    return JsonResponse({"message": "This is from the explicit test endpoint"})

================
File: api/webhooks.py
================
import logging
logger = logging.getLogger(__name__)
logger.debug("Webhooks module loaded")

================
File: handlers/appointment_handler.py
================
# chatbot/views/handlers/appointment_handler.py

from datetime import datetime
from zoneinfo import ZoneInfo
from django.conf import settings
from chatbot.views.utils.formatters import get_resource_name
from chatbot.views.utils.datetime_utils import format_datetime_for_user
from chatbot.views.config import config as app_config  # Fixed import
from ..services.session import update_session
from ..services.fhir_service import get_user_appointments, get_practitioner
import logging

logger = logging.getLogger('chatbot')
logger.debug("Appointment handler module loaded")
def handle_appointment_query(session, user_message):
    """Handle showing upcoming appointments"""
    try:
        if not session.get('patient'):
            return "Please verify your identity first."
        
        patient_id = session['patient']['id']
        logger.info(f"Fetching appointments for patient {patient_id}")
        
        # Get FHIR client from app_config
        fhir_client = app_config.get_fhir_client()  # Using the correct config
        
        # Build the search parameters
        current_time = datetime.now(ZoneInfo(settings.TIME_ZONE)).isoformat()
        search_params = {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "_sort": "date"
        }
        
        # Search for appointments
        logger.debug(f"Searching appointments with params: {search_params}")
        response = fhir_client.search("Appointment", search_params)
        
        if not response or 'entry' not in response or not response['entry']:
            return "You don't have any upcoming appointments scheduled."
        
        # Format appointments
        appointments = []
        for entry in response.get('entry', []):
            appt = entry['resource']
            
            # Skip non-booked appointments
            if appt.get('status') not in ['booked', 'pending']:
                continue
            
            # Get the appointment time
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            local_time = start_time.astimezone(ZoneInfo(settings.TIME_ZONE))
            formatted_time = local_time.strftime("%A, %B %d, %Y at %I:%M %p %Z")
            
            # Get practitioner info
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('type') == 'Practitioner':
                    pract_ref = participant['actor']['reference']
                    try:
                        pract_id = pract_ref.split('/')[-1]
                        practitioner = fhir_client.read("Practitioner", pract_id)
                        if practitioner and 'name' in practitioner:
                            name_data = practitioner['name'][0] if isinstance(practitioner['name'], list) else practitioner['name']
                            if isinstance(name_data, dict):
                                if 'text' in name_data:
                                    practitioner_name = f"Dr. {name_data['text']}"
                                elif 'family' in name_data:
                                    given = name_data.get('given', [''])[0]
                                    practitioner_name = f"Dr. {given} {name_data['family']}"
                    except Exception as e:
                        logger.error(f"Error getting practitioner details: {str(e)}")
                    break
            
            appointments.append(f"- {formatted_time} with {practitioner_name}")
            if appt.get('description'):
                appointments[-1] += f" ({appt['description']})"
        
        if not appointments:
            return "You don't have any upcoming appointments scheduled."
        
        return "Here are your upcoming appointments:\n\n" + "\n".join(appointments)
        
    except Exception as e:
        logger.error(f"Error handling appointment query: {str(e)}", exc_info=True)
        return "I'm sorry, I couldn't retrieve your appointments at this time. Please try again later."

async def handle_appointment_cancellation(session, user_message):
    """Handle appointment cancellation requests"""
    try:
        # Get FHIR client from app_config
        fhir_client = app_config.get_fhir_client()

        if not session.get('patient'):
            return "Please verify your identity first."
            
        patient_id = session['patient']['id']
        logger.debug(f"Handling appointment cancellation for patient {patient_id}")
        
        # If we're already in cancellation mode
        if session.get('cancellation_options'):
            if user_message.isdigit():
                option_num = user_message
                if option_num in session['cancellation_options']:
                    appt_id = session['cancellation_options'][option_num]
                    try:
                        appointment = fhir_client.read("Appointment", appt_id)
                        if appointment:
                            appointment['status'] = 'cancelled'
                            fhir_client.update("Appointment", appt_id, appointment)
                            session.pop('cancellation_options', None)
                            # Use the user_id (from phone) rather than relying on session['id'] which may not exist
                            user_id = session.get('phone_number') or session.get('user_id')
                            await update_session(user_id, session)
                            
                            # Audit the cancellation
                            from audit.utils import log_event
                            log_event(
                                actor=user_id,
                                action="appointment.cancelled",
                                resource=f"Appointment/{appt_id}",
                                meta={
                                    "patient_id": patient_id,
                                    "appointment_status": "cancelled"
                                }
                            )
                            
                            return "Your appointment has been cancelled. Is there anything else I can help you with?"
                    except Exception as e:
                        logger.error(f"Error cancelling appointment {appt_id}: {str(e)}")
                        return "There was an error cancelling your appointment. Please try again."
                return "Please select a valid appointment number from the list."
        
        # Get upcoming appointments
        current_time = datetime.now(ZoneInfo(settings.TIME_ZONE)).isoformat()
        search_params = {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "status": "booked,pending",
            "_sort": "date"
        }
        
        appointments = fhir_client.search("Appointment", search_params)
        if not appointments or 'entry' not in appointments or not appointments['entry']:
            return "You don't have any upcoming appointments to cancel."
            
        # Create numbered list of appointments
        options = {}
        messages = ["Which appointment would you like to cancel?"]
        
        for i, entry in enumerate(appointments['entry'], 1):
            appt = entry['resource']
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            local_time = start_time.astimezone(ZoneInfo(settings.TIME_ZONE))
            formatted_time = local_time.strftime("%A, %B %d at %I:%M %p")
            
            # Get practitioner info
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('type') == 'Practitioner':
                    pract_ref = participant['actor']['reference']
                    try:
                        pract = fhir_client.read("Practitioner", pract_ref.split('/')[-1])
                        if pract:
                            practitioner_name = f"Dr. {get_resource_name(pract)}"
                    except Exception as e:
                        logger.error(f"Error getting practitioner: {str(e)}")
            
            messages.append(f"{i}. {formatted_time} with {practitioner_name}")
            options[str(i)] = appt['id']
            
        # Store options in session
        session['cancellation_options'] = options
        # Use the user_id (from phone) rather than relying on session['id'] which may not exist
        user_id = session.get('phone_number') or session.get('user_id')
        await update_session(user_id, session)
        
        return "\n".join(messages)
        
    except Exception as e:
        logger.error(f"Error handling cancellation: {str(e)}")
        return "I'm sorry, I couldn't process your cancellation request at this time. Please try again later."
logger.debug("Appointment handler module initialization complete")

================
File: handlers/chat_handler.py
================
# chatbot/views/handlers/chat_handler.py

import inspect
import logging
import json
import re
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
from asgiref.sync import sync_to_async
# Django imports
from django.conf import settings
from django.http import JsonResponse
# Third-party imports
from openai import AsyncOpenAI
from twilio.rest import Client
from chatbot.views.services.fhir_service import FHIRService
from fhirclient.models.observation import Observation
from fhirclient.models.diagnosticreport import DiagnosticReport
from chatbot.views.config import config as app_config
from chatbot.views.services.language_service import LanguageService, LanguageHandler
from chatbot.views.services.session import update_session
from chatbot.views.utils.datetime_utils import format_datetime_for_user
from chatbot.views.utils.shared import get_resource_name
from chatbot.views.utils.constants import OPENAI_MODEL
import dateparser
from chatbot.views.services.intent_service import (
    detect_intent,
)
from chatbot.views.services.symptom_guidance_service import SymptomGuidanceService
from chatbot.views.handlers.symptom_guidance_handler import SymptomGuidanceHandler
from chatbot.views.services.personalized_medical_advice_service import (
    PersonalizedMedicalAdviceService,
    AsyncGPT4Client
)
from chatbot.views.handlers.medical_handler import (
    get_complete_medical_record,
)
from chatbot.views.services.fhir_service import (
    get_available_practitioners,
)
from chatbot.views.services.scheduler import search_available_slots, get_patient_appointments

from fhirclient.models.condition import Condition
from fhirclient.models.patient import Patient
from fhirclient.models.immunization import Immunization
from fhirclient.models.bundle import Bundle
from fhirclient.server import FHIRServer
# Removed debug utils imports that were causing issues

from .context_manager import ContextManager  # Import the ContextManager

logger = logging.getLogger(__name__)

MEDICAL_DISCLAIMER = """
This information is for educational purposes only and is not a substitute for professional medical advice.
Always seek the advice of your physician or other qualified health provider with any questions you may have.
"""
logger.debug("ChatHandler module loaded")
# Removed @trace_async_calls decorator that was causing issues
class ChatHandler:
    def __init__(self, session_data, user_message, user_id=None):
        # If no user_id is provided, default to the phone number in the session
        self.user_id = user_id if user_id is not None else session_data.get('phone_number')
        self.session = session_data
        self.user_message = user_message

        # Log the user_id for debugging purposes
        logger.debug(f"ChatHandler initialized for user_id: {self.user_id}")

        # Initialize FHIR service using your existing FHIRService class
        self.fhir_service = FHIRService()
        self.fhir_client = self.fhir_service  # Use fhir_service for all FHIR operations

        # Extract patient data from session if available
        self.patient = session_data.get('patient')
        if self.patient and isinstance(self.patient, dict):
            # Prefer numeric_id if available; otherwise, use 'id' or a resource ID from the patient data
            if 'numeric_id' in self.patient:
                self.patient_id = self.patient['numeric_id']
                logger.debug(f"Using numeric patient ID: {self.patient_id}")
            elif 'id' in self.patient:
                self.patient_id = self.patient['id']
                logger.debug(f"Using full patient ID: {self.patient_id}")
            elif 'resource' in self.patient and isinstance(self.patient['resource'], dict):
                self.patient_id = self.patient['resource'].get('id')
                logger.debug(f"Using resource patient ID: {self.patient_id}")
            else:
                self.patient_id = None
                logger.warning("No valid patient ID found in patient data")
        else:
            self.patient_id = None
            logger.debug("No patient data in session")

        # Initialize other attributes
        self.current_context = session_data.get('current_context')
        self.last_intent = session_data.get('last_intent')
        self.conversation_history = session_data.get('conversation_history', [])
        
        # Initialize conversation_context before updating it
        self.conversation_context = None
        # Import ContextManager here to avoid circular imports
        from .context_manager import ContextManager
        if session_data and 'conversation_context' in session_data:
            # Create a new ContextManager or initialize to empty object that can handle __dict__.update
            self.conversation_context = ContextManager(self.user_id, session_data, None)
            self.conversation_context.__dict__.update(session_data['conversation_context'])

        # Import the medical advice service
        from chatbot.views.services.personalized_medical_advice_service import PersonalizedMedicalAdviceService
        
        # Initialize the medical advice service
        self.medical_advice_service = PersonalizedMedicalAdviceService()
        
        # Import the explanation service for handling educational queries
        from chatbot.views.services.explanation_service import explanation_service
        
        # Store the singleton instance
        self.explanation_service = explanation_service
        
        # Register intent handlers.  This is the CRITICAL part.
        self.intent_handlers = {
            # Medical-related intents - all routed through central medical query handler
            'medical_info_query': self._handle_medical_query,
            'symptom_report': self._handle_medical_query,
            'issue_report': self._handle_medical_query,  # Added missing handler for issue_report
            'symptoms': self._handle_medical_query,
            'conditions': self._handle_medical_query,
            'medications': self._handle_medical_query,
            'immunizations': self._handle_medical_query,
            'vaccines': self._handle_medical_query,
            'lab_results': self._handle_medical_query,
            'lab_results_query': self._handle_medical_query,
            'screening': self._handle_medical_query,
            'height': self._handle_medical_query,
            'explanation_query': self._handle_medical_query,
 
            # Non-medical intents remain unchanged
            'medical_record': self._handle_medical_record,
            'set_appointment': self.handle_booking_flow,
            'appointment': self.handle_booking_flow,
            'show_appointments': self._handle_show_appointments,
            'nextAppointment': self._handle_show_appointments,
            'query_appointments': self._handle_show_appointments,
            'capabilities': self._handle_capabilities_query,
            'reset_context': self._handle_reset_context,
            'greeting': self._handle_greeting
        }

        # Initialize lab context
        self.lab_context = {
            'last_results': None,
            'current_topic': None
        }
        
        # These will be initialized in the initialize() method
        self.openai_client = None
        self.language_handler = None
        self.language_service = None
        self.context_manager = None
        self.current_language = None

    async def initialize(self):
        """Async initialization tasks"""
        logger.debug("[initialize] ChatHandler initialize started")
        try:
            # Initialize OpenAI client
            logger.debug("Initializing AsyncOpenAI client")
            self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
            
            # Initialize language services
            logger.debug("Initializing language services")
            self.language_service = LanguageService()
            # We need to set the openai_client in the language service
            self.language_service.openai_client = self.openai_client
            
            self.language_handler = LanguageHandler()
            # Set the openai_client in the language handler's language_service
            self.language_handler.language_service.openai_client = self.openai_client
            
            # Initialize context manager
            logger.debug("Initializing context manager")
            try:
                # Make sure user_id is not None before creating context manager
                if not self.user_id:
                    logger.warning("No user_id available, using session ID as fallback")
                    self.user_id = str(id(self.session))  # Generate a unique ID
                
                # Make sure session has conversation_history initialized
                if 'conversation_history' not in self.session:
                    self.session['conversation_history'] = []
                
                # Ensure ContextManager is imported properly - redundant with the import at the top
                # but keeps consistency with the except block pattern
                from chatbot.views.handlers.context_manager import ContextManager
                
                self.context_manager = ContextManager(
                    user_id=self.user_id,
                    session=self.session, 
                    openai_client=self.openai_client
                )
                logger.debug("Context manager initialized successfully")
            except Exception as context_error:
                logger.error(f"Error initializing context manager: {str(context_error)}", exc_info=True)
                # Create a fallback minimal context manager
                # We must import context_manager here to handle the case where the top-level import failed
                try:
                    from chatbot.views.handlers.context_manager import ContextManager
                    self.context_manager = ContextManager(
                        user_id=str(id(self.session)),  # Generate a unique ID as fallback
                        session={'conversation_history': []}, 
                        openai_client=self.openai_client
                    )
                    logger.debug("Fallback context manager initialized successfully")
                except Exception as fallback_error:
                    logger.critical(f"CRITICAL: Could not initialize fallback context manager: {str(fallback_error)}", exc_info=True)
                    # If the module couldn't be imported, create a minimal object that mimics the required interface
                    class MinimalContextManager:
                        def __init__(self, **kwargs):
                            self.session = kwargs.get('session', {'conversation_history': []})
                            self.user_id = kwargs.get('user_id', 'fallback-user')
                        
                        async def add_message(self, user_id, message):
                            if 'conversation_history' not in self.session:
                                self.session['conversation_history'] = []
                            self.session['conversation_history'].append({
                                'message': message,
                                'timestamp': datetime.now().isoformat(),
                                'is_user': True
                            })
                            return self.session
                        
                        async def get_context(self, user_id):
                            return {'summary': '', 'recent_messages': self.session.get('conversation_history', [])}
                        
                        async def get_user_facts(self, user_id):
                            return self.session.get('user_facts', {})
                        
                        async def _extract_user_facts(self, message):
                            return {}
                        
                        async def save_session(self):
                            return True
                    
                    self.context_manager = MinimalContextManager(
                        user_id=str(id(self.session)),
                        session=self.session,
                    )
                    logger.warning("Using minimal fallback context manager implementation")
            
            # Set OpenAI client for medical advice service
            logger.debug("Setting OpenAI client for medical advice service")
            if hasattr(self, 'medical_advice_service') and self.medical_advice_service is not None:
                # Ensure the openai_client is set directly at the PersonalizedMedicalAdviceService level
                self.medical_advice_service.openai_client = self.openai_client
                # Also set it for the symptom_analyzer that's within the service
                if hasattr(self.medical_advice_service, 'symptom_analyzer'):
                    self.medical_advice_service.symptom_analyzer.openai_client = self.openai_client
                # Set the gpt_client if it exists
                if hasattr(self.medical_advice_service, 'gpt_client'):
                    # Create a new AsyncGPT4Client with the API key
                    from chatbot.views.services.personalized_medical_advice_service import AsyncGPT4Client
                    self.medical_advice_service.gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
            
            # Detect language
            logger.debug("Detecting language")
            self.current_language = await self.language_service.detect_language(self.user_message)
            logger.debug(f"Language detected: {self.current_language}")
            
            logger.debug("Initialize completed successfully")
        except Exception as e:
            logger.error(f"Error in async initialization: {str(e)}", exc_info=True)
            raise
            logger.debug("(initialisation finished)")

    async def handle_message(self, message=None, **kwargs):
        """Main message handling method, now with extensive debugging."""
        logger.debug("Starting handle_message")
        logger.debug("=== ENTER handle_message ===")
        
        if message is None:
            logger.debug("No message provided, using self.user_message")
            message = self.user_message
        logger.debug(f"{message}")
        logger.debug(f"Processing message: {message}")

        # Check if we need to identify the user by phone number
        if not self.patient_id and not self.session.get('awaiting_phone_number'):
            # Check if the message might contain a phone number
            if self._is_phone_number(message):
                return await self._identify_user_by_phone(message)
            else:
                # Ask for phone number
                self.session['awaiting_phone_number'] = True
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Welcome to ANNA! To help you access your medical information, please provide your phone number."]
                }), self.session
        
        # If we're awaiting a phone number, try to process it
        if self.session.get('awaiting_phone_number') and not self.patient_id:
            # Check if this looks like a phone number
            if self._is_phone_number(message):
                return await self._identify_user_by_phone(message)
            else:
                return JsonResponse({
                    "messages": ["That doesn't look like a valid phone number. Please enter your phone number (e.g., 1234567890)."]
                }), self.session

        try:
            # Language Detection and Translation
            logger.debug("About to perform language detection")
            logger.debug("Performing language detection")
            logger.debug("Calling language_service.detect_language")
            detected_lang = await self.language_service.detect_language(self.user_message)
            logger.debug(f"{detected_lang}")
            
            if detected_lang != 'en':
                logger.debug(f"Skipping translation (disabled)")
                logger.debug(f"Skipping translation from {detected_lang} to English")
                # Skip translation and just use the original text
                english_text = self.user_message
                needs_translation = False
            else:
                logger.debug("No translation needed (English detected)")
                english_text = self.user_message
                needs_translation = False
            logger.debug(f"{english_text}")
            logger.debug(f"Text for processing: {english_text}")

            # Context management
            logger.debug("Starting context management")
            logger.debug("Adding message to context manager")
            try:
                logger.debug("Calling context_manager.add_message")
                # Initialize context with current session data to ensure it's up-to-date
                # This ensures proper context persistence between turns
                self.context_manager.session = self.session
                
                # Log the current session state before adding the message
                logger.debug(f"{self.session.get('current_topic')}")
                
                # Add the message to update the context
                await self.context_manager.add_message(self.user_id, self.user_message)
                logger.debug("Message added to context manager")
                
                # Check if the current_topic was updated properly
                logger.debug(f"{self.context_manager.session.get('current_topic')}")
            except Exception as cm_error:
                logger.debug(f"{str(cm_error)}")
                import traceback
                logger.debug(f"{traceback.format_exc()}")
                logger.error(f"Context manager error: {str(cm_error)}", exc_info=True)
                # Make sure there's a valid conversation history even if context manager fails
                if 'conversation_history' not in self.session:
                    self.session['conversation_history'] = []
                # Add current message to history directly
                self.session['conversation_history'].append({
                    'message': self.user_message,
                    'is_user': True,
                    'timestamp': datetime.now().isoformat()
                })
                await update_session(self.user_id, self.session)

            try:
                logger.debug("Getting context")
                context = await self.context_manager.get_context(self.user_id)
                logger.debug("Context retrieved")
                
                # Debug the current_topic to confirm it's being properly maintained
                current_topic = context.get("current_topic", {})
                logger.debug(f"{current_topic}")
                
                logger.debug("Getting user facts")
                user_facts = await self.context_manager.get_user_facts(self.user_id)
                logger.debug("User facts retrieved")
                
                logger.debug("Extracting user facts from message")
                new_facts = await self.context_manager._extract_user_facts(self.user_message)
                logger.debug(f"{new_facts}")
                
                # Ensure we have the most current topic from session
                # This is a critical part of fixing the missing context in follow-up questions
                current_topic = self.session.get('current_topic', context.get("current_topic", {}))
                
                # Log what we're using to debug context persistence
                logger.debug(f"{current_topic}")
                logger.debug(f"{self.session.get('current_topic')}")
                logger.debug(f"{context.get('current_topic')}")
                
                # Store the conversation context in an instance variable for medical query handling
                self.context_info = {
                    "summary": context.get("summary", ""),
                    "recent_messages": context.get("recent_messages", []),
                    "user_facts": user_facts,
                    "current_topic": current_topic  # Give priority to the session value
                }
                logger.debug(f"Stored conversation context info: {self.context_info}")
            
            except Exception as facts_error:
                logger.debug(f"{str(facts_error)}")
                import traceback
                logger.debug(f"{traceback.format_exc()}")
                logger.error(f"Facts extraction error: {str(facts_error)}", exc_info=True)
                # Set defaults if there's an error
                context = {"summary": "", "recent_messages": self.session.get('conversation_history', [])}
                user_facts = self.session.get('user_facts', {})
                new_facts = {}
                # Default context info - make sure to include current_topic if available
                current_topic = self.session.get('current_topic', {})
                self.context_info = {
                    "summary": "", 
                    "recent_messages": [], 
                    "user_facts": {},
                    "current_topic": current_topic  # Include current_topic even in error handling
                }

            if new_facts:
                logger.debug("Adding new facts to session")
                logger.debug(f"Found new facts: {new_facts}")
                if 'user_facts' not in self.session:
                    self.session['user_facts'] = {}
                # Merge them
                for k, v in new_facts.items():
                    self.session['user_facts'][k] = v
                logger.debug("Updating session with new facts")
                await update_session(self.user_id, self.session)
                logger.debug("Session updated")

            # Prepare the context for intent detection
            logger.debug("Preparing context for intent detection")
            
            # Ensure we're using the most up-to-date current_topic from session
            current_topic = self.session.get('current_topic', context.get("current_topic", {}))
            logger.debug(f"{current_topic}")
            
            context_info = {
                "summary": context["summary"],
                "recent_messages": context["recent_messages"],
                "user_facts": user_facts,
                "current_topic": current_topic  # Use the prioritized session value
            }
            logger.debug(f"{context_info}")

            # --- Intent Detection ---
            logger.debug("Starting intent detection")
            logger.debug("Detecting intent")
            try:
                logger.debug("Calling detect_intent")
                intent_data = await detect_intent(
                    user_input=english_text,
                    conversation_context=context_info,
                    last_intent=self.session.get('last_intent')
                )
                logger.debug(f"{intent_data.get('intent')}")
                logger.debug(f"Intent with context.current_topic = {context_info.get('current_topic')}")
            except Exception as intent_error:
                logger.debug(f"{str(intent_error)}")
                import traceback
                logger.debug(f"{traceback.format_exc()}")
                # Provide default intent data if there's an error
                intent_data = {"intent": "unknown", "confidence": 0.0, "entities": {}}
            logger.debug(f"Detected intent: {intent_data.get('intent')}, confidence: {intent_data.get('confidence')}")
            logger.debug(f"[handle_message] Detected intent data: {json.dumps(intent_data, indent=2)}")

            # Extract intent information
            intent = intent_data.get("intent")
            confidence = intent_data.get("confidence", 0.0)
            entities = intent_data.get("entities", {})

            responses = []

            # Check for active booking flow or booking-related intent
            if self.session.get('booking_state'):
                logger.debug("Processing active booking flow")
                # Check for cancel command first
                if english_text.lower() == 'cancel':
                    logger.debug("Cancelling booking")
                    self.session.pop('booking_state', None)
                    await update_session(self.user_id, self.session)
                    return JsonResponse({
                        "messages": ["Booking cancelled. I'm here to help you with any questions you may have."]
                    }), self.session
                
                # Continue with booking flow if not cancelled
                logger.debug("[handle_message] Handling booking flow")
                response, self.session = await self.handle_booking_flow(self.user_message)
                logger.debug(f"Booking flow returned response type: {type(response).__name__}")
                logger.debug(f"Type of response in handle_message after booking flow: {type(response)}")
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                print(f"Final response type: {type(response)}")
                print(f"Is coroutine: {inspect.iscoroutine(response)}")
                
                return response, self.session

            elif intent == "set_appointment":
                logger.debug("Processing set_appointment intent")
                # Check if this is a rescheduling request
                if any(word in english_text.lower() for word in ["reschedule", "change", "move", "modify"]):
                    logger.debug("[handle_message] Detected rescheduling request")
                    response, self.session = await self._handle_reschedule_request()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                        logger.error(f"Attempting to await the coroutine")
                        response = await response  # Try to fix it
                    
                    return response, self.session

                # Start new booking flow if it's a fresh appointment request
                logger.debug("[handle_message] Starting new booking flow")
                response, self.session = await self.handle_booking_flow(self.user_message)
                logger.debug(f"Type of response in handle_message after booking flow: {type(response)}")
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                return response, self.session

            # Store the intent data in the instance
            self.intent_data = intent_data

            # Add condition-specific routing
            if any(keyword in self.user_message.lower() for keyword in
                ['my conditions', 'my medical conditions', 'what conditions', 'show me my conditions']):
                logger.debug("Handling conditions query")
                response, self.session = await self._handle_explanation_query(self.user_message)
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                return response, self.session

            # Continue with intent handling regardless of triage classification
            if not intent:
                logger.debug("[handle_message] No intent detected")
                general_response = "I'm not sure how to help with that. Could you please rephrase?"
                if needs_translation:
                    general_response = await self.language_handler.translate_text(general_response, self.current_language)
                responses.append(general_response)
            else:
                primary_intent = intent
                logger.debug(f"[handle_message] Primary intent: {primary_intent}")
                logger.debug(f"Available handlers: {self.intent_handlers.keys()}")
                logger.debug(f"Looking for handler: {primary_intent}")
                logger.debug(f"[handle_message] Handler dict: {self.intent_handlers}")
                logger.debug(f"[handle_message] Handler type: {type(self.intent_handlers.get(primary_intent))}")

                # Add capabilities to your intent handling
                if primary_intent == 'capabilities':
                    logger.debug("Handling capabilities intent")
                    response, self.session = await self._handle_capabilities_query()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                        logger.error(f"Attempting to await the coroutine")
                        response = await response  # Try to fix it
                    
                    return response, self.session

                # Special handling for viewing appointments
                if primary_intent == 'appointment' and any(keyword in self.user_message.lower()
                    for keyword in ['show', 'view', 'my', 'upcoming']):
                    logger.debug("[handle_message] Handling show appointments request")
                    appointments_response, self.session = await self._handle_show_appointments()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(appointments_response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {appointments_response}")
                        logger.error(f"Attempting to await the coroutine")
                        appointments_response = await appointments_response  # Try to fix it
                    
                    return appointments_response, self.session

                # Special handling for appointment booking initialization
                elif primary_intent == 'appointment' and not self.session.get('booking_state'):
                    logger.debug("[handle_message] Initializing new appointment booking")
                    self.session['booking_state'] = {
                        'step': 'select_practitioner_type',
                        'appointment_info': {}
                    }
                    await self._update_session()
                    
                    messages = [
                        "What type of healthcare provider would you like to see?\n\n"
                        "1. Doctor\n"
                        "2. Nurse\n"
                        "3. Specialist\n\n"
                        "Please select a number or type 'cancel' to stop booking."
                    ]
                    if needs_translation:
                        messages = [await self.language_handler.translate_text(m, self.current_language) for m in messages]
                    responses.extend(messages)
                    
                else:
                    # Intent handlers mapping with async/sync specifications
                    intent_handlers = {
                        # Async handlers
                        'medical_record': self._handle_medical_record,
                        'medical_info_query': self._handle_symptom_report,
                        'medical_info': self._handle_medical_record,
                        'show_records': self._handle_medical_record,
                        'set_appointment': self.handle_booking_flow,
                        'appointment': self.handle_booking_flow,
                        'nextAppointment': self._handle_show_appointments,
                        'query_appointments': self._handle_show_appointments,
                        'show_appointments': self._handle_show_appointments,
                        'immunizations': self._handle_immunizations_query,
                        'vaccines': self._handle_immunizations_query,
                        'lab_results': self._handle_lab_results,
                        # Regular handlers requiring user_id
                        'height': self._handle_height_query,
                        'greeting': self._handle_greeting,
                        'conditions': self.handle_conditions_query,
                        'medications': self.handle_medications_query,
                        'capabilities': self._handle_capabilities_query,
                        'explanation_query': self._handle_explanation_query,
                    }

                    # Get the handler from the instance's intent_handlers
                    logger.debug(f"Looking for handler for intent: {primary_intent}")
                    handler = self.intent_handlers.get(primary_intent)
                    logger.debug(f"Found handler: {handler.__name__ if handler else 'None'}")

                    if handler:
                        try:
                            logger.debug(f"Calling handler with message={message}, intent_data={intent_data}")
                            response = await handler(message=message, intent_data=intent_data)
                            logger.debug(f"Handler returned response of type: {type(response).__name__}")
                            
                            # Check for unawaited coroutine
                            if inspect.iscoroutine(response):
                                logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                                logger.error(f"Attempting to await the coroutine")
                                response = await response  # Try to fix it
                            
                            print(f"Final response type: {type(response)}")
                            print(f"Is coroutine: {inspect.iscoroutine(response)}")
                            
                            # If returning a tuple, check each part
                            if isinstance(response, tuple):
                                # Create a new tuple with awaited items if needed
                                new_response = []
                                for i, item in enumerate(response):
                                    if inspect.iscoroutine(item):
                                        logger.error(f"Tuple item {i} is a coroutine!")
                                        new_response.append(await item)  # Await the coroutine
                                    else:
                                        new_response.append(item)
                                response = tuple(new_response)  # Create a new tuple
                                
                                logger.debug(f"Response is a tuple with {len(response)} items")
                                return response
                            else:
                                logger.debug("Response is not a tuple, wrapping with session")
                                return response, self.session
                        except Exception as e:
                            logger.error(f"[handle_message] Error in handler execution: {str(e)}")
                            raise
                    else:
                        logger.warning(f"[handle_message] No handler found for intent: {primary_intent}")
                        unknown_intent_response = "I'm not sure how to help with that specific request. Could you try rephrasing?"
                        if needs_translation:
                            unknown_intent_response = await self.language_handler.translate_text(
                                unknown_intent_response,
                                self.current_language
                            )
                        responses.append(unknown_intent_response)

            # Create JsonResponse at the end
            logger.debug(f"Creating final JsonResponse with {len(responses)} messages")
            logger.debug(f"Creating final JsonResponse with {len(responses)} messages")
            
            # Final check for coroutines
            if inspect.iscoroutine(responses):
                logger.debug(f"Got unawaited coroutine {responses}")
                logger.error(f"CRITICAL ERROR: Got unawaited coroutine {responses}")
                logger.error(f"Attempting to await the coroutine")
                logger.debug(f"Attempting to await the coroutine")
                responses = await responses  # Try to fix it
                logger.debug(f"Successfully awaited coroutine")
            
            logger.debug(f"{type(responses)}")
            logger.debug(f"{inspect.iscoroutine(responses)}")
            
            # Create the response object
            final_response = JsonResponse({"messages": responses})
            logger.debug(f"{type(final_response)}")
            logger.debug(f"Is JsonResponse a coroutine? {inspect.iscoroutine(final_response)}")
            
            # Create the return tuple
            return_value = (final_response, self.session)
            logger.debug(f"{type(return_value)}")
            logger.debug(f"Is return value a coroutine? {inspect.iscoroutine(return_value)}")
            
            # Return the tuple with response and session
            return return_value

        except Exception as e:
            logger.debug(f"{str(e)}")
            import traceback
            logger.debug(f"{traceback.format_exc()}")
            logger.error(f"Error handling message: {str(e)}", exc_info=True)
            
            error_response = JsonResponse({
                "messages": ["I'm sorry, something went wrong while processing your request."]
            })
            logger.debug(f"{type(error_response)}")
            logger.debug(f"Is error response a coroutine? {inspect.iscoroutine(error_response)}")
            
            return_tuple = (error_response, self.session)
            logger.debug(f"{type(return_tuple)}")
            logger.debug(f"Is error return tuple a coroutine? {inspect.iscoroutine(return_tuple)}")
            
            return return_tuple

        finally:
            # Store conversation_history and user_facts back to session
            try:
                logger.debug("Saving conversation history and user facts to session")
                logger.debug("[handle_message] Saving conversation history and user facts to session")
                await self.context_manager.save_session()
                logger.debug("Session saved successfully")
            except Exception as session_error:
                logger.debug(f"{str(session_error)}")
                import traceback
                logger.debug(f"{traceback.format_exc()}")
                logger.error(f"[handle_message] Failed to save session: {str(session_error)}", exc_info=True)
            logger.debug("Exiting handle_message")
            logger.debug("=== EXIT handle_message ===")

    async def _detect_conversation_topic(self, message):
        """Detect the topic of conversation from message and history"""
        topic_categories = {
            'respiratory': ['asthma', 'bronchitis', 'breathing', 'lung', 'respiratory'],
            'musculoskeletal': ['elbow', 'arm', 'shoulder', 'knee', 'leg', 'back'],
            'allergies': ['hayfever', 'allergic', 'allergy'],
            'symptoms': ['pain', 'hurt', 'ache', 'sore']
        }

        message_words = message.lower().split()
        current_topics = set()

        # Check current message for topics
        for category, keywords in topic_categories.items():
            if any(keyword in message_words for keyword in keywords):
                current_topics.add(category)

        # Check recent history if no topic in current message
        if not current_topics and self.conversation_history:
            recent_messages = [msg['message'].lower() for msg in self.conversation_history[-3:]]
            for msg in recent_messages:
                for category, keywords in topic_categories.items():
                    if any(keyword in msg for keyword in keywords):
                        current_topics.add(category)

        return list(current_topics) if current_topics else None
   

    async def handle_booking_flow(self, message=None, intent_data=None) -> JsonResponse:
        """Handle the booking flow state machine"""
        try:
            # Check if we're in an active booking flow
            booking_state = self.session.get('booking_state', {})

            # If we have an active booking state, handle the current step
            if booking_state and booking_state.get('step'):
                logger.debug(f"Continuing booking flow at step: {booking_state['step']}")
                step_handlers = {
                    'initial_choice': self._handle_initial_choice,
                    'select_role': self._handle_type_selection,
                    'select_practitioner': self._handle_practitioner_selection,
                    'enter_reason': self._handle_reason_entry,
                    'select_datetime': self._handle_datetime_selection,
                    'confirm_booking': self._handle_booking_confirmation
                }

                handler = step_handlers.get(booking_state['step'])
                if handler:
                    response = await handler(booking_state)
                    logger.debug(f"Type of response in handle_booking_flow after {booking_state['step']}: {type(response)}")  
                    return response
                else:
                    logger.error(f"Invalid booking step: {booking_state['step']}")
                    return await self._handle_booking_error("Invalid booking state")

            # Initialize new booking flow
            logger.debug("Initializing new booking flow")
            # Get available practitioners using FHIRService
            practitioners = await self.fhir_service.get_available_practitioners()

            if not practitioners:
                return JsonResponse({
                    "messages": ["I apologize, but no healthcare providers are currently available."]
                }), self.session

            # Initialize booking state
            self.session['booking_state'] = {
                'step': 'initial_choice',
                'appointment_info': {}
            }
            await update_session(self.user_id, self.session)

            response = JsonResponse({
                "messages": [
                    "How would you like to find a healthcare provider?\n\n"
                    "1. Search by practitioner name\n"
                    "2. Search by role (Doctor, Nurse, Specialist)\n\n"
                    "Or type 'cancel' to stop booking."
                ]
            })
            logger.debug(f"Type of response in handle_booking_flow before return: {type(response)}")  
            return response, self.session

        except Exception as e:
            logger.error(f"Error in booking flow: {str(e)}", exc_info=True)
            return await self._handle_booking_error("Error processing booking request")

    async def _handle_datetime_selection(self, booking_state):
        """
        Handle the datetime selection for appointment booking.
        This version tries multiple approaches:
        1. Direct parsing with Python's dateparser.
        2. If direct parsing fails, tries a GPT-based approach (optional).
        3. Provides clear error messages to the user.
        """
        user_input = self.user_message.lower().strip()

        # Allow the user to cancel
        if user_input == 'cancel':
            self.session.pop('booking_state', None)
            await self._update_session()
            return JsonResponse({
                "messages": ["Booking cancelled. Is there anything else I can help you with?"]
            }), self.session

        # Attempt to parse using dateparser for maximum flexibility
        parsed_datetime, error_message = await self._parse_datetime_with_timezone(user_input)
        if error_message:
            # If parsing failed, give feedback and re-ask
            return JsonResponse({"messages": [error_message]}), self.session

        # If parsed correctly, continue with slot checking
        logger.debug(f"Looking for slot at time: {parsed_datetime.isoformat()}")
        try:
            search_time = parsed_datetime.strftime("%Y-%m-%dT%H:%M:00+00:00")
            logger.debug(f"Searching for slot with time: {search_time}")

            # Search for an available slot in FHIR
            search_params = {
                'schedule': f"Schedule/{booking_state.get('schedule', '25549')}",
                'start': f"eq{search_time}",
                'status': 'free'
            }
            logger.debug(f"Search params: {search_params}")

            slots = await self.fhir_service.search("Slot", search_params)
            if not slots or 'entry' not in slots or not slots['entry']:
                return JsonResponse({
                    "messages": ["That time slot is not available. Please select another time."]
                }), self.session

            # Get the first available slot
            selected_slot = slots['entry'][0]['resource']

            # Store the slot information
            booking_state['appointment_info'].update({
                'datetime': parsed_datetime.isoformat(),
                'slot': {
                    'id': selected_slot['id'],
                    'start': selected_slot['start'],
                    'end': selected_slot['end']
                }
            })

            # Move to confirmation step
            booking_state['step'] = 'confirm_booking'
            self.session['booking_state'] = booking_state
            await self._update_session()
            formatted_time = await self._format_appointment_time(selected_slot['start'])
            return JsonResponse({
                "messages": [
                    f"Please confirm your appointment:\n\n"
                    f"Provider: {booking_state['appointment_info'].get('practitioner_name')}\n"
                    f"Type: {booking_state['appointment_info']['type'].title()}\n"
                    f"Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info'].get('reason', 'General consultation')}\n\n"
                    "Type 'confirm' to book or 'cancel' to start over."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error searching for slots: {str(e)}", exc_info=True)
            return await self._handle_booking_error("Error checking slot availability")

    async def _handle_practitioner_selection(self, booking_state):
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            if not self.user_message.isdigit():
                return JsonResponse({
                    "messages": ["Please select a practitioner by entering their number, or type 'cancel' to stop booking."]
                }), self.session

            selection = int(self.user_message)
            practitioners = self.session['booking_state'].get('practitioners', {})

            if not practitioners:
                logger.error("No practitioners dictionary in booking state")
                return self._handle_booking_error()

            if str(selection) not in practitioners:
                return JsonResponse({
                    "messages": ["Please select a valid practitioner number from the list."]
                }), self.session

            practitioner_id = practitioners[str(selection)]

            # Use the async search method instead of sync read
            search_result = await self.fhir_service.search('Practitioner', {'_id': practitioner_id})
            practitioner = search_result['entry'][0]['resource'] if search_result.get('entry') else None

            if not practitioner:
                logger.error(f"Could not fetch practitioner with ID {practitioner_id}")
                return self._handle_booking_error()

            # Update booking state
            self.session['booking_state']['selected_practitioner'] = practitioner_id
            self.session['booking_state']['appointment_info']['practitioner_name'] = get_resource_name(practitioner)
            self.session['booking_state']['step'] = 'enter_reason'  # Changed from 'confirm_booking' to 'enter_reason'
            await update_session(self.user_id, self.session)

            return JsonResponse({
                "messages": [
                    f"You've selected {self.session['booking_state']['appointment_info']['practitioner_name']}.\n\n"
                    "Please enter the reason for your visit."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in practitioner selection: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_booking_error(self, error_message=None):
        """Handle booking flow errors uniformly"""
        self.session.pop('booking_state', None)
        message = error_message or "I'm sorry, there was an error processing your booking request. Please try again."
        return JsonResponse({
            "messages": [message]
        }), self.session

    async def _handle_booking_confirmation(self, booking_state):
        """Handle final booking confirmation"""
        try:
            if self.user_message.lower() not in ['confirm', 'yes', 'y']:
                return JsonResponse({
                    "messages": ["Please type 'confirm' to book the appointment or 'cancel' to start over."]
                }), self.session

            # Get complete slot info from booking state
            slot_info = booking_state.get('appointment_info', {}).get('slot')
            if not slot_info or not all(key in slot_info for key in ['id', 'start', 'end']):
                logger.error(f"Invalid slot information in booking state: {booking_state}")
                return self._handle_booking_error()

            # Create appointment resource
            appointment_data = {
                'resourceType': 'Appointment',
                'status': 'booked',
                'slot': [{'reference': f"Slot/{slot_info['id']}"}],
                'start': slot_info['start'],
                'end': slot_info['end'],
                'participant': [
                    {
                        'actor': {'reference': f"Patient/{self.patient_id}"},
                        'status': 'accepted'
                    },
                    {
                        'actor': {'reference': f"Practitioner/{booking_state['selected_practitioner']}"},
                        'status': 'accepted'
                    }
                ],
                'appointmentType': {
                    'text': booking_state['appointment_info']['type']
                },
                'reason': [{
                    'text': booking_state['appointment_info'].get('reason', 'General consultation')
                }],
                'created': datetime.now(ZoneInfo("UTC")).isoformat()
            }

            # Create the appointment
            created = await sync_to_async(self.fhir_client.create)('Appointment', appointment_data)
            if not created:
                return self._handle_booking_error()

            # Update slot status
            slot_update = {
                'resourceType': 'Slot',
                'id': slot_info['id'],
                'status': 'busy'
            }
            await sync_to_async(self.fhir_client.update)('Slot', slot_info['id'], slot_update)

            # Clear booking state
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)

            # Format success message
            formatted_time = await self._format_appointment_time(slot_info['start'])
            return JsonResponse({
                "messages": [
                    f"Your appointment has been confirmed!\n\n"
                    f"Provider: {booking_state['appointment_info']['practitioner_name']}\n"
                    f"Type: {booking_state['appointment_info']['type'].title()}\n"
                    f"Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info'].get('reason', 'General consultation')}\n\n"
                    f"You will receive a confirmation email shortly. Is there anything else I can help you with?"
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in booking confirmation: {str(e)}")
            return self._handle_booking_error()
    
    async def _handle_symptom_report(self, message=None, intent_data=None):
        """
        Simplified symptom handler that uses the PersonalizedMedicalAdviceService
        to analyze symptoms and provide appropriate guidance.
        """
        try:
            if message is None:
                message = self.user_message
                
            logger.debug(f"Processing symptom query: {message}")
            
            # Get patient data from session if available
            patient_data = self.patient.get('resource') if self.patient else None
            
            # Use the medical advice service to handle the symptom query
            response_data = await self.medical_advice_service.handle_symptom_query(
                message, 
                patient_data
            )
            
            # Check the response data and convert to JSON response
            if isinstance(response_data, dict) and 'messages' in response_data:
                return JsonResponse(response_data), self.session
            else:
                return JsonResponse({
                    "messages": ["I couldn't analyze your symptoms. Please try again or consult a healthcare professional."]
                }), self.session
            
        except Exception as e:
            logger.error(f"Error in symptom handler: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": [
                    "I apologize, but I encountered an error processing your symptoms.",
                    "If you're experiencing a medical emergency, please call emergency services immediately."
                ]
            }), self.session
            
    async def _log_symptom_interaction(self, original_message, analysis, assessment, response):
        """Log the symptom interaction for audit purposes"""
        try:
            interaction_log = {
                'timestamp': datetime.utcnow().isoformat(),
                'patient_id': self.patient_id,
                'original_message': original_message,
                'symptom_analysis': analysis,
                'risk_assessment': assessment,
                'response_given': response,
                'session_id': self.session.get('id')
            }
            
            await sync_to_async(logger.info)(f"Symptom interaction logged: {json.dumps(interaction_log)}")
            
        except Exception as e:
            await sync_to_async(logger.error)(f"Error logging symptom interaction: {str(e)}")

    async def handle_procedures_query(self):
        """Handle request to show patient's procedures"""
        try:
            if not self.patient_id:
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Get procedures from FHIR server
            procedures = await self.fhir_client.search('Procedure',
                params={'patient': self.patient_id, '_sort': '-date'})

            if procedures and procedures.get('entry'):
                formatted_procedures = ['Your past procedures are:']
                for entry in procedures['entry']:
                    procedure = entry['resource']
                    name = procedure.get('code', {}).get('text', 'Unknown procedure')
                    date = procedure.get('performedDateTime', '').split('T')[0]
                    formatted_procedures.append(f"- {name} (Date: {date})")
                return JsonResponse({"messages": formatted_procedures}), self.session
            return JsonResponse({
                "messages": ["I couldn't find any procedures in your medical record."]
            }), self.session

        except Exception as e:
            logger.error(f"Error fetching procedures: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your procedure records right now."]
            }), self.session

    async def _create_appointment(self, slot, booking_state, parsed_datetime):
        """Create the actual appointment with all necessary details"""
        try:
            logger.info(f"Creating appointment for slot: {slot}")

            # Get the slot resource correctly
            slot_resource = slot.get('resource', slot)

            # Create the appointment resource
            appointment = {
                'resourceType': 'Appointment',
                'status': 'booked',
                'appointmentType': {
                    'coding': [{
                        'system': 'http://terminology.hl7.org/CodeSystem/v2-0276',
                        'code': booking_state['appointment_info']['type'],
                        'display': booking_state['appointment_info']['type']
                    }]
                },
                'description': booking_state['appointment_info']['reason'],
                'start': slot_resource['start'],
                'end': slot_resource['end'],
                'minutesDuration': 30,
                'slot': [
                    {'reference': f"Slot/{slot_resource['id']}"}
                ],
                'participant': [
                    {
                        'actor': {
                            'reference': f"Patient/{self.patient_id}",
                            'type': 'Patient'
                        },
                        'status': 'accepted'
                    },
                    {
                        'actor': {
                            'reference': f"Practitioner/{booking_state['selected_practitioner']}",
                            'type': 'Practitioner'
                        },
                        'status': 'accepted'
                    }
                ],
                'created': datetime.now(ZoneInfo("UTC")).isoformat()
            }

            # Create the appointment
            logger.info("Attempting to create appointment in FHIR")
            created_appointment = await self.fhir_client.create('Appointment', appointment)

            if not created_appointment:
                raise Exception("Failed to create appointment in FHIR")

            # Update the slot status to booked
            logger.info("Updating slot status to booked")
            slot_resource['status'] = 'busy'
            await self.fhir_client.update('Slot', slot_resource['id'], slot_resource)

            # Clear booking state
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)

            # Format the confirmation message
            clinic_tz = self._get_clinic_timezone()
            formatted_time = await self._format_appointment_time(parsed_datetime.isoformat())

            return JsonResponse({
                "messages": [
                    f"Great! I've booked your {booking_state['appointment_info']['type']} appointment:\n\n"
                    f"Provider: Dr. {booking_state['appointment_info']['practitioner_name']}\n"
                    f"Date/Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info']['reason']}\n\n"
                    "You'll receive a confirmation email shortly. Is there anything else I can help you with?"
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error creating appointment: {str(e)}", exc_info=True)
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm sorry, there was an error creating your appointment. Please try again."]
            }), self.session

    def send_message(self, to_number, message):
        """Send SMS message using Twilio"""
        try:
            client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
            message = client.messages.create(
                body=message,
                from_=settings.TWILIO_PHONE_NUMBER,
                to=to_number
            )
            logger.info(f"SMS sent successfully to {to_number}: {message.sid}")
            return True
        except Exception as e:
            logger.error(f"Error sending SMS to {to_number}: {str(e)}")
            return False
            
    def _is_phone_number(self, text):
        """Check if text looks like a phone number"""
        # Remove common phone number formatting
        digits_only = ''.join(c for c in text if c.isdigit())
        
        # Check if we have a reasonable number of digits for a phone number
        # Most phone numbers are 10-15 digits
        return 7 <= len(digits_only) <= 15
        
    async def _identify_user_by_phone(self, phone_input):
        """Identify a user by their phone number and fetch their data"""
        try:
            # Clean the phone number - remove non-digits
            phone_number = ''.join(c for c in phone_input if c.isdigit())
            
            # Format with country code if needed
            if len(phone_number) == 10 and not phone_number.startswith('1'):
                # Add US country code for 10-digit numbers
                phone_number = '1' + phone_number
                
            logger.info(f"Attempting to identify user by phone number: {phone_number}")
            
            # Try to find a patient directly using FHIR search
            try:
                # Try multiple search patterns for phone numbers
                search_attempts = [
                    {'telecom': f"phone|{phone_number}"},
                    {'telecom': phone_number}
                ]
                
                # Try each search pattern
                for params in search_attempts:
                    logger.info(f"Trying search with params: {params}")
                    result = await self.fhir_service.search('Patient', params)
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                        logger.info(f"Found patient using params: {params}")
                        break
                else:
                    # Get the first patient for demo/testing purposes
                    logger.info("No patient found with phone, using first patient for demo")
                    result = await self.fhir_service.search('Patient', {'_count': '1'})
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                    else:
                        patient = None
            except Exception as e:
                logger.error(f"Error searching for patient: {str(e)}")
                patient = None
            
            if not patient:
                # No patient found with this phone number
                self.session['awaiting_phone_number'] = False  # Reset the flag
                await update_session(self.user_id, self.session)
                
                return JsonResponse({
                    "messages": [
                        "I couldn't find a patient record with that phone number.",
                        "Please check the number and try again, or contact support for assistance."
                    ]
                }), self.session
            
            # Store in session
            self.session['patient'] = {
                'resource': patient,
                'id': patient.get('id'),
                'phone_number': phone_number
            }
            self.patient = self.session['patient']
            self.patient_id = patient.get('id')
            
            # Clear the awaiting flag
            self.session['awaiting_phone_number'] = False
            
            # Update current_topic in session to track context for follow-up questions
            self.session['current_topic'] = {
                'name': 'patient_identification',
                'type': 'authentication',
                'last_updated': datetime.now().isoformat()
            }
            
            # Save the session with all updates
            await update_session(self.user_id, self.session)
            
            # Get patient name for greeting
            name = patient.get('name', [{}])[0]
            given_name = name.get('given', [''])[0] if name else ''
            
            return JsonResponse({
                "messages": [
                    f"Thank you! I've found your records, {given_name}.",
                    "How can I assist you with your healthcare today?"
                ]
            }), self.session
            
        except Exception as e:
            logger.error(f"Error identifying user by phone: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble processing your request. Please try again later."]
            }), self.session

    async def _handle_show_appointments(self, message=None, intent_data=None, user_id=None):
        """Handle showing appointments for a user.

        Args:
            message: The user's message
            intent_data: Intent data from NLP
            user_id: The user's ID (optional, falls back to self.user_id)
        """
        try:
            if not self.patient or not self.patient.get('email'):
                return JsonResponse({
                    "messages": ["Please verify your email first to view your appointments."]
                }), self.session

            patient_email = self.patient['email']
            patient_id = self.patient['id']
            logger.info(f"Fetching appointments for patient email: {patient_email}")

            # Get current time in UTC
            current_time = datetime.now(ZoneInfo("UTC")).isoformat()

            # Search for appointments using patient ID directly
            appointment_params = {
                "patient": f"Patient/{patient_id}",
                "date": f"ge{current_time}",
                "_sort": "date"
            }

            logger.debug(f"Searching appointments with params: {appointment_params}")
            appointments = await self.fhir_service.search("Appointment", appointment_params)

            if not appointments or 'entry' not in appointments or not appointments['entry']:
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments scheduled."]
                }), self.session

            # Format appointments
            messages = ["Here are your upcoming appointments:"]

            for entry in appointments['entry']:
                appointment = entry['resource']

                # Skip non-booked appointments
                if appointment.get('status') not in ['booked', 'pending']:
                    continue

                # Format the appointment time
                start_time = datetime.fromisoformat(appointment['start'].replace('Z', '+00:00'))
                formatted_time = await self._format_appointment_time(appointment['start'])

                # Get practitioner info from participants
                practitioner_name = "Unknown Provider"
                for participant in appointment.get('participant', []):
                    actor = participant.get('actor', {})
                    if actor.get('type') == 'Practitioner' or 'Practitioner/' in actor.get('reference', ''):
                        practitioner_ref = actor['reference'].split('/')[-1]
                        practitioner = await sync_to_async(self.fhir_service.read)('Practitioner', practitioner_ref)
                        if practitioner:
                            practitioner_name = get_resource_name(practitioner)
                        break

                # Build appointment info string
                appt_info = f"- {formatted_time} with {practitioner_name}"

                # Add reason if available
                if appointment.get('description'):
                    appt_info += f" ({appointment['description']})"
                elif appointment.get('reason'):
                    appt_info += f" ({appointment['reason'][0].get('text', 'No reason provided')})"

                messages.append(appt_info)

            if len(messages) == 1:  # Only header message
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments scheduled."]
                }), self.session

            return JsonResponse({
                "messages": messages
            }), self.session

        except Exception as e:
            logger.error(f"Error showing appointments: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm sorry, I couldn't retrieve your appointments at this time. Please try again later."]
            }), self.session

    async def _handle_height_query(self):
        """Handle request to show patient's height"""
        try:
            logger.debug("Handling height query")
            if not self.patient or not self.patient.get('resource'):
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Get height from patient resource extensions
            patient_resource = self.patient['resource']
            height_extension = next(
                (ext for ext in patient_resource.get('extension', [])
                 if ext['url'] == "http://example.org/fhir/StructureDefinition/height"),
                None
            )

            if height_extension and 'valueQuantity' in height_extension:
                height_value = height_extension['valueQuantity']['value']
                height_unit = height_extension['valueQuantity']['unit']
                logger.debug(f"Found height: {height_value} {height_unit}")
                return JsonResponse({"messages": [f"Your height is {height_value} {height_unit}."]}), self.session

            return JsonResponse({"messages": ["I couldn't find your height information in your records."]}), self.session

        except Exception as e:
            logger.error(f"Error fetching height: {str(e)}", exc_info=True)
            return JsonResponse({"messages": ["I'm sorry, I couldn't retrieve your height information at this time."]}), self.session

    async def _handle_greeting(self, message=None, intent_data=None):
        try:
            if self.patient and self.patient.get('resource'):
                name = self.patient['resource'].get('name', [{}])[0]
                if name and name.get('given') and name.get('family'):
                    greeting = f"Hello {name.get('given', [''])[0]} {name.get('family')}! How can I help you today?"
                    return JsonResponse({"messages": [greeting]}), self.session

            return JsonResponse({"messages": ["Hello! How can I help you today?"]}), self.session
        except Exception as e:
            logger.error(f"Error in greeting: {str(e)}")
            return JsonResponse({"messages": ["Hello! How can I help you today?"]}), self.session

    async def handle_medications_query(self):
        """Handle request to show patient's medications"""
        try:
            if not self.patient_id:
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Wrap synchronous search methods with sync_to_async
            medication_statements = await sync_to_async(self.fhir_client.search)('MedicationStatement',
                params={'patient': f"Patient/{self.patient_id}", 'status': 'active'})

            medication_requests = await sync_to_async(self.fhir_client.search)('MedicationRequest',
                params={'patient': f"Patient/{self.patient_id}", 'status': 'active'})

            medications = []

            # Process MedicationStatements
            if medication_statements and medication_statements.get('entry'):
                for entry in medication_statements['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display', 'Unknown medication')
                    dosage = med.get('dosage', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")

            # Process MedicationRequests
            if medication_requests and medication_requests.get('entry'):
                for entry in medication_requests['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text', 'Unknown medication')
                    dosage = med.get('dosageInstruction', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")

            if medications:
                formatted_meds = ['Your current medications are:']
                formatted_meds.extend(medications)
                await update_session(self.user_id, self.session)
                return JsonResponse({"messages": formatted_meds}), self.session

            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I couldn't find any active medications in your records."]
            }), self.session

        except Exception as e:
            logger.error(f"Error fetching medications: {str(e)}", exc_info=True)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your medication records right now."]
            }), self.session

    async def _handle_medical_record(self):
        logger.debug("=== Medical Record Query Debug ===")
        logger.debug(f"Patient data: {self.patient}")
        logger.debug(f"Patient ID: {self.patient_id}")

        """Handle request to show complete medical record"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't access your medical records. Please ensure you're logged in."]
                }), self.session

            # Initialize the record list
            record = []
            patient_resource = self.patient['resource']

            # Basic Information
            record.append("PERSONAL INFORMATION:")
            name = patient_resource.get('name', [{}])[0]
            full_name = f"{name.get('given', [''])[0]} {name.get('family', '')}"
            record.append(f"Name: {full_name}")
            record.append(f"Gender: {patient_resource.get('gender', 'Not specified')}")
            record.append(f"Birth Date: {patient_resource.get('birthDate', 'Not specified')}")

            # Vital Signs
            record.append("\nVITAL SIGNS:")
            for extension in patient_resource.get('extension', []):
                if extension['url'].endswith('height'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Height: {value.get('value')} {value.get('unit')}")
                elif extension['url'].endswith('weight'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Weight: {value.get('value')} {value.get('unit')}")

            # Contact Information
            record.append("\nCONTACT INFORMATION:")
            for telecom in patient_resource.get('telecom', []):
                system = telecom.get('system', '').title()
                value = telecom.get('value', '')
                record.append(f"{system}: {value}")

            # Emergency Contacts
            record.append("\nEMERGENCY CONTACTS:")
            contacts = await sync_to_async(self.fhir_client.search)("RelatedPerson", {
                "patient": f"Patient/{self.patient_id}"
            })
            if contacts and contacts.get('entry'):
                for entry in contacts['entry']:
                    contact = entry['resource']
                    relationship = contact.get('relationship', [{}])[0].get('text', 'Contact')
                    name = contact.get('name', [{}])[0]
                    contact_name = f"{name.get('given', [''])[0]} {name.get('family', '')}"
                    record.append(f"- {relationship}: {contact_name}")
                    for telecom in contact.get('telecom', []):
                        record.append(f"  {telecom.get('system', '').title()}: {telecom.get('value', '')}")
            else:
                record.append("No emergency contacts listed")

            # Allergies
            record.append("\nALLERGIES:")
            allergies = await sync_to_async(self.fhir_client.search)("AllergyIntolerance", {
                "patient": f"Patient/{self.patient_id}"
            })
            if allergies and allergies.get('entry'):
                for entry in allergies['entry']:
                    allergy = entry['resource']
                    substance = (allergy.get('code', {}).get('text') or
                               allergy.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown'))
                    severity = allergy.get('reaction', [{}])[0].get('severity', 'unknown')
                    record.append(f"- {substance} (Severity: {severity})")
            else:
                record.append("No known allergies")

            # Social History
            record.append("\nSOCIAL HISTORY:")
            social_history = await sync_to_async(self.fhir_client.search)("Observation", {
                "patient": f"Patient/{self.patient_id}",
                "category": "social-history"
            })
            if social_history and social_history.get('entry'):
                for entry in social_history['entry']:
                    observation = entry['resource']
                    record.append(f"- {observation.get('code', {}).get('text')}: {observation.get('valueString', '')}")
            else:
                record.append("No social history recorded")

            # Healthcare Providers
            record.append("\nHEALTHCARE PROVIDERS:")
            providers = await sync_to_async(self.fhir_client.search)("PractitionerRole", {
                "patient": f"Patient/{self.patient_id}"
            })
            if providers and providers.get('entry'):
                for entry in providers['entry']:
                    provider = entry['resource']
                    role = provider.get('specialty', [{}])[0].get('text', 'Healthcare Provider')
                    practitioner = provider.get('practitioner', {}).get('display', 'Unknown')
                    record.append(f"- {role}: Dr. {practitioner}")
            else:
                record.append("No healthcare providers listed")

            # ----------- Fetching Medical Conditions -----------
            try:
                # First attempt: Fetch active, relapse, and recurrence conditions sorted by recorded-date
                conditions = await sync_to_async(self.fhir_client.search)("Condition", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-recorded-date",  # Corrected sort parameter
                    "clinical-status": "active,relapse,recurrence"  # Ensure these are valid statuses
                })

                logger.debug(f"Conditions response: {json.dumps(conditions)}")  # Debug logging

                # If no conditions found, try fetching all conditions sorted by recorded-date
                if not conditions or not conditions.get('entry'):
                    conditions = await sync_to_async(self.fhir_client.search)("Condition", {
                        "patient": f"Patient/{self.patient_id}",
                        "_sort": "-recorded-date"  # Corrected sort parameter
                    })
                    logger.debug(f"Conditions response after second attempt: {json.dumps(conditions)}")  # Debug logging

                if conditions and conditions.get('entry'):
                    record.append("\nMEDICAL CONDITIONS:")
                    for entry in conditions['entry']:
                        condition = entry['resource']

                        # Extract condition name
                        name = (condition.get('code', {}).get('text') or
                                condition.get('code', {}).get('coding', [{}])[0].get('display') or
                                'Unknown condition')

                        # Extract clinical status
                        clinical_status_obj = condition.get('clinicalStatus', {})
                        clinical_status = (clinical_status_obj.get('text') or
                                           clinical_status_obj.get('coding', [{}])[0].get('display') or
                                           clinical_status_obj.get('coding', [{}])[0].get('code', 'unknown'))

                        # Extract verification status
                        verification_obj = condition.get('verificationStatus', {})
                        verification_status = (verification_obj.get('text') or
                                               verification_obj.get('coding', [{}])[0].get('display') or
                                               verification_obj.get('coding', [{}])[0].get('code', ''))

                        # Extract onset date
                        onset_date = None
                        if condition.get('onsetDateTime'):
                            onset_date = condition['onsetDateTime'].split('T')[0]
                        elif condition.get('onsetPeriod', {}).get('start'):
                            onset_date = condition['onsetPeriod']['start'].split('T')[0]
                        elif condition.get('onsetString'):
                            onset_date = condition['onsetString']

                        # Build condition line
                        condition_line = f"- {name}"
                        if clinical_status and clinical_status.lower() != 'active':
                            condition_line += f" (Status: {clinical_status})"
                        if onset_date:
                            condition_line += f" (Onset: {onset_date})"
                        if verification_status and verification_status.lower() != 'confirmed':
                            condition_line += f" ({verification_status})"

                        record.append(condition_line)

                        # Add condition notes if available
                        if condition.get('note'):
                            for note in condition['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nMEDICAL CONDITIONS:")
                    record.append("No current medical conditions found")
            except Exception as e:
                logger.error(f"Error fetching conditions: {str(e)}", exc_info=True)
                record.append("\nMEDICAL CONDITIONS:")
                record.append("Error retrieving conditions")

            # ----------- Fetching Medications -----------
            try:
                medications = await sync_to_async(self.fhir_client.search)("MedicationRequest", {
                    "patient": f"Patient/{self.patient_id}",
                    "status": "active"
                })

                if medications and medications.get('entry'):
                    record.append("\nCURRENT MEDICATIONS:")
                    for entry in medications['entry']:
                        med = entry['resource']
                        name = (med.get('medicationCodeableConcept', {}).get('text') or
                                med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or
                                'Unknown medication')

                        dosage = med.get('dosageInstruction', [{}])[0]
                        dosage_text = (dosage.get('text') or
                                       f"{dosage.get('timing', {}).get('repeat', {}).get('frequency', 'as needed')} times per day")

                        record.append(f"- {name} ({dosage_text})")

                        # Add medication notes if available
                        if med.get('note'):
                            for note in med['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nCURRENT MEDICATIONS:")
                    record.append("No active medications found")

            except Exception as e:
                logger.error(f"Error fetching medications: {str(e)}")
                record.append("\nCURRENT MEDICATIONS:")
                record.append("Error retrieving medications")

            # ----------- Fetching Procedures -----------
            try:
                procedures = await sync_to_async(self.fhir_client.search)("Procedure", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-recorded-date"  # Corrected sort parameter
                })

                if procedures and procedures.get('entry'):
                    record.append("\nPAST PROCEDURES:")
                    for entry in procedures['entry']:
                        procedure = entry['resource']
                        name = (procedure.get('code', {}).get('text') or
                                procedure.get('code', {}).get('coding', [{}])[0].get('display') or
                                'Unknown procedure')

                        date = procedure.get('performedDateTime', '').split('T')[0]
                        status = procedure.get('status', 'unknown')

                        procedure_line = f"- {name}"
                        if date:
                            procedure_line += f" (Date: {date})"
                        if status != 'completed':
                            procedure_line += f" (Status: {status})"

                        record.append(procedure_line)

                        # Add procedure notes if available
                        if procedure.get('note'):
                            for note in procedure['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nPAST PROCEDURES:")
                    record.append("No procedures found")

            except Exception as e:
                logger.error(f"Error fetching procedures: {str(e)}")
                record.append("\nPAST PROCEDURES:")
                record.append("Error retrieving procedures")

            # ----------- Fetching Immunizations -----------
            try:
                immunizations = await sync_to_async(self.fhir_client.search)("Immunization", {
                    "patient": f"Patient/{self.patient_id}"
                })

                if immunizations and immunizations.get('entry'):
                    record.append("\nIMMUNIZATIONS:")
                    for entry in immunizations['entry']:
                        immunization = entry['resource']
                        vaccine = (immunization.get('vaccineCode', {}).get('text') or
                                   immunization.get('vaccineCode', {}).get('coding', [{}])[0].get('display') or
                                   'Unknown vaccine')

                        date = immunization.get('occurrenceDateTime', '').split('T')[0]
                        status = immunization.get('status', 'unknown')

                        record.append(f"- {vaccine} (Date: {date}, Status: {status})")

                        # Add immunization notes if available
                        if immunization.get('note'):
                            for note in immunization['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nIMMUNIZATIONS:")
                    record.append("No immunization records found")

            except Exception as e:
                logger.error(f"Error fetching immunizations: {str(e)}")
                record.append("\nIMMUNIZATIONS:")
                record.append("Error retrieving immunizations")

            # Compile and return the complete medical record
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["Here is your complete medical record:\n\n" + "\n".join(record)]
            }), self.session

        except Exception as e:
            logger.error(f"Error handling medical record query: {str(e)}", exc_info=True)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your medical records right now."]
            }), self.session

    async def _handle_initial_choice(self):
        """Handle initial choice for finding healthcare provider"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            if not self.user_message.isdigit() or self.user_message not in ['1', '2']:
                return JsonResponse({
                    "messages": [
                        "Please select a valid option:\n\n"
                        "1. Search by practitioner name\n"
                        "2. Search by role (Doctor, Nurse, Specialist)\n\n"
                        "Or type 'cancel' to stop booking."
                    ]
                }), self.session

            if self.user_message == '1':
                # Search by name
                practitioners = await self.fhir_service.get_available_practitioners()
                if not practitioners:
                    return JsonResponse({
                        "messages": ["I apologize, but no healthcare providers are currently available."]
                    }), self.session

                messages = ["Please select a practitioner by number:"]
                practitioner_map = {}
                for i, pract in enumerate(practitioners, 1):
                    name = pract['name']
                    specialty = pract.get('specialty', 'General Practice')
                    messages.append(f"{i}. {name} - {specialty}")
                    practitioner_map[str(i)] = pract['id']

                messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

                # Update booking state
                self.session['booking_state']['practitioners'] = practitioner_map
                self.session['booking_state']['step'] = 'select_practitioner'
                await update_session(self.user_id, self.session)

                return JsonResponse({"messages": messages}), self.session

            else:  # self.user_message == '2'
                # Get available practitioners
                practitioners = await self.fhir_service.get_available_practitioners()
                if not practitioners:
                    return JsonResponse({
                        "messages": ["I apologize, but no healthcare providers are currently available."]
                    }), self.session

                # Get unique roles
                roles = sorted(set(p.get('role', 'General Practitioner') for p in practitioners))
                messages = ["Please select a healthcare provider role:"]
                role_map = {}
                for i, role in enumerate(roles, 1):
                    messages.append(f"{i}. {role}")
                    role_map[str(i)] = role

                messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

                # Update booking state
                self.session['booking_state']['roles'] = role_map
                self.session['booking_state']['step'] = 'select_role'
                await update_session(self.user_id, self.session)

                return JsonResponse({"messages": messages}), self.session

        except Exception as e:
            logger.error(f"Error handling initial choice: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_name_search(self, booking_state):
        """Handle practitioner name search"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            # Search for practitioner by name
            practitioners = await self.fhir_service.get_available_practitioners(name=self.user_message)

            if not practitioners:
                return JsonResponse({
                    "messages": [
                        "No practitioners found with that name. Please try again with a different name.\n"
                        "Or type 'cancel' to stop booking."
                    ]
                }), self.session

            # Store practitioners and move to reason entry
            booking_state['practitioners'] = {str(i): p['id'] for i, p in enumerate(practitioners, 1)}
            booking_state['step'] = 'enter_reason'
            booking_state['selected_practitioner'] = practitioners[0]['id']  # Since we're searching by name
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            practitioner_name = await get_resource_name(practitioners[0])
            return JsonResponse({
                "messages": [
                    f"Found Dr. {practitioner_name}.\n\n"
                    "Please provide a brief reason for your visit.\n"
                    "Or type 'cancel' to stop booking."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in name search: {str(e)}", exc_info=True)
            return self._handle_booking_error()


    async def _handle_immunizations_query(self):
        """Handle immunization/vaccine queries"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't find your patient records."]
                }), self.session

            medical_record = await get_complete_medical_record(self.patient_id)

            # Extract immunizations section from medical record
            if isinstance(medical_record, str):
                immunizations_section = ""
                capture_immunizations = False
                immunizations = []

                for line in medical_record.split('\n'):
                    if 'Immunizations:' in line:
                        capture_immunizations = True
                        continue
                    elif capture_immunizations and line.strip() and not line.startswith('7.'):
                        immunizations.append(line.strip())
                    elif capture_immunizations and line.startswith('7.'):
                        break

                if immunizations:
                    response = ["Your immunization record includes:"]
                    response.extend([f"- {imm}" for imm in immunizations if imm.strip()])
                    return JsonResponse({"messages": response})
            return JsonResponse({
                "messages": ["I couldn't find any immunization records in your file."]
            }), self.session

        except Exception as e:
            logger.error(f"Error handling immunizations query: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your immunization records right now."]
            }), self.session

    async def detect_language(self, text):
        try:
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a language detector. Respond only with the ISO language code."},
                    {"role": "user", "content": f"What language is this: {text}"}
                ]
            )
            detected = response.choices[0].message.content.strip().lower()
            # Ensure we return a string, not any other type
            return str(detected) if detected else 'en'
        except Exception as e:
            logger.error(f"Error detecting language: {str(e)}")
            return 'en'  # Default to English on error


    async def handle_conditions_query(self):
        """Handle request to view patient conditions"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't find your patient records."]
                }), self.session

            # Use sync_to_async to wrap the synchronous search method
            search_params = {
                "patient": f"Patient/{self.patient_id}",
                "_sort": "-recorded-date"
            }

            conditions_bundle = await sync_to_async(self.fhir_client.search)("Condition", search_params)

            if not conditions_bundle or 'entry' not in conditions_bundle:
                return JsonResponse({
                    "messages": ["I don't see any recorded conditions in your medical record."]
                }), self.session

            # Format conditions into readable text
            conditions_list = ["Your current conditions are:"]
            for entry in conditions_bundle['entry']:
                condition = entry['resource']
                name = condition.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown condition')
                status = condition.get('clinicalStatus', {}).get('coding', [{}])[0].get('code', 'unknown')

                condition_text = f"- {name} (Status: {status})"
                conditions_list.append(condition_text)
            return JsonResponse({
                "messages": conditions_list
            }), self.session

        except Exception as e:
            logger.error(f"Error retrieving conditions: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your conditions right now. Please try again later."]
            }), self.session



    async def _handle_type_selection(self, booking_state):
        """Handle selection of practitioner role"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            roles = booking_state.get('roles', {})
            if not roles:
                logger.error("No roles dictionary in booking state")
                return self._handle_booking_error()

            if not self.user_message.isdigit() or self.user_message not in roles:
                messages = ["Please select a valid role number:"]
                for i, role in roles.items():
                    messages.append(f"{i}. {role}")
                messages.append("\nOr type 'cancel' to stop booking.")
                return JsonResponse({"messages": messages}), self.session

            selected_role = roles[self.user_message]

            # Get practitioners with the selected role
            all_practitioners = await self.fhir_service.get_available_practitioners()
            role_practitioners = [p for p in all_practitioners if p.get('role') == selected_role]

            if not role_practitioners:
                return JsonResponse({
                    "messages": [f"I apologize, but no {selected_role}s are currently available."]
                }), self.session

            # Create numbered list of practitioners
            messages = [f"Please select a {selected_role} by number:"]
            practitioner_map = {}
            for i, pract in enumerate(role_practitioners, 1):
                name = pract['name']
                specialty = pract.get('specialty', 'General Practice')
                messages.append(f"{i}. {name} - {specialty}")
                practitioner_map[str(i)] = pract['id']

            messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

            # Update booking state
            booking_state['practitioners'] = practitioner_map
            booking_state['step'] = 'select_practitioner'
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            return JsonResponse({"messages": messages}), self.session

        except Exception as e:
            logger.error(f"Error handling role selection: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_reason_entry(self, booking_state):
        """Handle the entry of appointment reason"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            # Store the reason and update step
            booking_state['appointment_info']['reason'] = self.user_message
            booking_state['step'] = 'select_datetime'
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            return JsonResponse({
                "messages": [
                    "Please enter your preferred date and time for the appointment.\n\n"
                    "For example:\n"
                    "- Tomorrow at 2pm\n"
                    "- Next Tuesday at 10:30am\n"
                    "- December 1st at 3pm\n\n"
                    "Our hours are 9 AM to 5 PM, Monday through Friday."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in reason entry: {str(e)}")
            return self._handle_booking_error()

    async def _parse_datetime_with_timezone(self, datetime_string):
        """
        Parse a natural language datetime string with multiple fallback strategies:
        1. Attempt direct parsing with 'dateparser'.
        2. Validate business hours and days.
        3. If fails, return a helpful error message.

        Returns:
            (datetime or None, error_message or None)
        """
        try:
            # 1. Use dateparser for natural language date-time handling.
            #    Set a base reference time if needed, e.g., now in UTC.
            now = datetime.now(ZoneInfo("UTC"))
            parsed = dateparser.parse(
                datetime_string,
                settings={
                    'RETURN_AS_TIMEZONE_AWARE': True,
                    'TIMEZONE': 'UTC',
                    'RELATIVE_BASE': now,
                    'PREFER_DATES_FROM': 'future'
                }
            )

            if not parsed:
                # Could not parse at all
                return None, "I couldn't understand that date/time. Please try a more standard format like 'December 9th at 1pm' or 'next Monday at 2 PM'."

            # If the parsed date is today or in the past, assume user meant next occurrence
            if parsed.date() <= now.date():
                # Get the target weekday (0 = Monday, 6 = Sunday)
                target_weekday = parsed.weekday()
                current_weekday = now.weekday()

                # Calculate days until next occurrence
                days_ahead = target_weekday - current_weekday
                if days_ahead <= 0:  # Target day already passed this week
                    days_ahead += 7

                # Adjust the date to next occurrence
                parsed = parsed.replace(year=now.year, month=now.month, day=now.day) + timedelta(days=days_ahead)

            # 2. Validate business rules: Monday-Friday, 9-17 hours
            if parsed.weekday() >= 5:
                # Weekend
                return None, "We are only open Monday through Friday. Please choose a weekday."

            # Business hours check
            if not (9 <= parsed.hour < 17):
                return None, "Our hours are 9 AM to 5 PM. Please select a time within these hours."

            # Round to the nearest 30-minute increment
            minutes = parsed.minute
            rounded_minutes = 0 if minutes < 30 else 30
            parsed = parsed.replace(minute=rounded_minutes, second=0, microsecond=0)

            return parsed, None

        except Exception as e:
            logger.error(f"Error parsing datetime: {str(e)}", exc_info=True)
            return None, "There was an error processing your date/time selection. Please try again."
    async def _format_appointment_time(self, datetime_str):
        """
        Format datetime string into user-friendly format.
        Args:
            datetime_str: ISO format datetime string
        Returns:
            Formatted string like "Tuesday, November 21st at 2:00 PM"
        """
        try:
            # Parse the ISO datetime string
            if isinstance(datetime_str, str):
                if datetime_str.endswith('Z'):
                    datetime_str = datetime_str[:-1] + '+00:00'
                dt = datetime.fromisoformat(datetime_str)
            else:
                dt = datetime_str

            # Ensure timezone is UTC if none specified
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=ZoneInfo("UTC"))

            # Convert to local timezone
            local_dt = dt.astimezone(ZoneInfo(settings.TIME_ZONE))

            # Format date components
            day_name = local_dt.strftime("%A")
            month = local_dt.strftime("%B")
            day = local_dt.day

            # Add ordinal suffix
            suffix = "th" if 11 <= day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(day % 10, "th")

            # Format time
            time_str = local_dt.strftime("%I:%M %p").lstrip("0")

            return f"{day_name}, {month} {day}{suffix} at {time_str}"

        except Exception as e:
            logger.error(f"Error formatting appointment time: {str(e)}", exc_info=True)
            return str(datetime_str)


    async def _handle_appointment_booking(self, message, intent_data=None, user_id=None):
        """Handle appointment booking requests"""
        try:
            logger.debug("Handling appointment booking request")

            # Get available practitioners
            practitioners = await get_available_practitioners(self.fhir_client)

            # Get available slots
            available_slots = await search_available_slots(self.fhir_client)

            if not practitioners or not available_slots:
                return JsonResponse({
                    "messages": ["I apologize, but there are no available appointment slots at this time."],
                    "type": "error"
                }), self.session
                
            # Initialize the booking state with initial_choice step (not select_practitioner_type)
            # This fixes the mismatch with the step names in handle_booking_flow
            self.session['booking_state'] = {
                'step': 'initial_choice',  # Changed from 'select_practitioner_type' to match handler
                'practitioners': practitioners,
                'slots': available_slots,
                'appointment_info': {}
            }
            await update_session(self.user_id, self.session)

            return JsonResponse({
                "messages": ["Please select a healthcare provider and preferred time from the available slots:"],
                "type": "appointment_booking",
                "data": {
                    "practitioners": practitioners,
                    "available_slots": available_slots
                }
            }), self.session

        except Exception as e:
            logger.error(f"Error handling appointment booking: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I apologize, but I couldn't process your appointment booking request at this time."],
                "type": "error"
            }), self.session

    async def _handle_reschedule_request(self):
        """Handle appointment rescheduling requests."""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["Please verify your identity first to reschedule appointments."]
                }), self.session

            # Fetch upcoming appointments
            appointments = await get_patient_appointments(self.patient_id)
            if not appointments:
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments to reschedule."]
                }), self.session

            # Format appointment list for selection
            messages = ["Which appointment would you like to reschedule?"]
            appointment_map = {}
            for i, appt in enumerate(appointments, 1):
                formatted_time = await self._format_appointment_time(appt["start"])
                messages.append(f"{i}. {formatted_time} with {appt['provider']}")
                appointment_map[str(i)] = appt["id"]

            messages.append("\nEnter the number of the appointment you'd like to reschedule.")

            # Store selection context
            self.session["reschedule_options"] = appointment_map
            await update_session(self.user_id, self.session)

            return JsonResponse({"messages": messages})
        except Exception as e:
            logger.error(f"Error handling reschedule request: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble retrieving your appointments. Please try again later."]
            }), self.session

    async def _handle_lab_results(self, message=None, intent_data=None, user_id=None):
        """Handle requests to view lab results"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["Please verify your identity first to view your lab results."]
                }), self.session

            logger.debug(f"Fetching lab results for patient {self.patient_id}")

            # Try a simpler query first
            try:
                # First, try just getting DiagnosticReport without includes
                diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-date"
                })

                logger.debug(f"Initial query response: {diagnostic_reports}")

                if not diagnostic_reports or 'entry' not in diagnostic_reports:
                    # Try alternative category coding
                    diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                        "patient": f"Patient/{self.patient_id}",
                        "category": "LAB",
                        "_sort": "-date"
                    })
                    if not diagnostic_reports or 'entry' not in diagnostic_reports:
                        return JsonResponse({
                            "messages": ["No lab results found in your records."]
                        }), self.session

            except Exception as query_error:
                logger.error(f"Error in initial lab results query: {str(query_error)}")
                # Try fallback query
                diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                    "patient": self.patient_id,  # Try without Patient/ prefix
                    "_sort": "-date"
                })

            # Format the results
            formatted_results = ["Here are your lab results:"]

            if diagnostic_reports and 'entry' in diagnostic_reports:
                for entry in diagnostic_reports['entry']:
                    report = entry['resource']
                    if report['resourceType'] != 'DiagnosticReport':
                        continue

                    # Get basic report info
                    date = report.get('effectiveDateTime', report.get('issued', '')).split('T')[0]

                    # Try different ways to get the category
                    category = None
                    if 'category' in report:
                        for cat in report['category']:
                            if 'text' in cat:
                                category = cat['text']
                                break
                            elif 'coding' in cat:
                                for coding in cat['coding']:
                                    if coding.get('display'):
                                        category = coding['display']
                                        break

                    category = category or 'Laboratory'

                    formatted_results.append(f"\n {category} Report ({date})")

                    # Add the conclusion if available
                    if report.get('conclusion'):
                        formatted_results.append(f"Conclusion: {report['conclusion']}")

                    # Get the actual results
                    if 'result' in report:
                        try:
                            for result_ref in report['result']:
                                # Try to get the referenced observation
                                obs_id = result_ref['reference'].split('/')[-1]
                                observation = await self.fhir_service.read("Observation", obs_id)

                                if observation:
                                    test_name = observation.get('code', {}).get('text', 'Unknown Test')
                                    value = observation.get('valueQuantity', {})
                                    if value:
                                        value_str = f"{value.get('value', '')} {value.get('unit', '')}"
                                        formatted_results.append(f"- {test_name}: {value_str}")
                                    else:
                                        # Handle non-numeric results
                                        value_str = observation.get('valueString',
                                                  observation.get('valueCodeableConcept', {}).get('text',
                                                  'No value recorded'))
                                        formatted_results.append(f"- {test_name}: {value_str}")
                        except Exception as obs_error:
                            logger.error(f"Error fetching observation details: {str(obs_error)}")
                            formatted_results.append("- Unable to fetch detailed results")

            if len(formatted_results) == 1:  # Only has the header
                return JsonResponse({
                    "messages": ["No lab results found in your records."]
                }), self.session

            logger.debug("Successfully formatted lab results")
            return JsonResponse({
                "messages": formatted_results
            }), self.session

        except Exception as e:
            logger.error(f"Error handling lab results: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble retrieving your lab results right now. Please try again later."]
            }), self.session

    async def _analyze_lab_question(self, message, lab_results):
        """Analyze the user's question about lab results with improved context"""
        try:
            # Get the last lab topic from session if it exists
            last_lab_context = self.session.get('last_lab_context', {})

            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                temperature=0.1,
                messages=[
                    {
                        "role": "system",
                        "content": """
                        You are a medical lab result analyzer.
                        If the question appears to be a follow-up, use the previous lab context.
                        Analyze the user's question and return a JSON structure with:
                        - test_name: The specific test being asked about (or use previous context if it's a follow-up)
                        - comparison_type: "value", "trend", or "reference_range"
                        - temporal_context: "most_recent", "specific_date", or "trend"
                        - question_type: "interpretation", "comparison", or "general"
                        - is_followup: true if this appears to be a follow-up question
                        """
                    },
                    {
                        "role": "user",
                        "content": f"""
                        Previous lab context: {json.dumps(last_lab_context)}
                        Current question: {message}
                        Available results: {lab_results}
                        """
                    }
                ]
            )

            analysis = json.loads(response.choices[0].message.content)

            # Update session with current lab context
            self.session['last_lab_context'] = {
                'test_name': analysis.get('test_name'),
                'last_query': message,
                'timestamp': datetime.now().isoformat()
            }

            return analysis

        except Exception as e:
            logger.error(f"Error analyzing lab question: {str(e)}")
            raise

    async def _find_specific_result(self, lab_results_response, test_info):
        """Find specific lab result with improved logging"""
        try:
            test_name = test_info['test_name'].lower()
            target_date = test_info.get('target_date')
            logger.debug(f"Looking for test: {test_name}")

            # Extract messages from JsonResponse
            if hasattr(lab_results_response, 'content'):
                content = json.loads(lab_results_response.content.decode())
                messages = content.get('messages', [])
            else:
                messages = lab_results_response.get('messages', [])

            logger.debug(f"Processing messages: {messages}")

            current_date = None
            for message in messages:
                if 'Date:' in message:
                    current_date = message.replace('Date:', '').strip()
                    logger.debug(f"Found date: {current_date}")
                elif test_name in message.lower():
                    logger.debug(f"Found matching test: {message}")
                    # Extract test details using regex
                    match = re.match(r'-\s*([^:]+):\s*(\d+\.?\d*)\s*([^\s\(]+)(?:\s*\(Reference Range:\s*([^\)]+)\))?', message)
                    if match:
                        return {
                            'test_name': match.group(1).strip(),
                            'value': match.group(2),
                            'unit': match.group(3),
                            'reference_range': match.group(4) if match.group(4) else None,
                            'date': current_date
                        }

            return None

        except Exception as e:
            logger.error(f"Error finding specific result: {str(e)}")
            return None

    async def _format_lab_response(self, result, test_info):
        """Format lab result with educational context only - flexible for any biomarker"""
        try:
            test_name = result.get('test_name', '')
            value = result.get('value', '')
            unit = result.get('unit', '')
            ref_range = result.get('reference_range', '')
            date = result.get('date', '')

            # Basic result and range information
            response = [
                f"For your {test_name} from {date}:",
                f"Value: {value} {unit}",
                f"Reference Range: {ref_range}\n"
            ]

            try:
                current_value = float(value.split()[0])
                range_parts = ref_range.split('-')
                if len(range_parts) == 2:
                    low = float(range_parts[0])
                    high = float(range_parts[1])

                    # Simple position relative to range
                    if current_value < low:
                        response.append("This result is below the reference range.")
                    elif current_value > high:
                        response.append("This result is above the reference range.")
                    else:
                        response.append("This result is within the reference range.")

            except (ValueError, IndexError) as e:
                logger.error(f"Error analyzing values: {str(e)}")

            # Generic educational disclaimer for any biomarker
            response.extend([
                "\nImportant notes:",
                "- Laboratory results can be affected by many factors including:",
                "   Diet and nutrition",
                "   Physical activity",
                "   Time of day",
                "   Medications",
                "   Sample collection and handling",
                "",
                "- This information is for educational purposes only",
                "- Always consult your healthcare provider for medical advice",
                "- Your healthcare provider will interpret these results in the context of your overall health"
            ])

            return "\n".join(response)

        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}")
            return "Error displaying results. Please consult your healthcare provider."
    async def _handle_medical_query(self, message=None, intent_data=None):
        """
        Centralized handler for all medical-related queries.
        Routes all medical questions through the PersonalizedMedicalAdviceService.
        """
        try:
            if message is None:
                message = self.user_message
                
            logger.debug(f"Processing medical query: {message} with intent: {intent_data.get('intent')}")
            logger.debug(f"Processing query with intent: {intent_data.get('intent')}")
            
            # Get patient data from session if available
            patient_data = self.patient.get('resource') if self.patient else None
            intent = intent_data.get('intent')
            entities = intent_data.get('entities', {})
            
            # inside _handle_medical_query(), right after you read entities:
            generic = {"general", "explanation", "followup", "unknown", ""}
            nlu_topic = entities.get("topic", "").strip().lower()
            
            # if NLU gives only a generic placeholder, reuse the stored one
            if nlu_topic in generic:
                stored = self.session.get("current_topic", {}).get("name", "")
                topic = stored or nlu_topic or message
            else:
                topic = nlu_topic or message
            
            # only write back if it's a real, non-generic topic
            if topic and topic not in generic and hasattr(self, 'context_manager') and self.context_manager:
                await self.context_manager.update_current_topic(topic)
                
            symptom_description = entities.get('symptom_description', message)
            symptom_keyphrase = entities.get('symptom_keyphrase')
            
            # Create context info with intent for the service
            context_info = self.context_info.copy() if self.context_info else {}
            context_info['intent'] = intent
            
            # Debug logs
            logger.debug(f"Using context_info: {context_info}")
            logger.debug(f"Using topic: {topic}")
            if symptom_keyphrase:
                logger.debug(f"Using symptom_keyphrase: {symptom_keyphrase}")
            
            # Handle issue reports (new intent for any health issue)
            if intent == 'issue_report':
                # Get additional FHIR resources that might be relevant
                additional_data = {}
                
                # Get conditions data if available
                if self.patient_id:
                    try:
                        conditions = await self.fhir_service.search("Condition", {
                            "patient": f"Patient/{self.patient_id}",
                            "status": "active", 
                            "_sort": "-recorded-date"
                        })
                        if conditions:
                            additional_data = conditions
                            
                        # Also try to get medications and allergies
                        try:
                            medications = await self.fhir_service.search("MedicationStatement", {
                                "patient": f"Patient/{self.patient_id}", 
                                "status": "active"
                            })
                            # Merge with additional_data if we got medications
                            if medications and 'entry' in medications:
                                if 'entry' not in additional_data:
                                    additional_data['entry'] = []
                                additional_data['entry'].extend(medications['entry'])
                        except Exception as med_error:
                            logger.error(f"Error fetching medications: {str(med_error)}")
                            
                        try:
                            allergies = await self.fhir_service.search("AllergyIntolerance", {
                                "patient": f"Patient/{self.patient_id}"
                            })
                            # Merge with additional_data if we got allergies
                            if allergies and 'entry' in allergies:
                                if 'entry' not in additional_data:
                                    additional_data['entry'] = []
                                additional_data['entry'].extend(allergies['entry'])
                        except Exception as allergy_error:
                            logger.error(f"Error fetching allergies: {str(allergy_error)}")
                            
                    except Exception as e:
                        logger.error(f"Error fetching conditions: {str(e)}")
                
                # Call the medical advice service with the issue report
                response_data = await self.medical_advice_service.handle_symptom_query(
                    symptom_description, 
                    patient_data,
                    topic=symptom_keyphrase,  # Use the extracted keyphrase if available
                    additional_data=additional_data,
                    conversation_context=context_info
                )
                
                # Update the session with the current topic
                if symptom_keyphrase:
                    self.session['current_topic'] = {
                        'name': symptom_keyphrase,
                        'type': 'issue_report',
                        'last_updated': datetime.now().isoformat()
                    }
                elif 'extracted_topic' in response_data:
                    self.session['current_topic'] = {
                        'name': response_data['extracted_topic'],
                        'type': 'issue_report',
                        'last_updated': datetime.now().isoformat()
                    }
                await update_session(self.user_id, self.session)
                logger.debug(f"Updated session with current_topic: {self.session.get('current_topic')}")
                
            # Handle explanation queries (for medical procedures, tests, etc.) with dedicated service
            elif intent == 'explanation_query':
                # By this point, topic has already been resolved to use the most specific available value
                # But let's log it for clarity                
                logger.debug(f"Handling explanation_query with topic: {topic}")
                
                # Update the session with the current topic FIRST to ensure it persists even if service fails
                self.session['current_topic'] = {
                    'name': topic,
                    'type': 'explanation',
                    'last_updated': datetime.now().isoformat()
                }
                await update_session(self.user_id, self.session)
                logger.debug(f"Updated session with explanation topic: {topic}")
                
                # Also update the context manager with this topic to ensure it persists
                if hasattr(self, 'context_manager') and self.context_manager:
                    await self.context_manager.update_current_topic(
                        topic,
                        {"source": "explanation_query"}
                    )
                
                # 1) If it's an explanation follow-up ("should I get one?"),
                # send it to the screening/recommendation logic instead of generic explainer.
                action = entities.get("action", "")
                is_followup = action == "followup" or entities.get("context_type") in ["anaphora_resolution", "short_query", "semantic_analysis"]
                
                is_screening_query = any(term in message.lower() for term in [
                    "should i", "do i need", "is it necessary", "recommended", 
                    "get one", "have one", "undergo", "when should"
                ])
                
                is_screening_topic = any(procedure in topic.lower() for procedure in [
                    "colonoscopy", "mammogram", "pap smear", "psa", "screening"
                ])
                
                # For follow-ups about screenings, route to the personalized screening recommendation
                if (is_followup or is_screening_query) and is_screening_topic:
                    logger.info(f"Detected screening recommendation request for {topic}")
                    
                    # Get user age from patient data if available
                    user_age = None
                    if patient_data and isinstance(patient_data, dict) and 'birthDate' in patient_data:
                        try:
                            # Use the imported datetime module
                            birth_date = datetime.fromisoformat(patient_data['birthDate'].replace('Z', '+00:00'))
                            today = datetime.now()
                            user_age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                            logger.debug(f"Extracted user age: {user_age}")
                        except Exception as e:
                            logger.error(f"Error calculating age: {str(e)}")
                    
                    # Call the medical advice service for screening guidelines
                    # Use patient_data parameter as it's defined in the method signature
                    response_data = await self.medical_advice_service.get_screening_recommendation(
                        patient_data=patient_data,
                        screening_type=topic,
                        user_age=user_age
                    )
                    logger.info(f"Got screening recommendation for {topic}")
                    
                # Otherwise (first question about a procedure), use the explanation service
                else:
                    # Call the explanation service to get an educational explanation
                    # Log which topic we're passing to the explanation service
                    logger.debug(f"Calling explanation_service.get_explanation with topic: {topic}")
                    response_data = await self.explanation_service.get_explanation(
                        topic=topic, 
                        patient_data=patient_data
                    )
                
            # General medical questions
            elif intent == 'medical_info_query':
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic=topic,
                    conversation_context=context_info
                )
                
            # Symptom-related queries
            elif intent in ['symptom_report', 'symptoms']:
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    conversation_context=context_info
                )
                
            # Patient-specific condition queries
            elif intent == 'conditions':
                # Get conditions data if available
                conditions = None
                if self.patient_id:
                    try:
                        conditions = await self.fhir_service.search("Condition", {
                            "patient": f"Patient/{self.patient_id}",
                            "_sort": "-recorded-date"
                        })
                    except Exception as e:
                        logger.error(f"Error fetching conditions: {str(e)}")
                
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="medical conditions",
                    additional_data=conditions,
                    conversation_context=self.context_info
                )
                
            # Patient-specific medication queries
            elif intent == 'medications':
                # Get medications data if available
                medications = None
                if self.patient_id:
                    try:
                        medications = await self.fhir_service.search("MedicationStatement", {
                            "patient": f"Patient/{self.patient_id}", 
                            "status": "active"
                        })
                    except Exception as e:
                        logger.error(f"Error fetching medications: {str(e)}")
                
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="medications",
                    additional_data=medications,
                    conversation_context=self.context_info
                )
                
            # Patient-specific immunization queries
            elif intent in ['immunizations', 'vaccines']:
                # Get immunizations data if available
                immunizations = None
                if self.patient_id:
                    try:
                        immunizations = await self.fhir_service.search("Immunization", {
                            "patient": f"Patient/{self.patient_id}"
                        })
                    except Exception as e:
                        logger.error(f"Error fetching immunizations: {str(e)}")
                
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="immunizations",
                    additional_data=immunizations,
                    conversation_context=self.context_info
                )
                
            # Patient-specific lab result queries
            elif intent in ['lab_results', 'lab_results_query']:
                # Get lab results data if available
                lab_results = None
                if self.patient_id:
                    try:
                        lab_results = await self.fhir_service.search("DiagnosticReport", {
                            "patient": f"Patient/{self.patient_id}",
                            "_sort": "-date"
                        })
                    except Exception as e:
                        logger.error(f"Error fetching lab results: {str(e)}")
                
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="lab results",
                    additional_data=lab_results,
                    conversation_context=self.context_info
                )
                
            # Patient-specific screening queries
            elif intent == 'screening':
                # For screening-related queries
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="health screenings",
                    conversation_context=self.context_info
                )
                
            # Patient-specific height queries
            elif intent == 'height':
                height = None
                if self.patient and self.patient.get('resource'):
                    # Try to extract height from patient extensions
                    patient_resource = self.patient['resource']
                    for ext in patient_resource.get('extension', []):
                        if ext.get('url') == "http://example.org/fhir/StructureDefinition/height":
                            height = ext.get('valueQuantity', {})
                            break
                
                response_data = await self.medical_advice_service.handle_symptom_query(
                    message, 
                    patient_data,
                    topic="height information",
                    additional_data=height,
                    conversation_context=self.context_info
                )
                
            # Fallback for unhandled medical intents
            else:
                response_data = {
                    "messages": ["I'm not sure how to handle that specific medical query. Could you try rephrasing?"]
                }
            
            # Make sure we update the current_topic in the session after processing a medical query
            # This is critical for the symptom analysis context persistence
            if intent in ['symptom_report', 'symptoms'] and topic:
                identified_topic = topic
                logger.debug(f"Setting current_topic to: {identified_topic}")
                
                # Create a properly structured current_topic for the session
                self.session['current_topic'] = {
                    'name': identified_topic,
                    'type': 'symptom_report',
                    'last_updated': datetime.now().isoformat()
                }
                
                # Save session explicitly to ensure persistence
                await update_session(self.user_id, self.session)
                logger.debug(f"Updated session with current_topic: {self.session.get('current_topic')}")
                
            # Check the response data and convert to JSON response
            if isinstance(response_data, dict) and 'messages' in response_data:
                # Ensure all messages are strings
                if not all(isinstance(msg, str) for msg in response_data['messages']):
                    response_data['messages'] = [str(msg) if not isinstance(msg, str) else msg 
                                               for msg in response_data['messages']]
                return JsonResponse(response_data), self.session
            else:
                # Format as a proper response if not already
                return JsonResponse({
                    "messages": [response_data] if isinstance(response_data, str) else ["I couldn't process your medical query. Please try a different question."]
                }), self.session
            
        except Exception as e:
            logger.error(f"Error in medical query handler: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": [
                    "I apologize, but I encountered an error processing your request.",
                    "If you're experiencing a medical emergency, please call emergency services immediately."
                ]
            }), self.session
    
    async def _handle_screening(self, message=None, intent_data=None):
       """Placeholder for screening intent handler - now handled by _handle_medical_query."""
       return await self._handle_medical_query(message, intent_data)

    async def _parse_lab_query(self, query, context=None):
        """Parse lab query with improved date handling and context awareness"""
        try:
            test_info = {
                'test_name': None,
                'temporal_context': 'most_recent',
                'target_date': None
            }

            # Extract test name
            test_names = {
                'potassium': ['potassium', 'k+'],
                'glucose': ['glucose', 'blood sugar', 'sugar'],
                'hemoglobin': ['hemoglobin', 'hgb', 'hb'],
                # Add more test mappings
            }

            # Check for test name in query
            for test, aliases in test_names.items():
                if any(alias in query for alias in aliases):
                    test_info['test_name'] = test
                    break

            # If no test found but we have context, use that
            if not test_info['test_name'] and context and context.get('last_test'):
                test_info['test_name'] = context['last_test']

            # Parse dates using improved regex patterns
            date_patterns = [
                # Natural language dates
                r'(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|'
                r'jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|'
                r'dec(?:ember)?)\s+\d+(?:st|nd|rd|th)?(?:\s*,?\s*\d{4})?',
                # ISO format dates
                r'\d{4}-\d{2}-\d{2}',
                # Other common formats
                r'\d{2}/\d{2}/\d{4}'
            ]

            for pattern in date_patterns:
                match = re.search(pattern, query, re.IGNORECASE)
                if match:
                    test_info['temporal_context'] = 'specific_date'
                    test_info['target_date'] = await self._normalize_date(match.group())
                    break

            return test_info

        except Exception as e:
            logger.error(f"Error parsing lab query: {str(e)}")
            return {'test_name': None, 'temporal_context': 'most_recent', 'target_date': None}

    async def _normalize_date(self, date_str):
        """Convert various date formats to ISO format"""
        try:
            # Try parsing natural language dates
            if any(month in date_str.lower() for month in ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
                                                          'jul', 'aug', 'sep', 'oct', 'nov', 'dec']):
                # Remove ordinal indicators and clean up
                date_str = re.sub(r'(st|nd|rd|th)', '', date_str)
                # Add current year if not specified
                if not re.search(r'\d{4}', date_str):
                    date_str = f"{date_str}, {datetime.now().year}"
                return datetime.strptime(date_str, "%B %d, %Y").strftime("%Y-%m-%d")

            # Handle other common formats
            for fmt in ["%Y-%m-%d", "%m/%d/%Y", "%d/%m/%Y"]:
                try:
                    return datetime.strptime(date_str, fmt).strftime("%Y-%m-%d")
                except ValueError:
                    continue

            raise ValueError(f"Unable to parse date: {date_str}")

        except Exception as e:
            logger.error(f"Error normalizing date {date_str}: {str(e)}")
            return None
    def _get_clinic_timezone(self):
        """Get the clinic timezone from settings or use default"""
        try:
            return ZoneInfo(settings.TIME_ZONE) if hasattr(settings, 'TIME_ZONE') else ZoneInfo("UTC")
        except Exception as e:
            logger.error(f"Error getting clinic timezone: {str(e)}")
            return ZoneInfo("UTC")  # Default to UTC


    async def _update_session(self):
        """Update session state"""
        try:
            self.session['last_interaction'] = datetime.now().isoformat()
            self.session['verified'] = True
            await update_session(self.user_id, self.session)
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            raise

    async def _handle_capabilities_query(self):
        capabilities = [
            "Schedule new medical appointments",
            "View your upcoming appointments",
            "Cancel existing appointments",
            "Access and explain your medical records, including:",
            "    Current conditions",
            "    Active medications",
            "    Recent procedures",
            "View and explain your test results",
            "Receive medication reminders",
            "Get notifications for annual screenings and check-ups",
            "Answer questions about your health information",
            "Provide general medical information and guidance",
            "Send appointment reminders via SMS",
            "Communicate through email notifications"
        ]

        response_text = "I can help you with:\n\n" + "\n".join(capabilities) + \
                   "\n\nPlease note: While I can provide information and explanations based on your medical records, " + \
                   "I am not a substitute for professional medical advice. Always consult your healthcare provider " + \
                   "for medical decisions."

        return JsonResponse({
            "messages": [response_text],
            "type": "capabilities"
        }), self.session

    async def _handle_explanation_query(self, message=None, intent_data=None):
        # Get the original text and check for context reset
        original_text = intent_data.get('entities', {}).get('original_text', '').lower()

        # Clear context if user explicitly states they're not talking about previous topic
        if 'not talking about' in original_text or 'i dont mean' in original_text:
            self.session.pop('last_topic', None)
            self.session.pop('last_context', None)
            await update_session(self.user_id, self.session)  # Ensure session update is persisted
            return JsonResponse({
                "messages": [
                    "I understand you want an explanation about something else. "
                    "Could you please specify what exactly you'd like me to explain? "
                    "I can help explain:"
                    "\n- Medical terms"
                    "\n- Test results"
                    "\n- Procedures"
                    "\n- Medications"
                    "\n- Or other health-related topics"
                ]
            }), self.session

        # Extract key terms from the topic to determine what needs explanation
        key_terms = {
            'check-up': 'regular medical check-ups and preventive care',
            'screening': 'medical screening and preventive tests',
            'vaccination': 'vaccinations and immunizations',
            'blood test': 'blood tests and laboratory work',
            'medication': 'medication adherence and treatment plans',
            'appointment': 'medical appointments and follow-ups',
            'test results': 'medical test results and monitoring',
            'symptoms': 'symptom monitoring and reporting'
        }

        topic = intent_data.get('entities', {}).get('topic', '')

        # Determine the explanation topic
        explanation_topic = None
        for term, description in key_terms.items():
            if term.lower() in topic.lower():
                explanation_topic = description
                break

        # If no specific term found, use a generic medical topic
        if not explanation_topic:
            explanation_topic = "general medical advice and recommendations"

        messages = [
            {
                "role": "system",
                "content": f"""You are a medical assistant providing clear explanations about {explanation_topic}.
                Explain the importance and benefits in simple terms, focusing on preventive care and health maintenance.
                Include:
                1. Why it's important
                2. Key benefits
                3. Potential risks of neglecting it
                4. General recommendations

                Keep the tone informative but reassuring."""
            },
            {
                "role": "user",
                "content": f"Please explain why {explanation_topic} is important for maintaining good health."
            }
        ]

        response = await self.openai_client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=messages,
            temperature=0.7
        )

        explanation = response.choices[0].message.content

        # Update conversation history
        if hasattr(self, 'conversation_history'):
            self.conversation_history.append({
                'text': topic,
                'is_user': True,
                'timestamp': datetime.now().isoformat()
            })
            self.conversation_history.append({
                'text': explanation,
                'is_user': False,
                'timestamp': datetime.now().isoformat()
            })

        return JsonResponse({
            "messages": [explanation]
        }), self.session

    async def _handle_reset_context(self, intent_data):
        # Clear context
        self.session.pop('last_topic', None)
        self.session.pop('last_context', None)
        self.session.pop('current_test', None)
        self.lab_context = {'last_results': None, 'current_topic': None}
        await update_session(self.user_id, self.session)  # Ensure session update is persisted

        excluded_topic = intent_data.get('entities', {}).get('excluded_topic')
        response = f"I understand you don't want to talk about {excluded_topic if excluded_topic else 'the previous topic'}. "
        response += "What would you like to discuss instead? I can help with:\n"
        response += "- Your medical records\n"
        response += "- Scheduling appointments\n"
        response += "- Explaining lab results\n"
        response += "- General health information\n"
        response += "Or you can ask 'what can you do' to see all my capabilities."

        # Return a JsonResponse object instead of a raw list to avoid type mismatch
        return JsonResponse({"messages": [response]}), self.session

================
File: handlers/context_manager.py
================
"""
chatbot/views/handlers/context_manager.py

This module manages conversation context for a HIPAA-compliant medical chatbot.
It supports threaded conversations, adaptive topic switching, incremental summarization,
and semantic retrieval while ensuring robust PHI redaction, local embedding generation,
and enhanced topic & fact extraction.
"""

import logging
logger = logging.getLogger(__name__)

import json
import re
from datetime import datetime
from typing import List, Dict, Any
import hashlib
import os
from dotenv import load_dotenv
import sys
from pathlib import Path

# Add the project root directory to Python path
project_root = str(Path(__file__).resolve().parent.parent.parent)
sys.path.append(project_root)

from dotenv import load_dotenv
load_dotenv()

import django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
django.setup()
import numpy as np
from django.conf import settings
from openai import AsyncOpenAI
load_dotenv()

import django
from asgiref.sync import sync_to_async
# Session update function (ensure this function handles encryption and secure storage)
from chatbot.views.services.session import update_session
logger.debug("Context manager module loaded")
# ---------------------------
# Initialize Global Components
# ---------------------------

# Initialize Microsoft Presidio Analyzer for PHI detection
try:
    from presidio_analyzer import AnalyzerEngine
    presidio_analyzer = AnalyzerEngine()
except ImportError:
    raise ImportError("Please install presidio-analyzer for robust PHI redaction.")

# Initialize spaCy with a medical model if available, otherwise fallback
try:
    import spacy
    nlp = spacy.load("en_core_web_lg")
except Exception as e:
    logging.warning("en_core_web_lg not found. Falling back to en_core_web_sm. Error: %s", e)
    import spacy
    nlp = spacy.load("en_core_web_sm")

# Initialize SentenceTransformer for generating real embeddings locally
try:
    from sentence_transformers import SentenceTransformer
    embedding_model = SentenceTransformer("all-MiniLM-L6-v2")
except ImportError:
    raise ImportError("Please install sentence_transformers to generate embeddings.")

# Initialize a zero-shot classification pipeline from Hugging Face for topic classification
try:
    from transformers import pipeline
    topic_classifier = pipeline("zero-shot-classification", model="facebook/bart-large-mnli")
except ImportError:
    raise ImportError("Please install transformers to enable topic classification.")

logger = logging.getLogger(__name__)

# ---------------------------
# Utility Functions
# ---------------------------

def redact_sensitive_info(text: str) -> str:
    """
    Use Microsoft Presidio to detect and redact PHI in the text.
    Then apply additional PII redaction using our custom security module.
    """
    try:
        # First pass with Presidio for comprehensive PHI detection
        results = presidio_analyzer.analyze(text=text, language="en")
        for result in results:
            # Replace each detected entity with [REDACTED]
            text = text.replace(result.entity_text, "[REDACTED]")
            
        # Second pass with our custom redaction for general PII
        from chatbot.utils.security import redact_pii
        text = redact_pii(text)
    except Exception as e:
        logger.error(f"Error in PHI redaction: {str(e)}", exc_info=True)
        # Fall back to basic redaction if Presidio fails
        from chatbot.utils.security import redact_pii
        text = redact_pii(text)
    return text

def generate_embedding(text: str) -> np.ndarray:
    """
    Generate a real embedding vector for the text using SentenceTransformer.
    """
    # Ensure text is redacted before embedding to avoid storing raw PHI
    redacted_text = redact_sensitive_info(text)
    embedding = embedding_model.encode(redacted_text)
    return embedding

def cosine_similarity(vec1: np.ndarray, vec2: np.ndarray) -> float:
    """
    Compute cosine similarity between two vectors.
    """
    norm1 = np.linalg.norm(vec1)
    norm2 = np.linalg.norm(vec2)
    if norm1 == 0 or norm2 == 0:
        return 0.0
    return float(np.dot(vec1, vec2) / (norm1 * norm2))

def compute_hash(text: str) -> str:
    """
    Compute an MD5 hash of the given text.
    Useful for caching summaries.
    """
    return hashlib.md5(text.encode("utf-8")).hexdigest()

async def summarize_messages(messages: List[str], openai_client: AsyncOpenAI) -> str:
    """
    Use GPT-4-turbo (or similar) to generate a concise bullet-point summary.
    Redacts sensitive data before summarization.
    """
    if not messages:
        return ""

    # Redact PHI in each message and join them
    joined_messages = "\n".join(f"User: {redact_sensitive_info(m)}" for m in messages)
    
    system_prompt = (
        "You are an assistant that summarizes conversation context. "
        "Return a concise bullet list (max ~100 tokens) capturing key user info "
        "(symptoms, conditions, preferences) without including any sensitive data."
    )

    prompt = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Conversation so far:\n{joined_messages}"}
    ]

    try:
        response = await openai_client.chat.completions.create(
            model="gpt-4-turbo",  # Adjust as needed
            messages=prompt,
            temperature=0.7,
            max_tokens=150
        )
        summary_text = response.choices[0].message.content.strip()
        return summary_text
    except Exception as e:
        logger.error(f"Error summarizing messages: {str(e)}", exc_info=True)
        return ""

def classify_topic(message: str) -> str:
    """
    Classify the topic of the message using a zero-shot classification pipeline.
    """
    # Expanded candidate labels to include explanation, screening, and prevention
    candidate_labels = ["scheduling", "medication", "symptoms", "explanation", "screening", "prevention", "general"]
    try:
        result = topic_classifier(message, candidate_labels)
        topic = result["labels"][0]
        return topic
    except Exception as e:
        logger.error(f"Error classifying topic: {str(e)}", exc_info=True)
        # Fallback to keyword matching with expanded options
        message_lower = message.lower()
        if "appointment" in message_lower or "schedule" in message_lower:
            return "scheduling"
        elif "medication" in message_lower or "prescription" in message_lower:
            return "medication"
        elif "symptom" in message_lower or "pain" in message_lower:
            return "symptoms"
        elif any(word in message_lower for word in ["explanation", "explain", "what is", "why do i need", "tell me about"]):
            return "explanation"
        elif any(word in message_lower for word in ["screening", "test", "should i get", "colonoscopy", "mammogram"]):
            return "screening"
        elif any(word in message_lower for word in ["prevent", "avoid", "reduce risk", "how to stop"]):
            return "prevention"
        else:
            return "general"

def extract_medical_facts(text: str) -> Dict[str, str]:
    """
    Use spaCy's NER to extract medical-related entities such as conditions and medications.
    """
    facts = {}
    try:
        doc = nlp(text)
        for ent in doc.ents:
            # You may refine this based on the entity labels your model produces.
            if ent.label_.lower() in ["condition", "disease", "symptom"]:
                facts["condition"] = ent.text
            elif ent.label_.lower() in ["medication", "drug"]:
                facts["medication"] = ent.text
    except Exception as e:
        logger.error(f"Error extracting medical facts: {str(e)}", exc_info=True)
    return facts

# ---------------------------
# ContextManager Class
# ---------------------------

class ContextManager:
    def __init__(self, user_id: str, session: Dict[str, Any], openai_client: AsyncOpenAI):
        self.user_id = user_id
        self.session = session
        self.openai_client = openai_client

        # Retrieve or initialize conversation data from the session.
        self.conversation_history = self.session.get("conversation_history", [])
        self.topic_summaries = self.session.get("topic_summaries", {})  # {topic: summary}
        self.embeddings = self.session.get("embeddings", {})  # {timestamp: embedding vector as list}
        # Cache summary hashes to avoid unnecessary API calls.
        self.summary_cache = self.session.get("summary_cache", {})

    async def add_message(self, user_id: str, message: str):
        """
        Add a new message to the conversation.
        Processes the message with robust PHI redaction, topic classification,
        and embedding generation.
        """
        topic = classify_topic(message)
        redacted_message = redact_sensitive_info(message)
        timestamp = datetime.now().isoformat()

        # Extract additional facts from the raw message using spaCy.
        extracted_facts = extract_medical_facts(message)

        # Encrypt the original message before storing
        from chatbot.utils.security import encrypt_message
        encrypted_message = encrypt_message(message)
        
        message_entry = {
            "message": redacted_message,            # Redacted version for storage
            "encrypted_message": encrypted_message, # Encrypted original message
            "is_user": True,
            "timestamp": timestamp,
            "topic": topic,
            "facts": extracted_facts
        }
        
        # Use redacted message for all logging
        logger.debug(f"Processing message: {redacted_message}")

        self.conversation_history.append(message_entry)
        self.session["conversation_history"] = self.conversation_history

        # Generate and store an embedding for the redacted message.
        embedding = generate_embedding(redacted_message)
        self.embeddings[timestamp] = embedding.tolist()  # Save as list for JSON serialization
        self.session["embeddings"] = self.embeddings

        # Update current_topic in session for proper follow-up question handling
        await self.update_current_topic(topic, {
            "facts": extracted_facts,
            "timestamp": timestamp
        })

        # Update the summary for the specific topic if necessary.
        await self._maybe_summarize_history(topic)

        logger.info(f"Added message for user {user_id} with topic '{topic}' at {timestamp}")
        await self.save_session()

    async def update_current_topic(self, topic_name: str, topic_data: Dict = None):
        """
        Update the current topic in the session to support follow-up question processing.
        This creates a properly structured current_topic that intent_service.py expects.
        
        Args:
            topic_name: String name of the topic (e.g., 'lab_results', 'symptoms')
            topic_data: Optional dictionary of additional metadata for the topic
        """
        if topic_data is None:
            topic_data = {}
        
        # Don't overwrite a specific topic with a generic one
        generic = {"general", "explanation", "followup", "unknown", ""}
        current = self.session.get("current_topic", {}).get("name", "")
        if topic_name in generic and current and current not in generic:
            logger.debug(f"Skipping generic topic '{topic_name}', keeping '{current}'")
            return
            
        # Map topic from classifier to intent service's expected topic types
        topic_type_mapping = {
            "scheduling": "appointment",
            "medication": "medication",
            "symptoms": "symptom_report",
            "general": "general",
            "explanation": "explanation",  # Map explanation topic to explanation type
            "screening": "explanation",    # Map screening topics to explanation type for now
            "prevention": "explanation",   # Prevention is also educational in nature
            # Add explicit mappings for symptom categories
            "back_pain": "symptom_report",
            "headache": "symptom_report", 
            "leg_pain": "symptom_report",
            "chest_pain": "symptom_report",
            "abdominal_pain": "symptom_report",
            "arm_pain": "symptom_report",
            "knee_pain": "symptom_report",
            "foot_pain": "symptom_report", 
            "hand_pain": "symptom_report",
            "ankle_pain": "symptom_report",
        }
        
        # Create a properly structured current_topic that intent_service.py expects
        current_topic = {
            'name': topic_name,
            'type': topic_type_mapping.get(topic_name, topic_name),
            'last_updated': datetime.now().isoformat()
        }
        
        # Add any additional metadata
        for key, value in topic_data.items():
            if key not in current_topic:
                current_topic[key] = value
        
        # Store in session
        self.session['current_topic'] = current_topic
        logger.info(f"Updated current topic to: {topic_name}")
        logger.info(f"Current topic structure: {current_topic}")
        
        # Debug logging
        logger.debug(f"Updated current_topic to {current_topic}")

    async def get_context(self, user_id: str, current_topic: str = "general") -> Dict[str, Any]:
        """
        Retrieve the current context for the conversation.
        Returns:
          - Topic-specific summary
          - Last N (default 10) messages matching the current topic
        """
        recent_messages = [msg for msg in self.conversation_history if msg.get("topic") == current_topic][-10:]
        summary = self.topic_summaries.get(current_topic, self.session.get("conversation_summary", ""))
        return {"summary": summary, "recent_messages": recent_messages}

    async def add_user_fact(self, user_id: str, fact_type: str, fact: str):
        """
        Add or update a user-specific fact (e.g., conditions, medications) in the session.
        """
        user_facts = self.session.get("user_facts", {}).get(fact_type, [])
        if fact not in user_facts:
            user_facts.append(fact)
            self.session.setdefault("user_facts", {})[fact_type] = user_facts
            logger.info(f"Added {fact_type} fact for user {user_id}: {fact}")
            await self.save_session()

    async def _build_gpt_prompt(self, user_input: str, current_topic: str = "general") -> str:
        """
        Build the system prompt for GPT including user facts and conversation context.
        """
        user_facts = self.session.get("user_facts", {})
        facts_str = "\n".join(f"- {k}: {v}" for k, v in user_facts.items())
        conversation_summary = self.topic_summaries.get(current_topic, self.session.get("conversation_summary", ""))

        system_prompt = f"""
You are a helpful, HIPAA-compliant medical assistant.
Known user facts:
{facts_str}

Summarized conversation (topic: '{current_topic}'):
{conversation_summary}

The user says: {user_input}
"""
        return system_prompt

    async def get_user_facts(self, user_id: str) -> Dict[str, List[str]]:
        """
        Retrieve stored user facts.
        """
        return self.session.get("user_facts", {})

    async def save_session(self):
        """
        Save the updated session.
        Ensure that the session backend is secure and encrypted.
        """
        try:
            # Ensure all session data is JSON serializable
            # Convert any numpy arrays or other non-serializable objects
            serializable_session = {}
            
            # Log key parts of the session we care about for debugging
            logger.info(f"Preparing to save session with current_topic: {self.session.get('current_topic')}")
            logger.debug(f"Current_topic before serialization: {self.session.get('current_topic')}")
            
            for key, value in self.session.items():
                if key == 'embeddings':
                    # Make sure embeddings are lists not numpy arrays
                    serializable_embeddings = {}
                    for timestamp, embedding in value.items():
                        if hasattr(embedding, 'tolist'):
                            serializable_embeddings[timestamp] = embedding.tolist()
                        else:
                            serializable_embeddings[timestamp] = embedding
                    serializable_session[key] = serializable_embeddings
                else:
                    serializable_session[key] = value
            
            # Double-check current_topic is properly included before saving
            if 'current_topic' in self.session and 'current_topic' not in serializable_session:
                serializable_session['current_topic'] = self.session['current_topic']
                logger.warning("Had to manually add current_topic to serializable session")
            
            logger.info(f"Session saved for user {self.user_id} at {datetime.now().isoformat()}")
            logger.debug(f"Current_topic in serializable session: {serializable_session.get('current_topic')}")
            
            # Save the session
            await update_session(self.user_id, serializable_session)
            logger.info("Session successfully updated")
            
        except Exception as e:
            logger.error(f"Error saving session: {str(e)}", exc_info=True)
            # Fall back to just saving without embeddings if there's an error
            try:
                session_copy = self.session.copy()
                if 'embeddings' in session_copy:
                    del session_copy['embeddings']
                await update_session(self.user_id, session_copy)
                logger.info("Session saved without embeddings due to serialization error")
            except Exception as e2:
                logger.error(f"Complete failure saving session: {str(e2)}", exc_info=True)

    async def _maybe_summarize_history(self, topic: str):
        """
        If the number of raw messages for a given topic exceeds a threshold,
        generate and cache a summary to reduce API calls and keep context lean.
        """
        MAX_RAW_MESSAGES = 10
        topic_messages = [msg for msg in self.conversation_history if msg.get("topic") == topic]
        if len(topic_messages) > MAX_RAW_MESSAGES:
            # Build a concatenated string of the messages to summarize.
            older_chunk = [msg["message"] for msg in topic_messages[:-MAX_RAW_MESSAGES]]
            combined_text = "\n".join(older_chunk)
            text_hash = compute_hash(combined_text)

            # Check if this summary is already cached.
            if self.summary_cache.get(topic) == text_hash:
                logger.info(f"Summary for topic '{topic}' is already up-to-date; skipping summarization.")
                return

            summary_text = await summarize_messages(older_chunk, self.openai_client)
            old_summary = self.topic_summaries.get(topic, "")
            combined_summary = f"{old_summary}\n{summary_text}".strip() if old_summary else summary_text
            self.topic_summaries[topic] = combined_summary
            self.session["topic_summaries"] = self.topic_summaries

            # Cache the hash for this topic summary.
            self.summary_cache[topic] = text_hash
            self.session["summary_cache"] = self.summary_cache

            # Prune older messages for this topic (retain only the last MAX_RAW_MESSAGES).
            recent_topic_messages = topic_messages[-MAX_RAW_MESSAGES:]
            # Remove all messages of this topic and add back the recent ones.
            self.conversation_history = [msg for msg in self.conversation_history if msg.get("topic") != topic] + recent_topic_messages
            self.session["conversation_history"] = self.conversation_history

            await self.save_session()
            logger.info(f"Summarized and pruned history for topic '{topic}' for user {self.user_id}")

    async def _extract_user_facts(self, message_text: str) -> Dict[str, str]:
        """
        Optionally extract key facts (e.g., conditions or medications) using spaCy.
        This method calls extract_medical_facts, which is a synchronous function.
        """
        try:
            # Use sync_to_async to properly wrap the synchronous function
            # This ensures the method correctly returns an awaitable result
            extract_medical_facts_async = sync_to_async(extract_medical_facts)
            facts = await extract_medical_facts_async(message_text)
            logger.info(f"Extracted facts: {facts}")
            return facts
        except Exception as e:
            logger.error(f"Error extracting user facts: {str(e)}", exc_info=True)
            return {}

    async def retrieve_similar_messages(self, current_input: str, top_n: int = 5) -> List[Dict[str, Any]]:
        """
        Retrieve semantically similar messages using embeddings.
        """
        current_embedding = generate_embedding(redact_sensitive_info(current_input))
        similarities = []
        for msg in self.conversation_history:
            msg_timestamp = msg.get("timestamp")
            msg_embedding_list = self.embeddings.get(msg_timestamp)
            if msg_embedding_list:
                msg_embedding = np.array(msg_embedding_list)
                similarity = cosine_similarity(current_embedding, msg_embedding)
                similarities.append((similarity, msg))
        similarities.sort(key=lambda x: x[0], reverse=True)
        top_messages = [msg for sim, msg in similarities[:top_n]]
        return top_messages

logger.debug("Context manager initialization complete")

================
File: handlers/medical_handler.py
================
from django.conf import settings

from chatbot.views.services.fhir_service import get_patient_allergies, get_patient_conditions, get_patient_immunizations, get_patient_medications, get_practitioner_for_patient
from ..config import config
from ..utils.formatters import get_resource_name
import logging
import openai
from asgiref.sync import sync_to_async
from fhirclient.models.patient import Patient
from fhirclient.models.condition import Condition
from fhirclient.models.immunization import Immunization
from fhirclient.models.medicationrequest import MedicationRequest
from fhirclient.models.procedure import Procedure
from fhirclient.models.bundle import Bundle
openai.api_key = settings.OPENAI_API_KEY

print ("15")
# Configure logging
logger = logging.getLogger('chatbot')

# Initialize FHIR Client
fhir_client = config.fhir_client
# Initialize Redis client for session management




def format_medications_detailed(medication_entries):
    """
    Formats medication information with detailed dosage and timing.
    
    :param medication_entries: List of medication resources from FHIR server
    :return: Formatted string with medication details
    """
    if not medication_entries:
        return "No active medications found."
    
    try:
        formatted = ["Your current medications:"]
        
        for entry in medication_entries:
            med = entry['resource']
            
            # Get medication name
            med_code = med.get('medicationCodeableConcept', {})
            name = med_code.get('text') or \
                   med_code.get('coding', [{}])[0].get('display', 'Unknown Medication')
            
            formatted.append(f"\n- {name}")
            
            # Get status
            status = med.get('status', 'unknown')
            if status != 'active':
                formatted.append(f"  Status: {status}")
            
            # Process dosage instructions
            dosage_list = med.get('dosage', [])
            if dosage_list:
                for dosage in dosage_list:
                    # Get dose
                    dose_and_rate = dosage.get('doseAndRate', [{}])[0]
                    dose = dose_and_rate.get('doseQuantity', {})
                    dose_value = dose.get('value', '')
                    dose_unit = dose.get('unit', '')
                    if dose_value and dose_unit:
                        formatted.append(f"  Dose: {dose_value} {dose_unit}")
                    
                    # Get timing
                    timing = dosage.get('timing', {})
                    repeat = timing.get('repeat', {})
                    
                    # Frequency
                    frequency = repeat.get('frequency')
                    period = repeat.get('period')
                    period_unit = repeat.get('periodUnit', 'day')
                    if frequency and period:
                        formatted.append(f"  Frequency: {frequency} time(s) per {period} {period_unit}")
                    
                    # Specific times
                    times = repeat.get('timeOfDay', [])
                    if times:
                        formatted.append(f"  Times: {', '.join(times)}")
                    
                    # Route
                    route = dosage.get('route', {}).get('text')
                    if route:
                        formatted.append(f"  Route: {route}")
                    
                    # Additional instructions
                    instructions = dosage.get('patientInstruction')
                    if instructions:
                        formatted.append(f"  Instructions: {instructions}")
                    
                    # Method
                    method = dosage.get('method', {}).get('text')
                    if method:
                        formatted.append(f"  Method: {method}")
            
            # Get reason for medication
            reason_reference = med.get('reasonReference', [])
            if reason_reference:
                reasons = []
                for reason in reason_reference:
                    reason_display = reason.get('display')
                    if reason_display:
                        reasons.append(reason_display)
                if reasons:
                    formatted.append(f"  Reason: {', '.join(reasons)}")
            
            # Get additional notes
            note = med.get('note', [])
            if note:
                notes = [n.get('text') for n in note if n.get('text')]
                if notes:
                    formatted.append(f"  Notes: {' '.join(notes)}")
        
        return "\n".join(formatted)
    
    except Exception as e:
        logger.error(f"Error formatting medications: {str(e)}")
        return "Error formatting medication information."

async def get_complete_medical_record(patient_id, fhir_client):
    try:
        logger.debug(f"Fetching complete medical record for patient {patient_id}")
        
        # Use Patient.read to get patient information
        patient = await sync_to_async(Patient.read)(patient_id, fhir_client.server)
        
        # Use Condition.where to search for conditions
        conditions_bundle = await sync_to_async(Condition.where({
            'patient': patient_id,
            'clinical-status': 'active'
        }).perform)(fhir_client.server)
        
        # Use Immunization.where to search for immunizations
        immunizations_bundle = await sync_to_async(Immunization.where({
            'patient': patient_id,
            '_sort': '-date'
        }).perform)(fhir_client.server)
        
        # Use MedicationRequest.where to search for medications
        medications_bundle = await sync_to_async(MedicationRequest.where({
            'patient': patient_id,
            'status': 'active'
        }).perform)(fhir_client.server)
        
        # Use Procedure.where to search for procedures
        procedures_bundle = await sync_to_async(Procedure.where({
            'patient': patient_id,
            '_sort': '-date'
        }).perform)(fhir_client.server)

        # Now extract and format the data from the bundles
        # Patient information
        name = patient.name[0]
        formatted_name = f"{name.given[0]} {name.family}"

        # Conditions
        conditions = []
        if conditions_bundle.entry:
            for entry in conditions_bundle.entry:
                condition = entry.resource
                condition_name = condition.code.text or condition.code.coding[0].display
                conditions.append(condition_name)

        # Immunizations
        immunizations = []
        if immunizations_bundle.entry:
            for entry in immunizations_bundle.entry:
                immunization = entry.resource
                vaccine_name = immunization.vaccineCode.text or immunization.vaccineCode.coding[0].display
                occurrence_date = immunization.occurrenceDateTime.isostring.split('T')[0]
                immunizations.append(f"{vaccine_name} ({occurrence_date})")

        # Medications
        medications = []
        if medications_bundle.entry:
            for entry in medications_bundle.entry:
                medication_request = entry.resource
                med_code = medication_request.medicationCodeableConcept
                med_name = med_code.text or med_code.coding[0].display
                medications.append(med_name)

        # Procedures
        procedures = []
        if procedures_bundle.entry:
            for entry in procedures_bundle.entry:
                procedure = entry.resource
                proc_code = procedure.code
                proc_name = proc_code.text or proc_code.coding[0].display
                performed_date = procedure.performedDateTime.isostring.split('T')[0] if procedure.performedDateTime else ''
                procedures.append(f"{proc_name} ({performed_date})" if performed_date else proc_name)

        return {
            'name': formatted_name,
            'birthDate': patient.birthDate.isostring,
            'gender': patient.gender,
            'conditions': conditions,
            'immunizations': immunizations,
            'medications': medications,
            'procedures': procedures
        }

    except Exception as e:
        logger.error(f"Error in get_complete_medical_record: {str(e)}", exc_info=True)
        return None
def format_procedures(procedures):
    """
    Formats a list of procedures into a readable string with detailed information.
    
    :param procedures: List of procedure resources from FHIR server
    :return: Formatted string with procedure details
    """
    if not procedures:
        return "No past procedures found."
    
    try:
        formatted = ["Your past procedures:"]
        
        for procedure in procedures:
            # Get procedure name
            code = procedure.get('code', {})
            name = code.get('text') or \
                   code.get('coding', [{}])[0].get('display', 'Unknown Procedure')
            
            # Start new procedure entry
            formatted.append(f"\n- {name}")
            
            # Get performed date/period
            if 'performedDateTime' in procedure:
                performed_date = procedure['performedDateTime'].split('T')[0]
                formatted.append(f"  Date: {performed_date}")
            elif 'performedPeriod' in procedure:
                period = procedure['performedPeriod']
                start = period.get('start', '').split('T')[0]
                end = period.get('end', '').split('T')[0]
                if start == end:
                    formatted.append(f"  Date: {start}")
                else:
                    formatted.append(f"  Period: {start} to {end}")
            
            # Get status
            status = procedure.get('status', '')
            if status:
                formatted.append(f"  Status: {status}")
            
            # Get category
            category = procedure.get('category', {}).get('text')
            if category:
                formatted.append(f"  Category: {category}")
            
            # Get location
            location = procedure.get('location', {}).get('display')
            if location:
                formatted.append(f"  Location: {location}")
            
            # Get performer information
            performers = procedure.get('performer', [])
            if performers:
                performer_names = []
                for performer in performers:
                    actor = performer.get('actor', {})
                    display = actor.get('display')
                    if display:
                        performer_names.append(display)
                if performer_names:
                    formatted.append(f"  Performed by: {', '.join(performer_names)}")
            
            # Get outcome
            outcome = procedure.get('outcome', {}).get('text')
            if outcome:
                formatted.append(f"  Outcome: {outcome}")
            
            # Get complications
            complication = procedure.get('complication', [])
            if complication:
                complications = []
                for comp in complication:
                    comp_text = comp.get('text') or comp.get('coding', [{}])[0].get('display')
                    if comp_text:
                        complications.append(comp_text)
                if complications:
                    formatted.append(f"  Complications: {', '.join(complications)}")
            
            # Get follow-up
            follow_up = procedure.get('followUp', [])
            if follow_up:
                followups = []
                for fu in follow_up:
                    fu_text = fu.get('text') or fu.get('coding', [{}])[0].get('display')
                    if fu_text:
                        followups.append(fu_text)
                if followups:
                    formatted.append(f"  Follow-up: {', '.join(followups)}")
            
            # Get notes
            notes = procedure.get('note', [])
            if notes:
                note_texts = [note.get('text') for note in notes if note.get('text')]
                if note_texts:
                    formatted.append(f"  Notes: {' '.join(note_texts)}")
        
        return "\n".join(formatted)
    
    except Exception as e:
        logger.error(f"Error formatting procedures: {str(e)}")
        return "Error formatting procedure information."

def format_conditions(conditions):
    """
    Formats a list of conditions into a readable string.
    """
    if not conditions:
        return "No active conditions found."
    
    formatted = ["Your current conditions:"]
    for condition in conditions:
        try:
            # Get condition details
            name = condition.get('code', {}).get('text') or \
                   condition.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown Condition')
            
            # Get severity if available
            severity = condition.get('severity', {}).get('text', '')
            severity_str = f" ({severity})" if severity else ""
            
            # Get onset date if available
            onset = condition.get('onsetDateTime', '').split('T')[0] if condition.get('onsetDateTime') else ''
            onset_str = f" - diagnosed on {onset}" if onset else ""
            
            # Get clinical status
            clinical_status = condition.get('clinicalStatus', {}).get('coding', [{}])[0].get('code', 'unknown')
            status_str = f" - {clinical_status}" if clinical_status != 'unknown' else ""
            
            formatted.append(f"- {name}{severity_str}{status_str}{onset_str}")
            
            # Add notes if available
            notes = condition.get('note', [])
            for note in notes:
                if note.get('text'):
                    formatted.append(f"  Note: {note['text']}")
                    
        except Exception as e:
            logger.error(f"Error formatting condition: {e}")
            formatted.append(f"- Error formatting condition")
    
    return "\n".join(formatted)
print ("16")

================
File: handlers/medication_reminder_handler.py
================
from ..services.medication_service import MedicationReminderService
from .chat_handler import ChatHandler
import logging

logger = logging.getLogger('chatbot')
logger.debug("Medication reminder handler initialized")
class MedicationReminderHandler(ChatHandler):
    def __init__(self):
        super().__init__()
        self.reminder_service = MedicationReminderService()

    def handle_reminder_response(self, message, session):
        """Handle patient responses to medication reminders."""
        response_text = message.lower().strip()
        patient_id = session.get('patient_id')
        
        if not patient_id:
            return self.create_error_response("Patient not identified")

        success = self.reminder_service.process_reminder_response(
            patient_id, 
            response_text
        )

        if success:
            # Log successful medication adherence confirmation
            from audit.utils import log_event
            log_event(
                actor=patient_id,
                action="medication.adherence_confirmed",
                resource=f"Patient/{patient_id}",
                meta={
                    "response": response_text,
                    "success": True
                }
            )
            
            return self.create_response(
                "Thank you for confirming your medication. Stay healthy!"
            )
        return self.create_response(
            "I'm not sure what you mean. Please reply 'TAKEN' when you've taken your medication."
        )
logger.debug("Medication reminder handler initialization complete")

================
File: handlers/symptom_guidance_handler.py
================
# chatbot/views/handlers/symptom_guidance_handler.py
from datetime import datetime
import json
from django.http import JsonResponse
import logging
from ..services.symptom_guidance_service import SymptomGuidanceService
from asgiref.sync import sync_to_async

logger = logging.getLogger('chatbot')
logger.debug("Symptom guidance handler initialized")

class SymptomGuidanceHandler:
    def __init__(self, session, user_message, user_id):
        self.session = session
        self.user_message = user_message
        self.user_id = user_id
        self.guidance_service = SymptomGuidanceService()
        self.patient = session.get('patient')
        self.patient_id = self.patient.get('id') if self.patient else None
        
    async def handle_symptom_guidance(self):
        """Handle symptom assessment and provide guidance"""
        try:
            logger.info(f"Processing symptom guidance for message: {self.user_message}")
            
            # 1. Check for red flags first - wrap sync method
            has_red_flags, red_flags = await sync_to_async(self.guidance_service.red_flag_checker)(self.user_message)
            
            if has_red_flags:
                logger.warning(f"Red flags detected: {red_flags}")
                emergency_response = await sync_to_async(self.guidance_service.response_formatter)({
                    'level': 'EMERGENCY',
                    'action': 'Seek immediate emergency care',
                    'red_flags': red_flags
                }, self.patient.get('resource') if self.patient else None)
                
                # Additionally provide detailed guidance for red flag cases
                specific_response = await sync_to_async(self.guidance_service.provide_specific_info)(
                    self.user_message,
                    emergency=True
                )
                
                # Combine emergency and specific guidance
                combined_messages = emergency_response['messages'] + specific_response['messages']
                
                return JsonResponse({
                    'messages': combined_messages,
                    'risk_level': 'EMERGENCY'
                })
            
            # 2. Analyze symptoms
            symptom_analysis = await sync_to_async(self.guidance_service.symptom_analyzer)(
                self.user_message,
                self.patient.get('resource') if self.patient else None
            )
            
            # 3. Determine risk level
            risk_assessment = await sync_to_async(self.guidance_service.risk_level_determiner)(
                symptom_analysis,
                red_flags if has_red_flags else None
            )
            
            # 4. Format response
            response = await sync_to_async(self.guidance_service.response_formatter)(
                risk_assessment,
                self.patient.get('resource') if self.patient else None
            )
            
            # 5. Get specific guidance based on symptoms
            specific_info = await sync_to_async(self.guidance_service.provide_specific_info)(
                self.user_message,
                emergency=False
            )
            
            # Combine general guidance with specific information
            response['messages'].extend(specific_info['messages'])
            
            # 6. Log the interaction
            await self._log_guidance_interaction(
                symptom_analysis,
                risk_assessment,
                response
            )
            
            return JsonResponse(response)
            
        except Exception as e:
            logger.error(f"Error in symptom guidance: {str(e)}", exc_info=True)
            return JsonResponse({
                'messages': [
                    "I apologize, but I encountered an error while analyzing your symptoms.",
                    "For your safety, please contact your healthcare provider or emergency services if you're concerned."
                ]
            })
    
    async def _log_guidance_interaction(self, analysis, assessment, response):
        """Log the guidance interaction for audit purposes"""
        try:
            interaction_log = {
                'timestamp': datetime.utcnow().isoformat(),
                'patient_id': self.patient_id,
                'symptom_analysis': analysis,
                'risk_assessment': assessment,
                'response_given': response,
                'session_id': self.session.get('id')
            }
            
            await sync_to_async(logger.info)(f"Symptom guidance interaction logged: {json.dumps(interaction_log)}")
            
            # Add to audit trail using the audit module
            from audit.utils import log_event
            
            # Extract risk level for audit metadata
            risk_level = assessment.get('level', 'UNKNOWN') if assessment else 'UNKNOWN'
            
            await sync_to_async(log_event)(
                actor=self.user_id,
                action="symptom.guidance",
                resource=f"Patient/{self.patient_id}" if self.patient_id else "unknown_patient",
                meta={
                    "risk_level": risk_level,
                    "timestamp": datetime.utcnow().isoformat()
                }
            )
            
        except Exception as e:
            await sync_to_async(logger.error)(f"Error logging guidance interaction: {str(e)}")
logger.debug("Symptom guidance handler initialization complete")

================
File: services/explanation_service.py
================
"""
explanation_service.py

Service for generating explanations about medical topics, procedures, and conditions.
This service is separate from symptom analysis to ensure clear educational responses
for questions that are asking for information rather than reporting health issues.
"""

import logging
import json
import asyncio
import httpx
from typing import Dict, List, Any, Optional

from django.conf import settings
from openai import AsyncOpenAI

from ..utils.medical_info_templates import get_template_for_topic
from ..utils.response_formatter import STANDARD_DISCLAIMER, format_medical_info_response

# Configure logging
logger = logging.getLogger(__name__)

class ExplanationService:
    """
    Service for providing educational explanations about medical topics.
    Focuses on medical procedures, tests, conditions, and general health information.
    """
    
    def __init__(self):
        """Initialize the service with OpenAI client"""
        self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
    
    async def get_explanation(self, topic: str, patient_data: Optional[Dict] = None) -> Dict[str, List[str]]:
        """
        Get an explanation for a medical topic.
        
        Args:
            topic: The medical topic or procedure to explain
            patient_data: Optional patient data for personalization
            
        Returns:
            Dictionary with message list for the response
        """
        try:
            logger.info(f"Generating explanation for topic: {topic}")
            
            # 1. Check for template match first
            template = get_template_for_topic(topic)
            if template:
                logger.info(f"Found template for {topic}")
                return {"messages": format_medical_info_response(
                    topic=topic,
                    summary=template.get("brief_answer", ""),
                    details=template.get("detailed_info", {}),
                    include_disclaimer=True
                )}
            
            # 2. Try MedlinePlus Health Topic lookup
            medline_info = await self._fetch_health_topic(topic)
            if medline_info:
                logger.info(f"Found MedlinePlus info for {topic}")
                return {"messages": medline_info}
            
            # 3. Generate an explanation with AI
            gpt_explanation = await self._generate_ai_explanation(topic, patient_data)
            return {"messages": gpt_explanation}
            
        except Exception as e:
            logger.error(f"Error generating explanation for {topic}: {str(e)}")
            # Fallback response
            return {"messages": [
                f"I apologize, but I don't have specific information about {topic} at the moment.",
                "I recommend discussing this with your healthcare provider for accurate information.",
                STANDARD_DISCLAIMER
            ]}
    
    async def _fetch_health_topic(self, topic: str) -> List[str]:
        """
        Fetch information from MedlinePlus Health Topics API.
        Different from symptom lookup - this targets educational content.
        """
        try:
            # Use MedlinePlus Health Topics API
            base_url = "https://wsearch.nlm.nih.gov/ws/query"
            params = {
                "db": "healthTopics",
                "term": f"{topic} site:medlineplus.gov",
                "retmax": 1,
                "rettype": "json"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(base_url, params=params, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Extract the relevant information
                    if "result" in data and data["result"].get("documentList", {}).get("document"):
                        document = data["result"]["documentList"]["document"][0]
                        title = document.get("title", "")
                        snippet = document.get("snippet", "")
                        url = document.get("accessibleVersion", "")
                        
                        messages = [
                            f"# {title}",
                            "",
                            snippet,
                            "",
                            f"For more information: {url}",
                            "",
                            STANDARD_DISCLAIMER
                        ]
                        return messages
                        
            return []
        except Exception as e:
            logger.error(f"Error fetching health topic information: {str(e)}")
            return []
    
    async def _generate_ai_explanation(self, topic: str, patient_data: Optional[Dict] = None) -> List[str]:
        """
        Generate an explanation using AI when no template or MedlinePlus data is available.
        """
        try:
            # Create a prompt for the topic
            prompt = self._create_explanation_prompt(topic, patient_data)
            
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You are a medical education assistant providing accurate, structured explanations of medical topics."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )
            
            explanation = response.choices[0].message.content.strip()
            
            # Format into paragraphs
            paragraphs = [p.strip() for p in explanation.split('\n') if p.strip()]
            
            # Ensure we have the disclaimer
            if STANDARD_DISCLAIMER not in explanation:
                paragraphs.append(STANDARD_DISCLAIMER)
                
            return paragraphs
            
        except Exception as e:
            logger.error(f"Error generating AI explanation: {str(e)}")
            return [
                f"I'm sorry, I couldn't generate specific information about {topic}.",
                "Please consult with your healthcare provider for accurate information.",
                STANDARD_DISCLAIMER
            ]
    
    def _create_explanation_prompt(self, topic: str, patient_data: Optional[Dict] = None) -> str:
        """Create a prompt for generating an explanation about a medical topic."""
        prompt = f"""Provide a clear, structured explanation about {topic} covering:

1. WHAT IS IT: Brief definition and description
2. PURPOSE: Why it's done or recommended
3. WHAT TO EXPECT: The procedure or experience
4. BENEFITS: Key benefits or reasons for it
5. RISKS/SIDE EFFECTS: Potential risks or side effects 
6. PREPARATION: How patients should prepare (if applicable)
7. ALTERNATIVES: Alternative options (if applicable)

Format your response in clear paragraphs with headings (using Markdown # for headings).
Focus on educational information rather than diagnostic advice.
Keep your explanation accurate, balanced, and easy to understand.
End with a clear reminder that this is educational information, not personalized medical advice.
"""
        
        # Add patient context if available
        if patient_data and isinstance(patient_data, dict):
            # Extract relevant demographic info without revealing PII
            age = None
            gender = None
            
            if "birthDate" in patient_data:
                from datetime import datetime
                try:
                    birth_date = datetime.fromisoformat(patient_data["birthDate"].replace('Z', '+00:00'))
                    today = datetime.now()
                    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                except (ValueError, TypeError):
                    pass
            
            if "gender" in patient_data:
                gender = patient_data["gender"]
            
            if age or gender:
                prompt += f"\n\nConsider demographics: "
                if age:
                    prompt += f"age {age}, "
                if gender:
                    prompt += f"{gender}, "
                prompt = prompt.rstrip(", ")
                prompt += " when providing relevant information."
        
        return prompt

# Singleton instance
explanation_service = ExplanationService()

================
File: services/fhir_service.py
================
# chatbot/views/services/fhir_service.py
# chatbot/views/services/fhir_service.py

from django.conf import settings
from fhirclient import client
from chatbot.views.utils.shared import get_resource_name
from datetime import datetime
from zoneinfo import ZoneInfo
import urllib.parse
import logging
from asgiref.sync import sync_to_async
import requests
import httpx

# Configure logging
logger = logging.getLogger('chatbot')
print ("22")
# Initialize FHIR Client
def get_fhir_client():
    """Get a configured FHIR client instance"""
    settings_dict = {
        'app_id': 'anna_chatbot',  # Replace with your actual app ID
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        fhir_server = client.FHIRClient(settings=settings_dict).server
        logger.info("FHIR server initialized successfully")
        return fhir_server  # Return server instance which has request_json method
    except Exception as e:
        logger.error(f"Failed to initialize FHIR server: {e}")
        raise

# Initialize global FHIR client with the server object
def get_fhir_server():
    """Get FHIR server instance with proper configuration"""
    settings_dict = {
        'app_id': 'anna_chatbot',
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        smart = client.FHIRClient(settings=settings_dict)
        logger.info("FHIR server initialized successfully")
        return smart.server  # Return the server object that has request_json
    except Exception as e:
        logger.error(f"Failed to initialize FHIR server: {e}")
        raise

# Initialize global FHIR server
fhir_server = get_fhir_server()

# Add all these standalone functions
async def get_patient_by_email(email):
    """Get patient by email"""
    fhir_service = FHIRService()
    result = await fhir_service.search('Patient', {'email': email})
    return result

async def get_patient_by_phone(phone_number):
    """Get patient by phone number"""
    fhir_service = FHIRService()
    # Clean the phone number to just digits
    clean_phone = ''.join(c for c in phone_number if c.isdigit())
    
    # Try multiple search patterns
    search_attempts = [
        {'telecom': f"phone|{phone_number}"},
        {'telecom': f"phone|{clean_phone}"},
        {'telecom': phone_number},
        {'telecom': clean_phone}
    ]
    
    # Try each pattern
    for params in search_attempts:
        result = await fhir_service.search('Patient', params)
        if result and 'entry' in result and result['entry']:
            return result
    
    # If no match, get first patient for demo
    return await fhir_service.search('Patient', {'_count': '1'})

async def get_patient_allergies(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_allergies(patient_id)

async def get_patient_conditions(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_conditions(patient_id)

async def get_patient_immunizations(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_immunizations(patient_id)

async def get_patient_medications(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_medications(patient_id)

async def get_practitioner_for_patient(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_practitioner_for_patient(patient_id)

async def get_available_practitioners():
    fhir_service = FHIRService()
    return await fhir_service.get_available_practitioners()

async def get_practitioner(practitioner_id):
    fhir_service = FHIRService()
    return await fhir_service.get_practitioner(practitioner_id)

async def get_patient_procedures(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_procedures(patient_id)

async def get_complete_medical_record(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_complete_medical_record(patient_id)

async def get_user_appointments(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments(patient_id, timezone)

async def get_user_appointments_direct(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments_direct(patient_id, timezone)

async def get_user_appointments_formatted(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments_formatted(patient_id, timezone)

async def search_available_slots(fhir_client):
    fhir_service = FHIRService()
    return await fhir_service.search_available_slots(fhir_client)

async def get_patient_appointments(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_appointments(patient_id)

class FHIRService:
    def __init__(self):
        self.base_url = settings.FHIR_SERVER_URL
        self.fhir_client = fhir_server
        self.logger = logging.getLogger('chatbot')
        self.fhir_client = get_fhir_client()

    async def search(self, resource_type, params=None):
        """Perform asynchronous FHIR search"""
        try:
            search_path = f"{resource_type}"
            if params:
                param_str = "&".join(f"{k}={v}" for k, v in params.items())
                search_path = f"{search_path}?{param_str}"
            
            logger.debug(f"FHIR search path: {search_path}")
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/{search_path}",
                    timeout=30.0
                )
                response.raise_for_status()
                return response.json()
                
        except httpx.TimeoutException:
            logger.error(f"FHIR search timeout for {search_path}")
            return None
        except httpx.HTTPError as e:
            logger.error(f"FHIR search HTTP error: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"FHIR search error: {str(e)}")
            return None
            
    # Removed problematic get_patient_by_phone method - now using search directly

    def get_practitioner_name(self, resource):
        """Extracts practitioner's full name using the get_resource_name utility."""
        try:
            return get_resource_name(resource)
        except Exception as e:
            self.logger.error(f"Error getting practitioner name: {str(e)}")
            return "Unknown"

    def get_practitioner_specialty(self, resource):
        """Extracts practitioner's specialties from the resource."""
        try:
            qualifications = resource.get('qualification', [])
            specialties = []
            for qual in qualifications:
                code = qual.get('code', {})
                display = (code.get('text') or 
                          code.get('coding', [{}])[0].get('display'))
                if display:
                    specialties.append(display)
            return ', '.join(specialties) if specialties else 'General Practice'
        except Exception as e:
            self.logger.error(f"Error extracting practitioner specialty: {str(e)}")
            return 'General Practice'

    def get_patient(self, patient_id):
        """Get patient by ID"""
        try:
            patient = self.fhir_client.read("Patient", patient_id)
            self.logger.debug(f"Retrieved patient: {patient}")
            return patient
        except Exception as e:
            self.logger.error(f"Error retrieving patient {patient_id}: {str(e)}")
            return None

    async def get_patient_by_email(self, email: str):
        """Get patient by email"""
        try:
            search_params = {'telecom:contains': email}
            result = await self.search('Patient', search_params)  # Make sure this is awaited
            
            if result and 'entry' in result:
                return result['entry'][0]['resource']
            return None
            
        except Exception as e:
            logger.error(f"Error getting patient by email: {str(e)}")
            return None

    def get_patient_by_phone(self, phone_number):
        """Retrieves a patient resource from the FHIR server based on phone number."""
        try:
            self.logger.debug(f"Searching for patient with phone number: {phone_number}")
            
            search_params = [
                {"telecom": f"phone|{urllib.parse.quote(phone_number)}"},
                {"telecom": phone_number}
            ]

            for params in search_params:
                try:
                    # Construct search query
                    query_string = '&'.join(f'{k}={v}' for k, v in params.items())
                    path = f"Patient?{query_string}"
                    result = self.fhir_client.request_json(path)
                    
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                        self.logger.debug(f"Found patient: {patient}")
                        return patient
                except Exception as search_error:
                    self.logger.debug(f"Search attempt failed: {str(search_error)}")
                    continue

            self.logger.debug("No patient found with the given phone number.")
            return None

        except Exception as e:
            self.logger.error(f"Error retrieving patient by phone: {e}")
            return None

    def get_practitioner_for_patient(self, patient):
        """Retrieves the practitioner's information linked to the patient."""
        try:
            general_practitioners = patient.get('generalPractitioner', [])
            if general_practitioners:
                practitioner_ref = general_practitioners[0].get('reference')
                if practitioner_ref:
                    practitioner_id = practitioner_ref.split('/')[-1]
                    practitioner = self.fhir_client.read("Practitioner", practitioner_id)
                    if practitioner:
                        self.logger.debug(f"Practitioner found: {practitioner.get('id')}")
                        return practitioner
            self.logger.debug("No practitioner linked to the patient.")
            return None
        except Exception as e:
            self.logger.error(f"Error retrieving practitioner for patient: {str(e)}")
            return None

    async def get_user_appointments(self, patient_id, timezone='America/New_York'):
        """Get user appointments with detailed logging"""
        self.logger.debug(f"Starting get_user_appointments for patient {patient_id}")
        self.logger.debug(f"Using timezone: {timezone}")
        
        try:
            search_params = {
                'patient': f'Patient/{patient_id}',
                'status': 'booked,arrived,fulfilled'
            }
            self.logger.debug(f"Search parameters: {search_params}")
            
            appointments = await self.search('Appointment', search_params)
            self.logger.debug(f"Raw appointments response: {appointments}")
            
            if not appointments:
                self.logger.debug("No appointments found")
                return []

            formatted_appointments = []
            for entry in appointments.get('entry', []):
                appt = entry.get('resource', {})
                
                try:
                    # Get appointment details
                    start_time = datetime.fromisoformat(appt.get('start').replace('Z', '+00:00'))
                    local_time = start_time.astimezone(ZoneInfo(timezone))
                    
                    # Get practitioner details
                    practitioner_ref = None
                    for participant in appt.get('participant', []):
                        actor = participant.get('actor', {})
                        if actor.get('type') == 'Practitioner' or 'Practitioner/' in actor.get('reference', ''):
                            practitioner_ref = actor.get('reference')
                            break
                    
                    practitioner_name = "Unknown Provider"
                    if practitioner_ref:
                        practitioner_id = practitioner_ref.split('/')[-1]
                        practitioner = await self.read("Practitioner", practitioner_id)
                        if practitioner:
                            name = self.get_practitioner_name(practitioner)
                            specialty = self.get_practitioner_specialty(practitioner)
                            practitioner_name = f"{name} ({specialty})" if specialty != 'Unknown specialty' else name
                    
                    formatted_appointments.append({
                        'datetime': local_time.strftime("%A, %B %d%S at %I:%M %p"),
                        'practitioner': practitioner_name,
                        'status': appt.get('status', 'unknown'),
                        'id': appt.get('id'),
                        'description': appt.get('description', 'General appointment')
                    })
                except Exception as e:
                    self.logger.error(f"Error formatting appointment: {e}")
                    continue
                
            return sorted(formatted_appointments, key=lambda x: x['datetime'])
            
        except Exception as e:
            self.logger.error(f"Error getting appointments: {e}")
            return []

    async def get_patient_immunizations(self, patient_id):
        """
        Retrieves immunization history for a patient from the FHIR server.
        
        :param patient_id: The patient's FHIR resource ID
        :return: List of immunization resources or empty list if none found
        """
        try:
            self.logger.debug(f"Retrieving immunizations for patient ID: {patient_id}")
            
            # Search for Immunization resources
            search_params = {
                "patient": f"Patient/{patient_id}",
                "_sort": "-date"  # Sort by date in descending order
            }
            
            immunization_result = await self.search("Immunization", search_params)
            
            if immunization_result and 'entry' in immunization_result:
                immunizations = []
                for entry in immunization_result['entry']:
                    immunization = entry['resource']
                    
                    # Format each immunization with relevant information
                    formatted_immunization = {
                        'vaccineCode': {
                            'text': immunization.get('vaccineCode', {}).get('text') or 
                                   immunization.get('vaccineCode', {}).get('coding', [{}])[0].get('display', 'Unknown vaccine')
                        },
                        'occurrenceDateTime': immunization.get('occurrenceDateTime', ''),
                        'status': immunization.get('status', 'unknown'),
                        'doseNumber': immunization.get('protocolApplied', [{}])[0].get('doseNumber', ''),
                        'seriesDoses': immunization.get('protocolApplied', [{}])[0].get('seriesDoses', ''),
                        'manufacturer': immunization.get('manufacturer', {}).get('display', ''),
                        'lotNumber': immunization.get('lotNumber', ''),
                        'performer': [
                            {
                                'actor': {
                                    'display': perf.get('actor', {}).get('display', 'Unknown provider')
                                }
                            } for perf in immunization.get('performer', [])
                        ],
                        'note': [
                            {'text': note.get('text', '')} 
                            for note in immunization.get('note', [])
                        ]
                    }
                    
                    immunizations.append(formatted_immunization)
                
                self.logger.debug(f"Found {len(immunizations)} immunizations for patient")
                return immunizations
            
            self.logger.debug("No immunizations found for patient")
            return []
            
        except Exception as e:
            self.logger.error(f"Error retrieving patient immunizations: {e}")
            return []

    def get_patient_name(self, patient_resource):
        """Extracts patient's full name"""
        try:
            names = patient_resource.get('name', [])
            if not names:
                return "Patient"
            name = names[0]
            given = ' '.join(name.get('given', []))
            family = name.get('family', '')
            full_name = f"{given} {family}".strip()
            return full_name if full_name else "Patient"
        except Exception as e:
            self.logger.error(f"Error extracting patient name: {e}")
            return "Patient"

    async def get_patient_conditions(self, patient_id):
        """
        Retrieves active conditions for a patient from the FHIR server and formats them.
        
        Args:
            patient_id (str): The patient's FHIR resource ID
            
        Returns:
            list: List of formatted condition strings
        """
        try:
            self.logger.debug(f"Retrieving conditions for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "clinical-status": "active",
                "_sort": "-recorded-date"  # Sort by most recently recorded first
            }
            
            conditions = await self.search("Condition", search_params)
            
            if not conditions or 'entry' not in conditions:
                self.logger.debug(f"No conditions found for patient {patient_id}")
                return ["No current medical conditions found."]
                
            formatted_conditions = ["Current Medical Conditions:"]
            for entry in conditions['entry']:
                condition = entry['resource']
                try:
                    # Extract condition details
                    name = condition.get('code', {}).get('text') or \
                           (condition.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown condition')
                    
                    clinical_status_obj = condition.get('clinicalStatus', {})
                    clinical_status = clinical_status_obj.get('text') or \
                                      (clinical_status_obj.get('coding', [{}])[0].get('display') or 'Unknown status')
                    
                    verification_obj = condition.get('verificationStatus', {})
                    verification_status = verification_obj.get('text') or \
                                          (verification_obj.get('coding', [{}])[0].get('display') or 'Unknown verification')
                    
                    onset_date = condition.get('onsetDateTime') or condition.get('onsetPeriod', {}).get('start') or condition.get('onsetString', 'Unknown onset')
                    onset_date = onset_date.split('T')[0] if isinstance(onset_date, str) else 'Unknown onset'
                    
                    condition_line = f"- {name} (Status: {clinical_status}, Verification: {verification_status}, Onset: {onset_date})"
                    
                    # Add condition notes if available
                    notes = condition.get('note', [])
                    for note in notes:
                        note_text = note.get('text', '')
                        if note_text:
                            condition_line += f"\n  Note: {note_text}"
                    
                    formatted_conditions.append(condition_line)
                except Exception as e:
                    self.logger.error(f"Error formatting condition: {e}")
                    continue
            
            return formatted_conditions
                
        except Exception as e:
            self.logger.error(f"Error fetching conditions: {e}", exc_info=True)
            return ["Error retrieving medical conditions."]

    async def get_patient_medications(self, patient_id):
        """Retrieves active medications for the given patient and formats them."""
        try:
            self.logger.debug(f"Retrieving medications for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "status": "active"
            }
            
            medication_statements = await self.search("MedicationStatement", search_params)
            medication_requests = await self.search("MedicationRequest", search_params)
            
            medications = []
            
            # Process MedicationStatements
            if medication_statements and 'entry' in medication_statements:
                for entry in medication_statements['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text') or \
                           (med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or 'Unknown medication')
                    dosage = med.get('dosage', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")
            
            # Process MedicationRequests
            if medication_requests and 'entry' in medication_requests:
                for entry in medication_requests['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text') or \
                           (med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or 'Unknown medication')
                    dosage = med.get('dosageInstruction', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")
            
            if medications:
                formatted_meds = ["Current Medications:"]
                formatted_meds.extend(medications)
                return formatted_meds
            
            self.logger.debug("No active medications found for patient.")
            return ["No active medications found."]
                
        except Exception as e:
            self.logger.error(f"Error fetching medications: {e}", exc_info=True)
            return ["Error retrieving medications."]

    async def get_patient_allergies(self, patient_id):
        """
        Retrieves allergy information for a patient from the FHIR server and formats it.
        
        :param patient_id: The patient's FHIR resource ID
        :return: List of formatted allergy strings or a message if none found
        """
        try:
            self.logger.debug(f"Retrieving allergies for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "clinical-status": "active"
            }
            
            allergy_result = await self.search("AllergyIntolerance", search_params)
            
            if allergy_result and 'entry' in allergy_result:
                allergies = []
                for entry in allergy_result['entry']:
                    allergy = entry['resource']
                    try:
                        # Extract allergy details
                        code = allergy.get('code', {}).get('text') or \
                               (allergy.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown substance')
                        
                        reactions = allergy.get('reaction', [])
                        reaction_details = []
                        for reaction in reactions:
                            manifestation = reaction.get('manifestation', [{}])[0].get('text') or \
                                            (reaction.get('manifestation', [{}])[0].get('coding', [{}])[0].get('display') or 'Unknown reaction')
                            severity = reaction.get('severity', 'unknown')
                            reaction_details.append(f"{manifestation} (Severity: {severity})")
                        
                        reaction_str = '; '.join(reaction_details) if reaction_details else 'No reaction details'
                        
                        allergy_line = f"- {code}: {reaction_str}"
                        
                        # Add allergy notes if available
                        notes = allergy.get('note', [])
                        for note in notes:
                            note_text = note.get('text', '')
                            if note_text:
                                allergy_line += f"\n  Note: {note_text}"
                        
                        allergies.append(allergy_line)
                    except Exception as e:
                        self.logger.error(f"Error formatting allergy: {e}")
                        continue
                
                formatted_allergies = ["Active Allergies:"]
                formatted_allergies.extend(allergies)
                return formatted_allergies
            
            self.logger.debug("No active allergies found for patient.")
            return ["No active allergies found."]
                
        except Exception as e:
            self.logger.error(f"Error retrieving patient allergies: {e}", exc_info=True)
            return ["Error retrieving allergies."]

    async def get_patient_procedures(self, patient_id):
        """Retrieves past procedures for the patient and formats them."""
        try:
            self.logger.debug(f"Retrieving procedures for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "status": "completed",
                "_sort": "-recorded-date"  # Sort by most recently recorded first
            }
            
            procedures = await self.search("Procedure", search_params)
            
            if not procedures or 'entry' not in procedures:
                self.logger.debug("No procedures found for patient.")
                return ["No past procedures found."]
            
            formatted_procedures = ["Past Procedures:"]
            for entry in procedures['entry']:
                procedure = entry['resource']
                try:
                    # Extract procedure details
                    name = procedure.get('code', {}).get('text') or \
                           (procedure.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown procedure')
                    
                    date = procedure.get('performedDateTime') or procedure.get('performedPeriod', {}).get('start') or 'Unknown date'
                    date = date.split('T')[0] if isinstance(date, str) else 'Unknown date'
                    
                    status = procedure.get('status', 'unknown')
                    
                    procedure_line = f"- {name} on {date} (Status: {status})"
                    
                    # Add procedure notes if available
                    notes = procedure.get('note', [])
                    for note in notes:
                        note_text = note.get('text', '')
                        if note_text:
                            procedure_line += f"\n  Note: {note_text}"
                    
                    formatted_procedures.append(procedure_line)
                except Exception as e:
                    self.logger.error(f"Error formatting procedure: {e}")
                    continue
            
            return formatted_procedures
                
        except Exception as e:
            self.logger.error(f"Error fetching procedures: {e}", exc_info=True)
            return ["Error retrieving procedures."]
        
    async def read(self, resource_type, resource_id):
        """Async wrapper for FHIR read"""
        try:
            path = f"{resource_type}/{resource_id}"
            request_json_async = sync_to_async(
                self.fhir_client.request_json,
                thread_sensitive=False
            )
            result = await request_json_async(path)
            return result
        except Exception as e:
            self.logger.error(f"FHIR read error for {resource_type}/{resource_id}: {str(e)}")
            return None

    async def get_available_practitioners(self):
        """Get list of available practitioners"""
        self.logger.debug("Starting get_available_practitioners")
        try:
            self.logger.debug("Attempting to search for practitioners")
            practitioners = await self.search('Practitioner', {})
            self.logger.debug(f"Raw practitioners response: {practitioners}")
            
            if practitioners and 'entry' in practitioners:
                available_practitioners = []
                self.logger.debug(f"Found {len(practitioners['entry'])} practitioners")
                
                for entry in practitioners['entry']:
                    self.logger.debug(f"Processing practitioner entry: {entry}")
                    practitioner = entry['resource']
                    
                    # Log practitioner details
                    self.logger.debug(f"Practitioner ID: {practitioner.get('id')}")
                    self.logger.debug(f"Practitioner resource: {practitioner}")
                    
                    # Get practitioner role and specialty from extensions
                    role = None
                    specialty = None
                    for extension in practitioner.get('extension', []):
                        if extension['url'].endswith('practitioner-role'):
                            role = extension.get('valueString')
                        elif extension['url'].endswith('practitioner-specialty'):
                            specialty = extension.get('valueString')
                    
                    name = self.get_practitioner_name(practitioner)
                    available_practitioners.append({
                        'id': practitioner['id'],
                        'name': name,
                        'role': role or 'General Practitioner',
                        'specialty': specialty or 'General Practice'
                    })
                
                self.logger.debug(f"Final available practitioners: {available_practitioners}")
                return available_practitioners
            
            self.logger.debug("No practitioners found in response")
            return []
            
        except Exception as e:
            self.logger.error(f"Error in get_available_practitioners: {str(e)}")
            self.logger.error("Full error details:", exc_info=True)
            self.logger.error(f"FHIR client state: {self.fhir_client}")
            return []

    async def get_user_appointments_direct(self, patient_id, timezone='America/New_York'):
        """Alternative method to get user appointments directly"""
        return await self.get_user_appointments(patient_id, timezone)

    async def get_complete_medical_record(self, patient_id):
        """Fetches and formats the complete medical record for a patient."""
        try:
            self.logger.debug(f"Fetching complete medical record for patient ID: {patient_id}")
            
            # Personal Information
            patient = await self.read("Patient", patient_id)
            if not patient:
                self.logger.error("Patient record not found.")
                return None
            
            record = []
            record.append("BASIC INFORMATION:")
            name = self.get_patient_name(patient)
            record.append(f"Name: {name}")
            record.append(f"Gender: {patient.get('gender', 'Not specified')}")
            record.append(f"Birth Date: {patient.get('birthDate', 'Not specified')}")
            
            # Contact Information
            record.append("\nCONTACT INFORMATION:")
            for telecom in patient.get('telecom', []):
                system = telecom.get('system', '').title()
                value = telecom.get('value', '')
                record.append(f"{system}: {value}")
            
            # Address
            if patient.get('address'):
                address = patient['address'][0]
                address_str = ', '.join(filter(None, [
                    ', '.join(address.get('line', [])),
                    address.get('city', ''),
                    address.get('state', ''),
                    address.get('postalCode', ''),
                    address.get('country', '')
                ]))
                record.append(f"Address: {address_str}")
            
            # Health Metrics
            record.append("\nHEALTH METRICS:")
            for extension in patient.get('extension', []):
                if extension['url'].endswith('height'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Height: {value.get('value')} {value.get('unit')}")
                elif extension['url'].endswith('weight'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Weight: {value.get('value')} {value.get('unit')}")
            
            # Medical Conditions
            conditions = await self.get_patient_conditions(patient_id)
            record.extend(conditions)
            
            # Medications
            medications = await self.get_patient_medications(patient_id)
            record.extend(medications)
            
            # Past Procedures
            procedures = await self.get_patient_procedures(patient_id)
            record.extend(procedures)
            
            # Immunizations
            immunizations = await self.get_patient_immunizations(patient_id)
            if immunizations:
                record.append("\nIMMUNIZATIONS:")
                for imm in immunizations:
                    imm_line = f"- {imm['vaccineCode']['text']} on {imm['occurrenceDateTime']} (Status: {imm['status']})"
                    if imm.get('note'):
                        for note in imm['note']:
                            if note.get('text'):
                                imm_line += f"\n  Note: {note['text']}"
                    record.append(imm_line)
            else:
                record.append("\nIMMUNIZATIONS:")
                record.append("No immunization records found.")
            
            self.logger.debug("Complete medical record fetched successfully.")
            return "\n".join(record)
                
        except Exception as e:
            self.logger.error(f"Error fetching complete medical record: {e}", exc_info=True)
            return None

    async def get_user_appointments_formatted(self, patient_id, timezone='America/New_York'):
        """Fetches and formats user appointments for display."""
        try:
            appointments = await self.get_user_appointments(patient_id, timezone)
            if not appointments:
                return ["You don't have any upcoming appointments scheduled."]
            
            messages = ["Here are your upcoming appointments:"]
            for appt in appointments:
                messages.append(f"- {appt['datetime']} with {appt['practitioner']} ({appt['description']})")
            
            return messages
        except Exception as e:
            self.logger.error(f"Error formatting user appointments: {e}", exc_info=True)
            return ["Error retrieving appointments."]

    async def get_diagnostic_reports(self, search_params):
        """Get diagnostic reports (lab results) for a patient"""
        try:
            result = await self.search('DiagnosticReport', search_params)
            
            if result and 'entry' in result:
                return result['entry']
            return []
            
        except Exception as e:
            self.logger.error(f"Error getting diagnostic reports: {str(e)}")
            return []

    async def get_lab_results(self, patient_id):
        """Fetch lab results for a patient"""
        try:
            # Try multiple category codes that might represent lab results
            categories = ['laboratory', 'LAB', 'lab']
            results = None
            
            for category in categories:
                # Build the FHIR query for DiagnosticReport
                query = (
                    f"/DiagnosticReport?patient={patient_id}"
                    f"&category={category}"
                    "&_sort=-date"
                    "&_include=DiagnosticReport:result"
                    "&_include=DiagnosticReport:subject"
                )
                
                # Make the request
                response = await self._make_request('GET', query)
                logger.debug(f"FHIR response for category {category}: {response.status_code}")
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('total', 0) > 0:
                        results = data
                        break
            
            # If no results found through categories, try without category filter
            if not results:
                query = (
                    f"/DiagnosticReport?patient={patient_id}"
                    "&_sort=-date"
                    "&_include=DiagnosticReport:result"
                    "&_include=DiagnosticReport:subject"
                )
                response = await self._make_request('GET', query)
                if response.status_code == 200:
                    results = response.json()
            
            return results
                
        except Exception as e:
            logger.error(f"Error in get_lab_results: {str(e)}")
            return None

    async def get_lab_reference_ranges(self, test_code):
        """Get reference ranges for a specific lab test"""
        try:
            params = {
                'code': test_code,
                'category': 'laboratory'
            }
            return await self.search('ObservationDefinition', params)
        except Exception as e:
            self.logger.error(f"Error fetching reference ranges: {str(e)}")
            raise

print ("23")

================
File: services/intent_service.py
================
from collections.abc import Coroutine
import logging
import json
import re
from datetime import datetime
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional

from openai import AsyncOpenAI
from django.conf import settings
from asgiref.sync import sync_to_async

# FHIR and Language Imports
from fhirclient.client import FHIRClient
from chatbot.views.config import config  # Assuming this contains FHIR server settings
from chatbot.views.services.language_service import LanguageService

# Load your OpenAI model name from a constants file or environment
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
logger.debug("Intent service module loaded")
# Global fallback cache for GPT fallback responses (to reduce redundant API calls)
FALLBACK_CACHE = {}

# ============================================
#   FHIR Client Initialization (async)
# ============================================
#figure out if any of this shit is necessary and wht it is exactly
def get_async_fhir_client():
    """
    Asynchronously get a configured FHIR client instance.
    Ensures that FHIR server methods are available as async functions.
    """
    settings_dict = {
        'app_id': 'anna_chatbot',
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        fhir_client = FHIRClient(settings=settings_dict)
        # Convert blocking methods to async versions
        fhir_client.server.request_json = sync_to_async(fhir_client.server.request_json, thread_sensitive=False)
        fhir_client.server.update = sync_to_async(fhir_client.server.update, thread_sensitive=False)
        fhir_client.server.create = sync_to_async(fhir_client.server.create, thread_sensitive=False)
        fhir_client.server.delete = sync_to_async(fhir_client.server.delete, thread_sensitive=False)
        fhir_client.server.perform_request = sync_to_async(fhir_client.server.perform_request, thread_sensitive=False)
        logger.info("Asynchronous FHIR client initialized successfully")
        return fhir_client
    except Exception as e:
        logger.error(f"Failed to initialize asynchronous FHIR client: {e}")
        raise

# ============================================
#   OpenAI Client Initialization
# ============================================

client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
language_service = LanguageService()

# ============================================
#   Intent Enumeration and Data Class
# ============================================

class Intent(Enum):
    SET_APPOINTMENT = 'set_appointment'
    SHOW_APPOINTMENTS = 'show_appointments'
    MEDICAL_RECORD_QUERY = 'medical_record_query'
    MEDICAL_INFO_QUERY = 'medical_info_query'
    SYMPTOM_REPORT = 'symptom_report'
    LAB_RESULTS_QUERY = 'lab_results_query'
    LAB_RESULTS = 'lab_results'
    CAPABILITIES = 'capabilities'
    EXPLANATION_QUERY = 'explanation_query'
    EMAIL_VERIFICATION = 'email_verification'
    RESET_CONTEXT = 'reset_context'
    DELETE_CONTEXT = 'delete_context'
    GREETING = 'greeting'
    CONDITION_QUERY = 'condition_query'
    MENTAL_HEALTH_QUERY = 'mental_health_query'
    SCREENING = 'screening'
    ISSUE_REPORT = 'issue_report'  # New intent for any user-reported health issue
    UNKNOWN = 'unknown'

@dataclass
class IntentData:
    """
    A structured container for intent detection results.
    """
    intent: Intent
    confidence: float
    entities: Dict[str, str]
    original_text: str = None
    context_type: str = None

# ============================================
#   Pre-compiled Regex Patterns
# ============================================

# --- Appointment Patterns ---
APPOINTMENT_KEYWORDS = (
    r"(?:book|schedule|make|arrange|reserve|organize|plan|fix|request|create|initiate|set(?:\s*up)?|secure|hold|slot|enroll|register|put\s+down)"
)
APPOINTMENT_PATTERNS_RAW = [
    fr"{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"(?:i|we|would like to|i'd like to|i need to|i want to)\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"need\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"want\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)"
]
COMPILED_APPOINTMENT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_PATTERNS_RAW]

APPOINTMENT_VIEW_PATTERNS_RAW = [
    r'(?:show|view|see|check|list|get|display|pull\s+up|fetch|retrieve)\s+(?:my|all|any|upcoming)?\s+appointments?',
    r'what\s+(?:appointments?|bookings?)\s+do\s+i\s+have(?:\s+scheduled)?',
    r'(?:my|all|upcoming|scheduled)\s+appointments?'
]
COMPILED_APPOINTMENT_VIEW_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_VIEW_PATTERNS_RAW]

# --- Symptom Patterns ---
SYMPTOM_PATTERNS_RAW = {
    'pain': [r'hurts?', r'aching?', r'pain(?:ful)?', r'sore', r'tender', r'burning',
             r'sharp\s+pain', r'dull\s+pain', r'throbbing', r'joint', r'joints',
             r'ankle', r'elbow', r'knee', r'leg\s+pain', r'foot\s+pain', r'back\s+ache'],
    'respiratory': [r'cough(?:ing)?', r'breathing', r'short\s+of\s+breath', r'wheez(?:e|ing)',
                    r'chest\s+tight(?:ness)?', r"can't\s+breathe", r'difficulty\s+breathing',
                    r'asthma', r'lung\s+pain'],
    'gastrointestinal': [r'stomach', r'nausea(?:ted)?', r'vomiting', r'diarrhea', r'constipation',
                         r'abdominal\s+pain', r'indigestion', r'cramps?', r'gastro'],
    'neurological': [r'headache', r'dizzy', r'migraine', r'faint(?:ing)?', r'numbness',
                     r'tingling', r'balance', r'vision', r'hearing', r'seizure', r'epilepsy'],
    'general': [r'fever(?:ish)?', r'tired(?:ness)?', r'fatigue', r'weak(?:ness)?', r'exhausted',
                r'not\s+feeling\s+well', r'unwell', r'sick', r'ill'],
    'musculoskeletal': [r'joint\s+pain', r'muscle\s+pain', r'stiffness', r'swelling',
                        r'limited\s+movement', r'difficulty\s+moving', r'arthritis',
                        r'sprain', r'strain', r'inflammation']
}
COMPILED_SYMPTOM_PATTERNS = {}
for category, patterns in SYMPTOM_PATTERNS_RAW.items():
    COMPILED_SYMPTOM_PATTERNS[category] = [re.compile(p, flags=re.IGNORECASE) for p in patterns]

# --- Medical Record Patterns ---
MEDICAL_RECORD_PATTERNS_RAW = [
    r'(?:show|view|see|access|get|pull\s+up|retrieve)\s+(?:my|all)?\s+(?:medical|health)?\s+records?',
    r'(?:my|full|complete)\s+(?:medical|health)?\s+records?',
    r'history',
    r'(?:my|the)\s+(?:chart|ehr|patient\s*portal|medical\s*file)'
]
COMPILED_MEDICAL_RECORD_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_RECORD_PATTERNS_RAW]

# --- Medical Info Patterns ---
MEDICAL_INFO_PATTERNS_RAW = [
    r'what\s+is', r'tell\s+me\s+about', r'explain', r'information\s+about',
    r'learn\s+about', r'understand', r'how\s+do\s+i\s+know\s+if', r'how\s+can\s+i\s+tell\s+if',
    r'what\s+are\s+the\s+signs\s+of', r'how\s+do\s+you\s+know\s+if', r'how\s+to\s+tell\s+if',
    r'can\s+you\s+provide\s+info', r'give\s+me\s+information', r'differences?\s+between'
]
COMPILED_MEDICAL_INFO_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_INFO_PATTERNS_RAW]

# --- Mental Health Patterns ---
MENTAL_HEALTH_PATTERNS_RAW = [
    r'depression', r'anxiety', r'(?:mental|emotional)\s+health', r'sad(?:ness)?',
    r'unhappy', r'stress(?:ed)?', r'mood', r'therap(?:y|ist)', r'psychological',
    r'crying', r'hopeless(?:ness)?', r'worthless(?:ness)?', r'panic', r'insomnia',
    r'burnout', r'trauma', r'ptsd', r'bipolar', r'schizophrenia', r'suicid(?:e|al)',
    r'self[-\s]*harm', r'counseling'
]
COMPILED_MENTAL_HEALTH_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MENTAL_HEALTH_PATTERNS_RAW]

# --- Condition Patterns ---
CONDITION_PATTERNS_RAW = [
    r'(?:my|current|existing)\s+conditions?', r'medical\s+conditions?',
    r'what\s+(?:conditions?|illnesses?)\s+do\s+i\s+have', r'what\s+am\s+i\s+diagnosed\s+with',
    r'health\s+conditions?', r'ongoing\s+diagnoses?', r'active\s+conditions?'
]
COMPILED_CONDITION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CONDITION_PATTERNS_RAW]

# --- Screening Patterns ---
# Only match screening intent in the context of a response to a screening reminder
# Rather than detecting general questions about screenings/health checks
SCREENING_PATTERNS_RAW = [
    r'screening\s+reminder', r'responding\s+to\s+screening',
    r'about\s+(?:the|my|your)\s+screening\s+(?:reminder|notification|message)',
    r'received\s+(?:a|the)\s+screening'
]
COMPILED_SCREENING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in SCREENING_PATTERNS_RAW]

# --- Lab Result Patterns ---
LAB_RESULT_PATTERNS_RAW = [
    r".*\b(?:cholesterol|glucose|hdl|ldl|triglycerides|potassium|sodium|chloride|bicarbonate|bun|creatinine|calcium|protein|albumin|bilirubin|ast|alt|alkaline\s+phosphatase|ggt|tsh|t4|t3|cortisol|testosterone|estradiol|progesterone|psa|uric\s+acid|crp|esr|inr|pt|aptt|d-dimer|troponin|ck|ldh|amylase|lipase|magnesium|phosphorus|iron|ferritin|transferrin|vitamin\s?b12|folate|vitamin\s?d|platelets|hemoglobin|leukocytes).*(?:high|low|normal|level|range|result|test|value|number).*",
    r".*\bwhat.*\b(?:do|does|about|concerning).*\b(?:my|these|those)?.*\b(?:test|result|level|value|number).*",
    r".*\b(?:my|the|latest|recent|previous|past).*\b(?:test|result|level|value|number).*\b(?:high|low|normal|range).*",
    r".*\b(?:test|result|level|value|number).*(?:okay|ok|good|bad|normal|abnormal|concerning|worrying).*",
    r"(?:what|how|why|when|where|which)\s+(?:is|are|do|does|can|could|should|would)?\s+.*?\s+(?:about|concerning|regarding|related\s+to|pertaining\s+to|mean|levels?|values?|numbers?|results?|tests?|readings?|measurements?)\b",
    r".*\b(?:lab|test|result|level|value|number)\b.*(?:from|on|in|at|for|during)\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|\d{1,2}/\d{1,2}/\d{4}|\d{4}-\d{2}-\d{2})",
    r"(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+\d{1,2}(?:st|nd|rd|th)?(?:,?|\s+in)?\s*(?:\d{4}|\d{2})?",
    r"\d{4}-\d{2}-\d{2}",
    r"\d{1,2}/\d{1,2}/\d{2,4}",
]
COMPILED_LAB_RESULT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in LAB_RESULT_PATTERNS_RAW]

ADDITIONAL_LAB_PATTERNS_RAW = [
    r".*(?:lab|labs?|test|tests?)\s+results?.*",
    r".*(?:blood|urine)\s+test.*",
    r".*my\s+(?:recent|latest|last)\s+results.*",
    r".*results?\s+for.*",
    r".*my\s+levels.*"
]
COMPILED_ADDITIONAL_LAB_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in ADDITIONAL_LAB_PATTERNS_RAW]

# --- Capability Patterns ---
CAPABILITY_PATTERNS_RAW = [
    r"(?:what\s+can\s+you\s+do|what\s+are\s+your\s+capabilities|what\s+do\s+you\s+do|help|how\s+can\s+you\s+help\s+me|what\s+are\s+you\s+able\s+to\s+do|show\s+me\s+what\s+you\s+can\s+do|list\s+capabilities|list\s+functions|what\s+features\s+do\s+you\s+have)"
]
COMPILED_CAPABILITY_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CAPABILITY_PATTERNS_RAW]

# --- Explanation Patterns ---
EXPLANATION_PATTERNS_RAW = [
    r"(?:how\s+do\s+you\s+explain|can\s+you\s+explain|what\s+does\s+.*?\s+mean|explain\s+.*?\s+to\s+me|help\s+me\s+understand|what\s+is\s+the\s+meaning\s+of|could\s+you\s+clarify|what\s+are|how\s+do\s+.*?\s+work|explain\s+the\s+difference)"
]
COMPILED_EXPLANATION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in EXPLANATION_PATTERNS_RAW]

# --- Greeting Patterns ---
GREETING_PATTERNS_RAW = [
    r'\b(?:hi|hello|hey|hii|heyy|yo|hiya|greetings?|wassup|what\'s\s*up|sup|good\s+(?:morning|afternoon|evening|day))\b'
]
COMPILED_GREETING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in GREETING_PATTERNS_RAW]

# ============================================
#   Helper Function to Extract Medical Topic
# ============================================
def extract_medical_topic(message: str) -> str:
    """
    Removes common prompt phrases so that the core topic is isolated.
    """
    patterns_to_remove = [
        'what is', 'tell me about', 'explain', 'information about',
        'learn about', 'understand', 'differences? between'
    ]
    cleaned_message = message
    for pattern in patterns_to_remove:
        cleaned_message = re.sub(pattern, '', cleaned_message, flags=re.IGNORECASE).strip()
    return cleaned_message

# ============================================
#   Main Intent Detection Function (Improved)
# ============================================
async def detect_intent(
    user_input: str,
    conversation_context: Optional[dict] = None,
    last_intent: Optional[str] = None
) -> Dict[str, any]:
    """
    Determines the user's intent using a layered approach:
      1. Special-case handling (digit input, email verification, context deletion/reset)
      2. Regex-based matching using precompiled patterns.
      3. Context-aware handling for short or anaphoric queries.
      4. A GPT fallback with few-shot examples and caching.
    """
    logger.info("=== STARTING INTENT DETECTION ===")
    logger.info(f"Input message: {user_input!r}")

    if not user_input or not isinstance(user_input, str):
        logger.error("Invalid user input: either None or not a string.")
        return {
            "intent": Intent.UNKNOWN.value,
            "confidence": 0.1,
            "entities": {},
            "original_text": str(user_input)
        }

    original_message = user_input.lower().strip()
    logger.debug(f"Processed message: {original_message!r}")

    # --- 1. Special Cases ---
    # 1a. Digit input during booking state
    if conversation_context and original_message.isdigit() and conversation_context.get('booking_state'):
        logger.info("Special case: Digit input during booking state detected.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 1.0,
            "entities": {"selection": original_message, "original_text": user_input, "context": "booking_flow"}
        }

    # 1b. Email Verification
    try:
        email_pattern = re.compile(r'[\w\.-]+@[\w\.-]+\.\w+', flags=re.IGNORECASE)
        if '@' in original_message:
            match_result = email_pattern.match(original_message)
            if match_result:
                matched_email = match_result.group(0)
                logger.info("Special case: Email verification match detected.")
                return {
                    "intent": Intent.EMAIL_VERIFICATION.value,
                    "confidence": 1.0,
                    "entities": {"email": matched_email, "original_text": user_input,
                                 "action": "verify", "context_type": "authentication"}
                }
    except Exception as e:
        logger.error(f"Error in email verification block: {e}")

    # 1c. Delete Context
    delete_commands = ["delete context", "clear context", "reset all", "delete contxt", "remove context", "erase context", "forget everything"]
    if any(cmd in original_message for cmd in delete_commands):
        logger.info("Special case: Delete context command recognized.")
        return {
            "intent": Intent.DELETE_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"action": "delete", "topic": "system", "original_text": user_input}
        }

    # 1d. Reset Context
    reset_patterns = [re.compile(p, flags=re.IGNORECASE) for p in [
        r"(?:i\s+)?(?:am\s+)?not\s+talking\s+about",
        r"(?:i\s+)?don'?t\s+mean",
        r"different\s+(?:topic|subject)",
        r"something\s+else",
        r"forget\s+the\s+previous\s+topic"
    ]]
    if any(pattern.search(original_message) for pattern in reset_patterns):
        excluded_topic_match = re.search(r"(?:about|mean)\s+(\w+)", original_message)
        excluded_topic = excluded_topic_match.group(1) if excluded_topic_match else None
        logger.info("Special case: Reset context command recognized.")
        return {
            "intent": Intent.RESET_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"original_text": user_input, "excluded_topic": excluded_topic}
        }

    # --- 2. Regex-Based Detection ---
    # 2.1 Greeting
    if any(pattern.search(original_message) for pattern in COMPILED_GREETING_PATTERNS):
        logger.info("Regex detection: Greeting pattern matched.")
        return {
            "intent": Intent.GREETING.value,
            "confidence": 1.0,
            "entities": {},
            "original_text": user_input
        }

    # 2.2 Appointment Booking
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_PATTERNS):
        logger.info("Regex detection: Appointment booking pattern matched.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 0.95,
            "entities": {"topic": original_message, "original_text": user_input}
        }

    # 2.3 Appointment Viewing
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_VIEW_PATTERNS):
        logger.info("Regex detection: Appointment viewing pattern matched.")
        return {
            "intent": Intent.SHOW_APPOINTMENTS.value,
            "confidence": 0.95,
            "entities": {"action": "view", "original_text": user_input}
        }

    # 2.4 Health Issue Detection (combines the new issue_report intent with traditional symptom reporting)
    # Check for general health issue indicators first 
    health_terms = [
        r'\b(?:symptom|feeling|suffering|experiencing|having)\b',
        r'\b(?:pain|ache|sore|hurt|discomfort)\b',
        r'\b(?:sick|ill|unwell|not well)\b',
        r'(?:problem with|issue with|trouble with)',
        r'\b(?:diagnosed|condition)\b',
        r'(?:can\'t sleep|insomnia|tired|fatigue)',
        r'\b(?:cough|fever|rash|dizziness|swelling)\b'
    ]
    
    is_general_health_issue = False
    for pattern in health_terms:
        if re.search(pattern, original_message, re.IGNORECASE):
            is_general_health_issue = True
            logger.info(f"Detected general health issue pattern: {pattern}")
            break
    
    # If it's a general health issue but not matching specific symptom categories,
    # use the new issue_report intent
    if is_general_health_issue:
        # Extract a symptom keyphrase if possible (this will be None if no service exists yet)
        symptom_keyphrase = None
        # We can't directly call the medical_advice_service here since it's not available
        # The actual keyphrase extraction will happen in the handler
        
        logger.info(f"Regex detection: General health issue detected, using issue_report intent.")
        return {
            "intent": Intent.ISSUE_REPORT.value,
            "confidence": 0.95,
            "entities": {
                "symptom_description": original_message, 
                "original_text": user_input,
                "symptom_keyphrase": symptom_keyphrase  # Will be None here, extracted later in handler
            }
        }
    
    # Fall back to traditional symptom category detection for specific symptoms
    for category, patterns in COMPILED_SYMPTOM_PATTERNS.items():
        if any(pattern.search(original_message) for pattern in patterns):
            logger.info(f"Regex detection: Symptom report pattern matched for category {category}.")
            return {
                "intent": Intent.SYMPTOM_REPORT.value,
                "confidence": 0.95,
                "entities": {"symptom_category": category, "symptom_description": original_message, "original_text": user_input}
            }

    # 2.5 Anaphora / Short Query Handling
    anaphora_patterns = {
        'it': re.compile(r'\b(it|this|that|these|those)\b', flags=re.IGNORECASE),
        'levels': re.compile(r'\b(levels|values|numbers|results)\b', flags=re.IGNORECASE),
        'change': re.compile(r'\b(increase|decrease|improve|change|modify)\b', flags=re.IGNORECASE)
    }
    
    # Debug logging for follow-up detection
    logger.debug(f"Checking for anaphora in: {original_message}")
    if conversation_context:
        current_topic_info = conversation_context.get('current_topic', {})
        logger.debug(f"With context: {current_topic_info}")
        logger.debug(f"Context type: {type(current_topic_info)}")
        logger.debug(f"Full conversation context: {conversation_context}")
    else:
        logger.debug("No conversation context provided")
        
    # Track which pattern matched for better debugging
    matched_pattern = None
    for pattern_name, pattern in anaphora_patterns.items():
        if pattern.search(original_message):
            matched_pattern = pattern_name
            logger.debug(f"Matched anaphora pattern: {pattern_name}")
            break
    
    if any(pattern.search(original_message) for pattern in anaphora_patterns.values()) and conversation_context and conversation_context.get('current_topic'):
        current_topic = conversation_context['current_topic']
        logger.debug(f"Current topic: {current_topic}")
        logger.debug(f"Current topic type: {type(current_topic)}")
        if isinstance(current_topic, dict):
            logger.debug(f"Topic name: {current_topic.get('name')}")
            logger.debug(f"Topic type: {current_topic.get('type')}")
        
        # Map the current topic type to the appropriate intent
        topic_type = current_topic.get('type', '')
        logger.debug(f"Topic type: {topic_type}")
        
        # Handle different types of follow-up questions based on the current topic
        if topic_type == 'lab_result' or topic_type == 'lab_results' or topic_type == 'lab_results_query':
            logger.info("Anaphora resolution: Lab result context detected in conversation context.")
            logger.debug("Identified as lab result follow-up")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "reference_range": current_topic.get('reference_range'),
                             "last_value": current_topic.get('last_value'), "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'symptom_report' or topic_type == 'symptoms':
            logger.info("Anaphora resolution: Symptom context detected in conversation context.")
            logger.debug("Identified as symptom follow-up")
            return {
                "intent": Intent.SYMPTOM_REPORT.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'medication' or topic_type == 'medications':
            logger.info("Anaphora resolution: Medication context detected in conversation context.")
            print("DEBUG-INTENT-FOLLOWUP-8: Identified as medication follow-up")
            return {
                "intent": Intent.MEDICAL_INFO_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'appointment' or topic_type == 'scheduling':
            logger.info("Anaphora resolution: Appointment context detected in conversation context.")
            print("DEBUG-INTENT-FOLLOWUP-9: Identified as appointment follow-up")
            return {
                "intent": Intent.SHOW_APPOINTMENTS.value, 
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'explanation':
            logger.info(f"Anaphora resolution: Educational explanation context detected for topic: {current_topic.get('name')}")
            logger.debug(f"Identified as explanation follow-up for {current_topic.get('name')}")
            return {
                "intent": Intent.EXPLANATION_QUERY.value,
                "confidence": 0.95,
                "entities": {
                    "action": "followup", 
                    "topic": current_topic.get('name'),
                    "original_text": user_input, 
                    "context_type": "anaphora_resolution"
                }
            }
        else:
            # General follow-up for other topics
            logger.info(f"Anaphora resolution: General follow-up to topic {topic_type}")
            logger.debug(f"General follow-up to topic {topic_type}")
            # Default to medical info query for general follow-ups
            return {
                "intent": Intent.MEDICAL_INFO_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name', 'general'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }

    # 2.6 Additional AI-based short query check for very short messages (<= 5 words)
    if len(original_message.split()) <= 5:
        logger.debug(f"Detected short query: {original_message}")
        # If we have a current topic, this is likely a follow-up
        if conversation_context and conversation_context.get('current_topic'):
            current_topic = conversation_context.get('current_topic', {})
            logger.debug(f"Short query with current topic: {current_topic}")
            
            # If the message is really short (1-2 words) and doesn't contain a question mark,
            # it's very likely a follow-up to the current topic
            if len(original_message.split()) <= 2 and '?' not in original_message:
                topic_type = current_topic.get('type', '')
                topic_name = current_topic.get('name', '')
                print(f"DEBUG-SHORT-QUERY-3: Very short query detected, treating as direct follow-up to {topic_type}")
                
                # Map to appropriate intent based on current topic
                if topic_type in ['lab_result', 'lab_results', 'lab_results_query']:
                    return {
                        "intent": Intent.LAB_RESULTS_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['symptom_report', 'symptoms']:
                    return {
                        "intent": Intent.SYMPTOM_REPORT.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['medication', 'medications']:
                    return {
                        "intent": Intent.MEDICAL_INFO_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['explanation', 'screening', 'prevention']:
                    return {
                        "intent": Intent.EXPLANATION_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
        
        context_prompt = f"\nPrevious topic: {conversation_context['current_topic'].get('name')}" if conversation_context and conversation_context.get('current_topic') else ""
        cache_key = f"short_query::{original_message}{context_prompt}"
        if cache_key in FALLBACK_CACHE:
            logger.info("Using cached GPT fallback for short query.")
            return FALLBACK_CACHE[cache_key]
        try:
            response = await client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": (
                        "You are analyzing if this short user message is a follow-up to a previous topic or "
                        "a standalone query. Return a JSON object:\n"
                        "{\n"
                        '  "is_followup": boolean,\n'
                        '  "confidence": float,\n'
                        '  "related_intent": "lab_results_query" or "show_appointments" or "explanation_query" or ...,\n'
                        '  "reasoning": "string"\n'
                        "}"
                        "\n\nIMPORTANT: If the previous topic is about a medical procedure, screening, or health information, "
                        "use 'explanation_query' as the related_intent. Examples of explanation topics include colonoscopy, "
                        "mammogram, blood pressure, or any medical test or procedure."
                    )},
                    {"role": "user", "content": f"Message: {user_input}{context_prompt}"}
                ],
                temperature=0.1
            )
            if isinstance(response, Coroutine):
                logger.debug("GPT response is a coroutine, forcing await.")
                response = await response
            analysis = json.loads(response.choices[0].message.content)
            if analysis.get('is_followup') is True and analysis.get('confidence', 0) > 0.7:
                related_intent = analysis.get('related_intent')
                if related_intent == 'lab_results_query':
                    result = {
                        "intent": Intent.LAB_RESULTS_QUERY.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "followup", "topic": conversation_context.get('current_topic', {}).get('name', 'unknown'),
                                     "original_text": user_input, "context_type": "semantic_analysis"}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
                elif related_intent == 'show_appointments':
                    result = {
                        "intent": Intent.SHOW_APPOINTMENTS.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "view", "original_text": user_input}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
                elif related_intent == 'explanation_query':
                    # Handle follow-up questions about medical explanation topics
                    topic_name = conversation_context.get('current_topic', {}).get('name', 'unknown')
                    result = {
                        "intent": Intent.EXPLANATION_QUERY.value,
                        "confidence": analysis['confidence'],
                        "entities": {
                            "action": "followup",
                            "topic": topic_name,
                            "original_text": user_input,
                            "context_type": "semantic_analysis"
                        }
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
        except Exception as e:
            logger.error(f"Error in AI-enhanced short query analysis: {e}")

    # 2.7 Lab Result Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_LAB_RESULT_PATTERNS):
        logger.info("Regex detection: Lab result pattern matched.")
        return {
            "intent": Intent.LAB_RESULTS_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": original_message, "original_text": user_input}
        }
    if any(pattern.search(original_message) for pattern in COMPILED_ADDITIONAL_LAB_PATTERNS):
        if re.search(r"(?:show|get|view|see)\s+.*results.*", original_message):
            logger.info("Regex detection: Additional lab pattern matched for viewing results.")
            return {
                "intent": Intent.LAB_RESULTS.value,
                "confidence": 0.9,
                "entities": {"action": "view", "original_text": user_input}
            }
        else:
            logger.info("Regex detection: Additional lab pattern matched for querying results.")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "query", "topic": original_message, "original_text": user_input}
            }

    # 2.8 Screening Patterns - check for sleep questions first and redirect them
    # Check if message is about sleep (redirect to medical_info_query instead)
    sleep_pattern = re.compile(r'sleep|rest|tired|insomnia|how\s+much\s+sleep|hours\s+of\s+sleep', re.IGNORECASE)
    if sleep_pattern.search(original_message):
        logger.info("Sleep question detected, routing to medical_info_query.")
        return {
            "intent": Intent.MEDICAL_INFO_QUERY.value, 
            "confidence": 0.95,
            "entities": {"topic": "sleep health", "original_text": user_input}
        }
        
    # Only match screening patterns if they're truly about screening reminders
    if any(pattern.search(original_message) for pattern in COMPILED_SCREENING_PATTERNS):
        logger.info("Regex detection: Screening pattern matched.")
        return {
            "intent": Intent.SCREENING.value,
            "confidence": 0.9,
            "entities": {"action": "respond", "original_text": user_input}
        }

    # 2.9 Medical Record Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_RECORD_PATTERNS):
        logger.info("Regex detection: Medical record pattern matched.")
        return {
            "intent": Intent.MEDICAL_RECORD_QUERY.value,
            "confidence": 0.9,
            "entities": {"record_type": "full", "original_text": user_input}
        }

    # 2.10 Medical Info Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_INFO_PATTERNS):
        topic_cleaned = extract_medical_topic(original_message)
        logger.info("Regex detection: Medical info pattern matched.")
        return {
            "intent": Intent.MEDICAL_INFO_QUERY.value,
            "confidence": 0.85,
            "entities": {"topic": topic_cleaned, "original_text": user_input}
        }

    # 2.11 Mental Health Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MENTAL_HEALTH_PATTERNS):
        logger.info("Regex detection: Mental health pattern matched.")
        return {
            "intent": Intent.MENTAL_HEALTH_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "mental_health", "original_text": user_input}
        }

    # 2.12 Condition Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CONDITION_PATTERNS):
        logger.info("Regex detection: Condition pattern matched.")
        return {
            "intent": Intent.CONDITION_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "conditions", "original_text": user_input}
        }

    # 2.13 Capability Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CAPABILITY_PATTERNS):
        logger.info("Regex detection: Capability pattern matched.")
        return {
            "intent": Intent.CAPABILITIES.value,
            "confidence": 1.0,
            "entities": {"topic": "capabilities", "original_text": user_input}
        }

    # 2.14 Explanation Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_EXPLANATION_PATTERNS):
        logger.info("Regex detection: Explanation pattern matched.")
        return {
            "intent": Intent.EXPLANATION_QUERY.value,
            "confidence": 1.0,
            "entities": {"topic": user_input, "original_text": user_input}
        }

    # --- 3. GPT Fallback ---
    # Add examples to the system prompt instead of as separate messages
    fallback_prompt = """
You are a powerful medical chatbot assistant. Classify the user's intent from this list:
- set_appointment
- show_appointments
- medical_record_query
- medical_info_query
- symptom_report
- issue_report
- lab_results
- lab_results_query
- capabilities
- explanation_query
- email_verification
- reset_context
- delete_context
- greeting
- condition_query
- mental_health_query
- screening
- unknown

IMPORTANT: Use 'issue_report' for any health issue query that describes a symptom, problem or condition the user is experiencing, especially when they're looking for advice on what to do.

Examples:
- "I've been having trouble sleeping"  issue_report
- "My back has been hurting for days"  issue_report
- "I have a persistent cough that won't go away"  issue_report
- "I'm experiencing ringing in my ears"  issue_report
- "My vision has been blurry"  issue_report

Here are more examples with their expected classifications:

User: "i want to set an appointment"
Expected response: {"intent": "set_appointment", "confidence": 0.95, "entities": {}}

User: "I need to schedule a check-up"
Expected response: {"intent": "set_appointment", "confidence": 0.95, "entities": {}}

User: "What are my upcoming appointments?"
Expected response: {"intent": "show_appointments", "confidence": 0.9, "entities": {}}

User: "What was my potassium level on my last lab test?"
Expected response: {"intent": "lab_results_query", "confidence": 0.85, "entities": {"test_name": "potassium"}}

User: "Can you show me my allergies?"
Expected response: {"intent": "medical_record_query", "confidence": 0.9, "entities": {"record_type": "allergies"}}

User: "hello"
Expected response: {"intent": "greeting", "confidence": 1.0, "entities": {}}

User: "I feel depressed and can't sleep"
Expected response: {"intent": "mental_health_query", "confidence": 0.9, "entities": {"topic": "mental_health"}}

User: "I want to see my lab results from last month"
Expected response: {"intent": "lab_results_query", "confidence": 0.9, "entities": {"action": "query"}}

User: "Let's delete context now"
Expected response: {"intent": "delete_context", "confidence": 1.0, "entities": {"action": "delete"}}

User: "I have a headache and a fever"
Expected response: {"intent": "symptom_report", "confidence": 0.95, "entities": {"symptom_category": "general"}}

User: "What screenings should I get?"
Expected response: {"intent": "screening", "confidence": 0.9, "entities": {"action": "recommend"}}

User: "I've been having trouble sleeping for a few weeks now"
Expected response: {"intent": "issue_report", "confidence": 0.95, "entities": {"symptom_description": "I've been having trouble sleeping for a few weeks now"}}

User: "My back has been hurting for days"
Expected response: {"intent": "issue_report", "confidence": 0.95, "entities": {"symptom_description": "My back has been hurting for days"}}

User: "Why do I need a colonoscopy?"
Expected response: {"intent": "explanation_query", "confidence": 0.95, "entities": {"topic": "colonoscopy"}}

User: "What can you help me with?"
Expected response: {"intent": "capabilities", "confidence": 1.0, "entities": {}}

Return strict JSON:
{
  "intent": "<one of the above>",
  "confidence": 0.95,
  "entities": { ... }
}
"""
    context_info = conversation_context if conversation_context else {}
    gpt_messages = [
        {"role": "system", "content": fallback_prompt},
        {"role": "user", "content": f"Utterance: {user_input}\nContext: {json.dumps(context_info)}\nLast Intent: {last_intent}"}
    ]
    cache_key = f"gpt_fallback::{original_message}::{json.dumps(context_info)}::{last_intent}"
    if cache_key in FALLBACK_CACHE:
        logger.info("Using cached GPT fallback response.")
        return FALLBACK_CACHE[cache_key]

    try:
        response = await client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=gpt_messages,
            temperature=0.2,
            max_tokens=150
        )
        if isinstance(response, Coroutine):
            logger.debug("GPT response is a coroutine, forcing await.")
            response = await response
        if not response or not response.choices:
            logger.error("Empty response from OpenAI fallback.")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        response_content = response.choices[0].message.content
        logger.debug(f"GPT Fallback raw response: {response_content}")
        try:
            intent_data = json.loads(response_content)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse GPT fallback response as JSON: {e}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        if not isinstance(intent_data, dict) or not all(k in intent_data for k in ["intent", "confidence"]):
            logger.error(f"GPT fallback response is invalid: {intent_data}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        try:
            recognized_intent = Intent(intent_data["intent"]).value
        except (ValueError, KeyError):
            logger.warning(f"Invalid intent in GPT fallback response: {intent_data.get('intent')}")
            recognized_intent = Intent.UNKNOWN.value
        result = {
            "intent": recognized_intent,
            "confidence": float(intent_data.get("confidence", 0.1)),
            "entities": intent_data.get("entities", {}),
            "original_text": user_input
        }
        FALLBACK_CACHE[cache_key] = result
        return result
    except Exception as e:
        logger.error(f"Unexpected error in GPT fallback: {e}", exc_info=True)
        return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}

# ============================================
#   Symptom & Condition Analysis (async)
# ============================================
async def analyze_symptom_and_conditions_with_ai(
    patient_id: str,
    user_message: str,
    conversation_history: Optional[list] = None,
    current_topic: Optional[dict] = None
) -> str:
    """
    Analyze symptoms and conditions with advanced AI using FHIR data.
    Detects language, retrieves the patient resource, and returns a triage response.
    """
    try:
        fhir_client =  get_async_fhir_client()
        detected_lang = await language_service.detect_language(user_message)
        emergency_text = language_service.get_localized_message('emergency_text', detected_lang)
        disclaimer = language_service.get_localized_message('disclaimer', detected_lang)
        patient = await fhir_client.server.perform_request('GET', f"Patient/{patient_id}")

        SEVERITY_LEVELS = {
            'EMERGENCY': {
                'prefix': ' EMERGENCY MEDICAL ATTENTION NEEDED',
                'action': 'Please call emergency services (e.g. 112) immediately or go to the nearest ER.',
                'followup': 'Do not delay seeking help.'
            },
            'URGENT': {
                'prefix': ' URGENT MEDICAL ATTENTION ADVISED',
                'action': 'Please seek urgent medical care or contact your healthcare provider right away.',
                'followup': 'If symptoms worsen, call emergency services.'
            },
            'MODERATE': {
                'prefix': ' MEDICAL ATTENTION RECOMMENDED',
                'action': 'Schedule an appointment with your provider soon.',
                'followup': 'Monitor symptoms and seek urgent care if they worsen.'
            },
            'LOW': {
                'prefix': ' GENERAL HEALTH ADVICE',
                'action': 'Monitor your symptoms and practice self-care at home.',
                'followup': 'Schedule a routine appointment if symptoms persist.'
            }
        }

        response = await client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": (
                    "You are a medical triage assistant focusing on patient safety. Always err on the side of caution. "
                    "Return structured JSON with severity and recommended steps."
                )},
                {"role": "user", "content": f"""
Analyze this health concern with severity:

Patient Message: {user_message}

Return JSON with:
{{
    "severity_level": "EMERGENCY|URGENT|MODERATE|LOW",
    "primary_symptoms": [list of main symptoms],
    "related_conditions": [possible related conditions],
    "immediate_actions": [actions to take],
    "reasoning": "brief explanation",
    "requires_emergency": boolean,
    "followup_recommendation": "specific followup advice"
}}
"""}
            ],
            temperature=0.3,
            max_tokens=500
        )
        analysis = json.loads(response.choices[0].message.content)
        severity = analysis.get('severity_level', 'MODERATE')
        severity_info = SEVERITY_LEVELS.get(severity, SEVERITY_LEVELS['MODERATE'])
        primary_symptoms = analysis.get('primary_symptoms', [])
        symptom_list = ", ".join(primary_symptoms) if primary_symptoms else "None"
        response_text = [
            f"{severity_info['prefix']}",
            "",
            f"Symptoms identified: {symptom_list}",
            "",
            f"RECOMMENDATION: {severity_info['action']}",
            "",
            f"Important: {severity_info['followup']}"
        ]
        if analysis.get('requires_emergency', False):
            response_text.append("\n EMERGENCY NUMBERS:")
            response_text.append("General Emergency: 112 (Europe), 911 (US), or local equivalent.")
            response_text.append("If in doubt, call emergency services immediately.")
        if disclaimer:
            response_text.append(f"\n{disclaimer}")
        else:
            response_text.append("\nPlease note this does not replace professional medical advice.")
        return "\n".join(response_text)
    except Exception as e:
        logger.error(f"Error in symptom analysis: {str(e)}", exc_info=True)
        return (
            "For your safety, please seek medical attention or contact emergency services "
            "if you're concerned about any symptoms."
        )
logger.debug("Intent service initialization complete")

================
File: services/language_service.py
================
# chatbot/views/services/language_service.py
import logging
import json
from langdetect import detect, DetectorFactory
from django.conf import settings
from django.core.cache import cache  # Redis cache backend
from openai import AsyncOpenAI  # Changed to AsyncOpenAI
import re
from ..utils.constants import OPENAI_MODEL
import hashlib

logger = logging.getLogger('chatbot')
logger.debug("Language service initialized")

class LanguageService:
    def __init__(self):
        DetectorFactory.seed = 0
        self.supported_languages = {
            'en': {'name': 'English', 'code': 'en'},
            'es': {'name': 'Spanish', 'code': 'es'}
        }
        self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)  # Changed to AsyncOpenAI
    
    async def detect_language(self, text):
        """Detect the language of the input text"""
        try:
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a language detector. Return JSON with language and translation if not English."},
                    {"role": "user", "content": f"Analyze: {text}\nReturn: " + '{"language": "en|es", "translated": "English translation if not English"}'}
                ]
            )
            try:
                result = json.loads(response.choices[0].message.content)
                return result.get('language', 'en').split('|')[0]
            except json.JSONDecodeError:
                logger.error("Failed to parse language detection response")
                return 'en'
        except Exception as e:
            logger.error(f"Error detecting language: {str(e)}")
            return 'en'
    
    def get_localized_message(self, message_key, lang_code='en'):
        """Get localized version of a message"""
        messages = {
            'emergency_text': {
                'en': ' EMERGENCY: Seek immediate medical attention',
                'es': ' EMERGENCIA: Busque atencin mdica inmediata'
            },
            'disclaimer': {
                'en': 'This is an automated assessment. Always consult a healthcare professional.',
                'es': 'Esta es una evaluacin automatizada. Siempre consulte a un profesional de la salud.'
            }
        }
        return messages.get(message_key, {}).get(lang_code, messages[message_key]['en'])
    
    async def translate_text(self, text, target_lang='en'):
        """
        Translate text using OpenAI with Redis caching
        
        Uses a hash of the text and target language as the cache key.
        Caches translations for 90 days to reduce API costs.
        """
        if not text or target_lang == 'en':
            return text
            
        # Generate a cache key based on the text and target language
        text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
        cache_key = f"trans:{target_lang}:{text_hash}"
        
        # Check cache first
        cached_translation = cache.get(cache_key)
        if cached_translation:
            logger.info(f"Using cached translation for {target_lang} (key: {cache_key[:10]}...)")
            return cached_translation

        try:
            # No cache hit, call the OpenAI API
            logger.info(f"Translation cache miss - calling API for {target_lang} text (key: {cache_key[:10]}...)")
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": f"You are a translator. Translate the following text to {self.supported_languages[target_lang]['name']}, maintaining the same tone and meaning:"},
                    {"role": "user", "content": text}
                ],
                temperature=0.3
            )
            translation = response.choices[0].message.content.strip()
            
            # Cache the result for 90 days (60*60*24*90 = 7,776,000 seconds)
            cache.set(cache_key, translation, 60*60*24*90)
            
            # Audit the translation (but not the content for privacy)
            from audit.utils import log_event
            log_event(
                actor="system", 
                action="translation.new",
                resource=f"language.{target_lang}",
                meta={"chars": len(text), "cache_key": cache_key}
            )
            
            return translation
        except Exception as e:
            logger.error(f"Translation error: {str(e)}")
            return text
            
    async def _gpt_translate(self, text, target_lang):
        """
        Internal method to perform the actual OpenAI translation
        Used by the cached translate_text method
        """
        try:
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": f"You are a translator. Translate the following text to {self.supported_languages[target_lang]['name']}, maintaining the same tone and meaning:"},
                    {"role": "user", "content": text}
                ],
                temperature=0.3
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"GPT translation error: {str(e)}")
            return text

class LanguageHandler:
    def __init__(self):
        self.language_service = LanguageService()
    
    async def process_multilingual(self, text):
        try:
            detected_lang = await self.language_service.detect_language(text)
            needs_translation = detected_lang != 'en'
            
            if needs_translation:
                english_text = await self.language_service.translate_text(text, 'en')
            else:
                english_text = text
                
            return english_text, needs_translation
        except Exception as e:
            logger.error(f"Error in process_multilingual: {str(e)}")
            return text, False
            
    async def translate_response(self, response, needs_translation, target_lang):
        """Translate the response if needed"""
        try:
            if not needs_translation or target_lang == 'en':
                return response

            if isinstance(response, str):
                return await self.language_service.translate_text(response, target_lang)
                
            if isinstance(response, dict) and 'messages' in response:
                translated_messages = []
                for message in response['messages']:
                    try:
                        translated_text = await self.language_service.translate_text(
                            message, 
                            target_lang
                        )
                        translated_messages.append(translated_text)
                    except Exception as e:
                        logger.error(f"Error translating message: {str(e)}")
                        translated_messages.append(message)
                    
                response['messages'] = translated_messages
                
            return response
            
        except Exception as e:
            logger.error(f"Error in translate_response: {str(e)}")
            return response
    async def translate_to_english(self, text):
      """Translate text to English"""
      if not text:
          return text

      try:
          _, needs_translation = await self.process_multilingual(text)
          if needs_translation:
              return await self.language_service.translate_text(text, 'en')
          return text
      except Exception as e:
          logger.error(f"Error translating to English: {str(e)}")
          return text
            
logger.debug("Language service initialization complete")

================
File: services/medication_service.py
================
#!/usr/bin/env python
"""
medication_adherence_reminder_service.py

A production-ready implementation for the Medication Adherence and Refill Reminder Service for Anna.
This module:
  - Retrieves active MedicationRequest resources from a FHIR server.
  - Parses complex dosage instructions (ignoring PRN instructions) to calculate the next due dose time.
  - Checks for refill needs by examining the latest MedicationDispense's daysSupply.
  - Sends SMS reminders via an integrated notification service.
  - Checks for patient confirmations via a persistent store (stubbed here).
  - Respects patient opt-out preferences.
  
IMPORTANT:
  - Replace FHIR endpoint settings and codes with your production values.
  - Integrate send_sms() with your actual SMS provider (e.g., Twilio).
  - Implement has_confirmed_intake() with real confirmation tracking.
  - In production, run this service on a scheduled basis (via Celery, cron, etc.) to avoid duplicate reminders.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.medicationrequest as fhir_medreq
import fhirclient.models.medicationdispense as fhir_meddisp
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("MedicationAdherenceReminders")
logger.setLevel(logging.INFO)
print ("27")
# ----------------------------------------------------------------------
# Production FHIR client and SMS integration
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient instance.
    Replace the api_base and add OAuth credentials if needed.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your FHIR endpoint
        # Add additional OAuth settings if required.
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS using your SMS provider.
    Replace this stub with your actual SMS provider integration.
    """
    try:
        # Example using Twilio (replace with real implementation):
        # from twilio.rest import Client as TwilioClient
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(body=message, from_=settings.TWILIO_PHONE_NUMBER, to=to_number)
        logger.info(f"Sending SMS to {to_number}: {message}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS: {e}")
        return False

# Stub for confirmation tracking.
# In production, replace this with a database query or message queue check.
def has_confirmed_intake(patient_id, med_req_id, dose_due_time):
    """
    Check if the patient has confirmed taking their dose.
    This function should query a persistent store keyed by (patient_id, med_req_id, dose_due_time).
    For demonstration, returns False.
    """
    # TODO: Integrate with your confirmation tracking database.
    return False

# ----------------------------------------------------------------------
# Medication Adherence and Refill Reminder Service
# ----------------------------------------------------------------------
class MedicationAdherenceReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        self.refill_threshold_days = 3  # Send refill reminder if <= 3 days remain
    


    def get_due_reminders(self, current_time):
        """
        Returns a list of due medication reminders for the current time.
        Each reminder is a dictionary with patient_id, medication_name, phone_number.
        """
        due_reminders = []
        med_requests = self._get_all_active_medication_requests()

        for med_req in med_requests:
            patient_id = self._extract_patient_id(med_req)
            if not patient_id:
                continue

            phone_number = self._get_patient_phone_number(patient_id)
            if not phone_number:
                logger.warning(f"No phone number for patient {patient_id}; skipping reminder.")
                continue

            medication_name = self._get_medication_name(med_req) or "your medication"

            # Determine next due dose time
            next_due_time = self._get_next_due_dose_time(med_req)

            if next_due_time and current_time >= next_due_time:
                due_reminders.append({
                    "patient_id": patient_id,
                    "medication_name": medication_name,
                    "phone_number": phone_number,
                    "due_time": next_due_time.isoformat()
                })

        return due_reminders

    def process_medication_reminders(self):
        """
        Main function: retrieves due reminders and sends SMS messages.
        """
        current_time = datetime.now()
        due_reminders = self.get_due_reminders(current_time)

        for reminder in due_reminders:
            self.send_reminder(reminder)

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for the given medication.
        """
        message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
        success = self.notification_service(reminder["phone_number"], message)

        if success:
            logger.info(f"Reminder sent to patient {reminder['patient_id']} for {reminder['medication_name']}")
        else:
            logger.error(f"Failed to send reminder to patient {reminder['patient_id']}")


    # ------------------------------------------------------------------
    # FHIR Data Retrieval Methods
    # ------------------------------------------------------------------
    def _get_all_active_medication_requests(self):
        med_reqs = []
        try:
            search = fhir_medreq.MedicationRequest.where({'status': 'active'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for req in bundle:
                    if isinstance(req, fhir_medreq.MedicationRequest):
                        med_reqs.append(req)
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving active MedicationRequests: {e}")
        return med_reqs

    def _extract_patient_id(self, med_req):
        if not med_req.subject or not med_req.subject.reference:
            return None
        return med_req.subject.reference.split('/')[-1]

    def _get_patient_phone_number(self, patient_id):
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient and patient.telecom:
                for telecom in patient.telecom:
                    if telecom.system == 'phone' and telecom.value:
                        return telecom.value
        except Exception as e:
            logger.error(f"Error retrieving phone number for patient {patient_id}: {e}")
        return None

    def _get_patient_preferred_language(self, patient_id):
        """
        Retrieves the preferred language from the Patient resource.
        For demonstration, returns 'en'.
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.communication and len(patient.communication) > 0:
                comm = patient.communication[0]
                if hasattr(comm, 'language') and comm.language and comm.language.text:
                    return comm.language.text.lower()
        except Exception as e:
            logger.error(f"Error retrieving preferred language for patient {patient_id}: {e}")
        return 'en'

    def _get_medication_name(self, med_req):
        if med_req.medicationCodeableConcept:
            if med_req.medicationCodeableConcept.text:
                return med_req.medicationCodeableConcept.text
            if med_req.medicationCodeableConcept.coding:
                return med_req.medicationCodeableConcept.coding[0].display
        return None

    def _patient_has_opted_out(self, patient_id):
        """
        Checks the Patient resource for an opt-out flag.
        Assumes an extension at "http://example.org/fhir/StructureDefinition/optOut".
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.extension:
                for ext in patient.extension:
                    if ext.url == "http://example.org/fhir/StructureDefinition/optOut" and getattr(ext, 'valueBoolean', False):
                        return True
        except Exception as e:
            logger.error(f"Error checking opt-out for patient {patient_id}: {e}")
        return False

    # ------------------------------------------------------------------
    # Dosage Instruction Parsing & Dose Reminder Logic
    # ------------------------------------------------------------------
    def _get_next_due_dose_time(self, med_req):
        """
        Iterates over all dosageInstruction entries (ignoring those marked as "as needed")
        and computes the next due dose time based on dosing frequency.
        Returns the earliest next due datetime among the instructions, or None.
        """
        next_due_times = []
        now = datetime.now()

        if not med_req.dosageInstruction:
            return None

        for dose_inst in med_req.dosageInstruction:
            # Skip PRN instructions (if asNeeded is True or specified via asNeededCodeableConcept)
            if hasattr(dose_inst, 'asNeededBoolean') and dose_inst.asNeededBoolean:
                continue
            if hasattr(dose_inst, 'asNeededCodeableConcept') and dose_inst.asNeededCodeableConcept:
                continue

            frequency, period_hours = self._extract_frequency_and_period(dose_inst)
            if frequency is None or period_hours is None:
                continue

            # Compute the dose interval (in hours)
            interval_hours = period_hours / frequency

            # Retrieve the last dose time from MedicationDispense
            last_dispense = self._get_last_dispense_date(med_req)
            if last_dispense:
                next_due = last_dispense + timedelta(hours=interval_hours)
            else:
                # If no dispense record, assume the dose is due immediately
                next_due = now

            next_due_times.append(next_due)

        if next_due_times:
            return min(next_due_times)
        return None

    def _extract_frequency_and_period(self, dose_inst):
        """
        Extracts frequency and period (in hours) from dose_inst.timing.repeat.
        Returns (frequency, period_hours) or (None, None) if extraction fails.
        """
        try:
            repeat = dose_inst.timing.repeat
            frequency = getattr(repeat, 'frequency', None)
            period = getattr(repeat, 'period', None)
            period_unit = getattr(repeat, 'periodUnit', None)
            if not (frequency and period and period_unit):
                return (None, None)
            hours_map = {
                's': 1/3600,
                'min': 1/60,
                'h': 1,
                'd': 24,
                'wk': 24*7,
                'mo': 24*30,
                'a': 24*365,
            }
            if period_unit not in hours_map:
                return (None, None)
            period_hours = period * hours_map[period_unit]
            return (frequency, period_hours)
        except Exception as e:
            logger.error(f"Error extracting frequency/period: {e}")
            return (None, None)

    def _get_last_dispense_date(self, med_req):
        """
        Retrieves the most recent dispense datetime from MedicationDispense resources
        referencing this MedicationRequest.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        last_date = None
        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    if disp_dt and (not last_date or disp_dt > last_date):
                        last_date = disp_dt
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving MedicationDispense for MedicationRequest/{med_req_id}: {e}")
        return last_date

    def _extract_dispense_datetime(self, disp):
        """
        Extracts a datetime from MedicationDispense.whenHandedOver or whenPrepared.
        """
        for attr in ['whenHandedOver', 'whenPrepared']:
            dt_str = getattr(disp, attr, None)
            if dt_str:
                dt = self._parse_date_str(dt_str)
                if dt:
                    return dt
        return None

    def _parse_date_str(self, date_str):
        """
        Parses an ISO8601 date string into a datetime object.
        """
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except Exception as e:
            logger.warning(f"Error parsing date string '{date_str}': {e}")
            return None

    # ------------------------------------------------------------------
    # Refill Reminder Logic
    # ------------------------------------------------------------------
    def _is_refill_due(self, med_req, now):
        """
        Determines if a refill reminder should be sent based on the latest MedicationDispense's
        daysSupply and the elapsed days since that dispense.
        """
        dispense_info = self._get_latest_dispense_info(med_req)
        if not dispense_info:
            return False

        dispense_date = dispense_info.get('dispense_date')
        days_supply = dispense_info.get('days_supply')
        if not dispense_date or days_supply is None:
            return False

        elapsed_days = (now.date() - dispense_date.date()).days
        remaining_days = days_supply - elapsed_days
        return remaining_days <= self.refill_threshold_days

    def _get_latest_dispense_info(self, med_req):
        """
        Retrieves the most recent MedicationDispense info for this MedicationRequest,
        returning a dict with keys 'dispense_date' and 'days_supply'.
        Note: For complex scenarios (partial refills, overlapping prescriptions), you may need to
        sum or aggregate multiple dispenses.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        latest_date = None
        latest_supply = None

        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    supply = self._extract_days_supply(disp)
                    if disp_dt and supply is not None and (not latest_date or disp_dt > latest_date):
                        latest_date = disp_dt
                        latest_supply = supply
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving dispense info for MedicationRequest/{med_req_id}: {e}")
            return None

        if latest_date:
            return {'dispense_date': latest_date, 'days_supply': latest_supply}
        return None

    def _extract_days_supply(self, disp):
        """
        Extracts the daysSupply value from a MedicationDispense.
        """
        if hasattr(disp, 'daysSupply') and disp.daysSupply and disp.daysSupply.value is not None:
            try:
                return float(disp.daysSupply.value)
            except Exception as e:
                logger.error(f"Error extracting daysSupply: {e}")
        return None

    # ------------------------------------------------------------------
    # End of Service Class
    # ------------------------------------------------------------------

# ----------------------------------------------------------------------
# Script Entry Point (for scheduled execution)
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        reminder_service = MedicationAdherenceReminderService(fhir_client, send_sms)
        reminder_service.process_medication_reminders()
    except Exception as e:
        logger.error(f"Critical error processing medication reminders: {e}")
print ("28")

================
File: services/personalized_medical_advice_service.py
================
#!/usr/bin/env python
"""
personalized_medical_advice_service.py

A production-ready, asynchronous module for generating personalized medical advice.
This service combines:
  - Patient-specific data from your FHIR server (via FHIRService from your codebase)
  - Recent conversation context (via your session/conversation manager)
  - Evidence-based guidelines from MedlinePlus Connect (queried via HTTP)
into a comprehensive prompt for GPT-4. The final advice always includes a prominent disclaimer.

Before deploying:
  - Ensure that your FHIR server (settings.FHIR_SERVER_URL) and credentials (from .env) are correct.
  - Verify that the MedlinePlus Connect query parameters match your requirements.
  - Confirm that your conversation manager functions are correctly integrated.
"""

import logging
import asyncio
from datetime import datetime
from typing import List, Dict, Any
import json
import openai

from django.conf import settings
from chatbot.views.services.fhir_service import FHIRService

# Configure logging
logger = logging.getLogger("PersonalizedMedicalAdvice")
logger.setLevel(logging.INFO)

# ------------------------------------------------------------------------------
# Evidence-Based Guidelines via MedlinePlus Connect
# ------------------------------------------------------------------------------
import logging
logger = logging.getLogger(__name__)
logger.debug("Personalized medical advice service module loaded")
# Mapping from condition names to MedlinePlus Connect codes.
CONDITION_CODE_MAPPING = {
    # Standard conditions
    "diabetes": "44054006",      # SNOMED code for Type 2 diabetes
    "hypertension": "38341003",  # SNOMED code for hypertension
    "insomnia": "248288008",     # SNOMED code for insomnia
    
    # Pain conditions with SNOMED codes
    "back_pain": "161891005",    # SNOMED code for back pain
    "headache": "25064002",      # SNOMED code for headache
    "leg_pain": "90834002",      # SNOMED code for leg pain
    "chest_pain": "29857009",    # SNOMED code for chest pain
    "abdominal_pain": "21522001", # SNOMED code for abdominal pain
    "knee_pain": "30989003",     # SNOMED code for knee pain
    "arm_pain": "45326000",      # SNOMED code for arm pain
    "foot_pain": "47933007",     # SNOMED code for foot pain
    "hand_pain": "53057004",     # SNOMED code for hand pain
    "ankle_pain": "16114001"     # SNOMED code for ankle pain
}

async def get_medlineplus_guidelines(condition: str) -> str:
    """
    Query MedlinePlus Connect for guideline text for the given condition.
    Returns guideline text or None.
    """
    # Find the condition in our mapping
    code = CONDITION_CODE_MAPPING.get(condition.lower())
    if not code:
        logger.warning(f"No mapping found for condition: {condition}")
        return None

    # Construct the MedlinePlus Connect API URL and parameters
    base_url = "https://connect.medlineplus.gov/service"
    params = {
        "mainSearchCriteria.v.c": code,
        "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
        "mainSearchCriteria.v.dn": condition.replace('_', ' '),
        "informationRecipient.language": "en",
        "knowledgeResponseType": "application/json"
    }
    
    logger.info(f"Making MedlinePlus API request for condition: {condition} with code: {code}")
    logger.info(f"Request URL: {base_url}")
    logger.info(f"Request parameters: {params}")
    
    try:
        # Use httpx for async HTTP requests
        import httpx
        
        async with httpx.AsyncClient() as client:
            # Make the API request with proper error handling
            response = await client.get(base_url, params=params, timeout=10)
            logger.info(f"MedlinePlus API response status: {response.status_code}")
            
            if response.status_code == 200:
                try:
                    # Parse the JSON response
                    logger.debug(f"MedlinePlus response content: {response.text[:500]}...")
                    
                    import json
                    response_data = json.loads(response.text)
                    guideline_text = None
                    
                    # Extract information from the JSON structure
                    # MedlinePlus Connect uses an Atom feed structure
                    if 'feed' in response_data and 'entry' in response_data['feed']:
                        entries = response_data['feed']['entry']
                        if entries and len(entries) > 0:
                            # Try to get the summary content first
                            if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                guideline_text = entries[0]['summary']['_value'].strip()
                                logger.info(f"Found summary element with text: {guideline_text[:100]}...")
                            
                            # If no summary, look for content or title
                            elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                guideline_text = entries[0]['content']['_value'].strip()
                                logger.info(f"Found content element with text: {guideline_text[:100]}...")
                            
                            # Try title as last resort
                            elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                guideline_text = entries[0]['title']['_value'].strip()
                                logger.info(f"Found title element with text: {guideline_text[:100]}...")
                    
                    if guideline_text:
                        logger.info(f"Successfully retrieved guideline for {condition}")
                        return guideline_text
                    else:
                        logger.warning(f"No useful information found for {condition} in JSON response")
                        return None
                except json.JSONDecodeError as json_error:
                    logger.error(f"JSON parsing error for MedlinePlus response: {json_error}")
                    logger.debug(f"Problematic JSON content: {response.text[:300]}...")
                    return None
            else:
                logger.error(f"MedlinePlus API error {response.status_code} for condition {condition}")
                logger.error(f"Error response: {response.text[:300]}...")
                return None
    except Exception as e:
        logger.error(f"Error querying MedlinePlus for {condition}: {e}")
        return None

def get_evidence_based_guidelines(conditions: List[str]) -> Dict[str, str]:
    """
    For each condition in the list, query MedlinePlus Connect and return a mapping.
    """
    guidelines = {}
    for cond in conditions:
        text = get_medlineplus_guidelines(cond)
        if text:
            guidelines[cond] = text
    return guidelines

# ------------------------------------------------------------------------------
# Asynchronous Summarization of Conversation Context
# ------------------------------------------------------------------------------
def redact_sensitive_info(text: str) -> str:
    """
    Stub for redacting sensitive information. Replace with real redaction as needed.
    """
    return text

async def summarize_messages(messages: List[str], openai_client: "AsyncGPT4Client") -> str:
    """
    Uses GPT-4-turbo to generate a concise bullet-point summary of conversation context.
    Redacts sensitive data before summarization.
    """
    if not messages:
        return ""
    joined_messages = "\n".join(f"User: {redact_sensitive_info(m)}" for m in messages)
    system_prompt = (
        "You are an assistant that summarizes conversation context. "
        "Return a concise bullet list (max ~100 tokens) capturing key user info "
        "(symptoms, conditions, preferences) without including any sensitive data."
    )
    prompt_messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Conversation so far:\n{joined_messages}"}
    ]
    try:
        response = await openai_client.chat_completions_create(
            model="gpt-4-turbo",
            messages=prompt_messages,
            temperature=0.7,
            max_tokens=150
        )
        summary_text = response.choices[0].message.content.strip()
        return summary_text
    except Exception as e:
        logger.error(f"Error summarizing messages: {e}", exc_info=True)
        return ""

# ------------------------------------------------------------------------------
# Asynchronous GPT-4 Client Using OpenAI's Async API
# ------------------------------------------------------------------------------
class AsyncGPT4Client:
    def __init__(self, api_key: str):
        self.api_key = api_key
        from openai import AsyncOpenAI
        self.client = AsyncOpenAI(api_key=api_key)

    async def chat_completions_create(self, model: str, messages: List[dict],
                                     temperature: float = 0.7,
                                     max_tokens: int = 300) -> dict:
        """
        Calls the OpenAI async ChatCompletion API.
        """
        try:
            response = await self.client.chat.completions.create(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            return response
        except Exception as e:
            logger.error(f"Error generating GPT-4 response: {e}")
            raise

    async def generate_advice(self, prompt: str) -> str:
        messages = [{"role": "user", "content": prompt}]
        response = await self.chat_completions_create(
            model="gpt-4o-mini",  # Using the more recent model
            messages=messages,
            temperature=0.7,
            max_tokens=300
        )
        return response.choices[0].message.content.strip()

# ------------------------------------------------------------------------------
# Conversation Context Retrieval (Replace with your real conversation/session management)
# ------------------------------------------------------------------------------
def get_conversation_context(patient_id: str) -> Dict[str, any]:
    """
    Retrieve recent conversation context for a patient.
    Replace this with your actual session/conversation manager call.
    """
    return {
        "recent_messages": [
            "I have been worried about my blood sugar levels.",
            "Last week I asked how to control my diabetes."
        ],
        "user_facts": {"diabetes": True}
    }

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Symptom Analysis & Risk Assessment - Enhanced for ANNA Chatbot
# ------------------------------------------------------------------------------
class SymptomAnalyzer:
    """
    Handles all aspects of symptom analysis and risk assessment with
    properly implemented async methods.
    """
    def __init__(self, openai_client=None):
        """Initialize with optional OpenAI client"""
        from django.conf import settings
        from openai import AsyncOpenAI
        
        self.openai_client = openai_client or AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        self.fhir_service = FHIRService()
        
        # Define red flag symptoms
        self.RED_FLAGS = {
            'chest_pain': [
                'chest pain', 'chest tightness', 'crushing pain',
                'heart attack', 'cardiac', 'heart pain'
            ],
            'breathing': [
                'cannot breathe', 'difficulty breathing', 'shortness of breath',
                'struggling to breathe', 'gasping', 'choking'
            ],
            'stroke': [
                'face drooping', 'arm weakness', 'speech difficulty',
                'numbness one side', 'sudden confusion', 'sudden dizziness'
            ],
            'consciousness': [
                'unconscious', 'passed out', 'fainting',
                'not responding', 'lost consciousness'
            ],
            'bleeding': [
                'severe bleeding', 'heavy bleeding', 'uncontrolled bleeding',
                'bleeding heavily', 'blood loss'
            ],
            'allergic': [
                'anaphylaxis', 'allergic reaction', 'throat swelling',
                'cannot swallow', 'severe allergy'
            ]
        }
        
        # Risk levels with their descriptions
        self.RISK_LEVELS = {
            'EMERGENCY': {
                'level': 4,
                'action': 'CALL EMERGENCY SERVICES IMMEDIATELY (112 or 999)',
                'urgency': 'Immediate emergency attention required'
            },
            'HIGH': {
                'level': 3,
                'action': 'Seek immediate medical attention or go to the nearest urgent care center',
                'urgency': 'Urgent medical attention recommended'
            },
            'MEDIUM': {
                'level': 2,
                'action': 'Consider visiting urgent care or booking an urgent appointment',
                'urgency': 'Prompt medical attention advised'
            },
            'LOW': {
                'level': 1,
                'action': 'Schedule a routine appointment with your healthcare provider',
                'urgency': 'Non-urgent medical attention'
            }
        }

    async def red_flag_checker(self, symptom_description):
        """
        Check for red flag symptoms that require immediate emergency attention
        Returns: tuple (bool, list of matched red flags)
        """
        try:
            symptom_description = symptom_description.lower()
            matched_flags = []

            for category, phrases in self.RED_FLAGS.items():
                if any(phrase in symptom_description for phrase in phrases):
                    matched_flags.append(category)
                    logging.warning(f"Red flag detected: {category} in symptom: {symptom_description}")

            return bool(matched_flags), matched_flags

        except Exception as e:
            logging.error(f"Error in red flag checking: {str(e)}")
            return True, ['error_defaulting_to_emergency']  # Err on side of caution

    async def symptom_analyzer(self, symptom_description, patient_data=None):
        """
        Analyze symptoms using OpenAI for severity assessment
        Returns: dict with analysis results
        """
        try:
            prompt = self._build_analysis_prompt(symptom_description, patient_data)
            
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You are a medical triage assistant. Always respond with a valid JSON object."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}  # Force JSON response format
            )

            analysis = response.choices[0].message.content
            try:
                import json
                analysis = json.loads(analysis)
                logging.info(f"Symptom analysis completed: {analysis}")
            except json.JSONDecodeError as e:
                logging.error(f"Error parsing JSON response: {e}, content: {analysis}")
                # If the response can't be parsed as JSON, extract "severity" if possible
                if '"severity"' in analysis:
                    severity = "HIGH"  # Default
                    if '"severity":"MILD"' in analysis.replace(" ", ""):
                        severity = "MILD"
                    elif '"severity":"MODERATE"' in analysis.replace(" ", ""):
                        severity = "MODERATE"
                    elif '"severity":"SEVERE"' in analysis.replace(" ", ""):
                        severity = "SEVERE"
                    elif '"severity":"CRITICAL"' in analysis.replace(" ", ""):
                        severity = "CRITICAL"
                        
                    analysis = {
                        'severity': severity,
                        'confidence': 0.7,
                        'recommendation': 'Extracted from malformed JSON response',
                        'possible_causes': ['Unknown - JSON parsing error'],
                        'next_steps': ['Consult a healthcare professional']
                    }
                else:
                    # Default cautious response
                    analysis = {
                        'severity': 'HIGH',
                        'confidence': 0.5,
                        'recommendation': 'See a healthcare professional soon',
                        'possible_causes': ['Unable to analyze symptoms'],
                        'next_steps': ['Consult a healthcare professional']
                    }
                
            return analysis

        except Exception as e:
            logging.error(f"Error in symptom analysis: {str(e)}")
            return {
                'severity': 'HIGH',
                'confidence': 0.0,
                'recommendation': 'Due to analysis error, recommending careful evaluation',
                'error': str(e)
            }

    def _build_analysis_prompt(self, symptom_description, patient_data=None):
        """
        Build a prompt for the OpenAI API to analyze symptoms.
        """
        # Base prompt elements
        prompt_parts = [
            "MEDICAL SYMPTOM ASSESSMENT: Analyze the following symptoms in JSON format.\n",
            f"USER SYMPTOMS: {symptom_description}\n",
        ]
        
        # Add patient context if available
        if patient_data:
            age = None
            gender = None
            conditions = []
            
            if isinstance(patient_data, dict):
                # Extract age if birthDate is available
                if 'birthDate' in patient_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.strptime(patient_data['birthDate'], "%Y-%m-%d")
                        today = datetime.today()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except:
                        pass
                
                # Extract gender
                gender = patient_data.get('gender')
                
                # Try to extract conditions if they exist in the data
                if 'condition' in patient_data:
                    for condition in patient_data['condition']:
                        if isinstance(condition, dict) and 'code' in condition and 'text' in condition['code']:
                            conditions.append(condition['code']['text'])
            
            if age or gender or conditions:
                prompt_parts.append("PATIENT CONTEXT:")
                if age:
                    prompt_parts.append(f"- Age: {age}")
                if gender:
                    prompt_parts.append(f"- Gender: {gender}")
                if conditions:
                    prompt_parts.append(f"- Existing conditions: {', '.join(conditions)}")
                prompt_parts.append("\n")
        
        # Add response format instructions
        prompt_parts.append("""
RESPONSE FORMAT: Return a JSON object with the following keys:
{
    "severity": "MILD|MODERATE|SEVERE|CRITICAL",
    "confidence": <float between 0 and 1>,
    "recommendation": "<action recommendation>",
    "possible_causes": ["<cause1>", "<cause2>"],
    "next_steps": ["<step1>", "<step2>"]
}
        """)
        
        return "\n".join(prompt_parts)

    async def risk_level_determiner(self, symptom_analysis, red_flags=None):
        """
        Determine risk level based on symptom analysis and red flags
        Returns: dict with risk assessment
        """
        try:
            if red_flags:
                return {
                    'level': 'EMERGENCY',
                    'action': self.RISK_LEVELS['EMERGENCY']['action'],
                    'urgency': self.RISK_LEVELS['EMERGENCY']['urgency'],
                    'red_flags': red_flags,
                    'timestamp': datetime.utcnow().isoformat()
                }

            # Map severity to risk level
            severity_mapping = {
                'MILD': 'LOW',
                'MODERATE': 'MEDIUM',
                'SEVERE': 'HIGH',
                'CRITICAL': 'EMERGENCY'
            }

            assessed_level = severity_mapping.get(
                symptom_analysis.get('severity', 'SEVERE'),  # Default to SEVERE if unclear
                'HIGH'  # Default to HIGH if mapping fails
            )

            return {
                'level': assessed_level,
                'action': self.RISK_LEVELS[assessed_level]['action'],
                'urgency': self.RISK_LEVELS[assessed_level]['urgency'],
                'confidence': symptom_analysis.get('confidence', 0.0),
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            logging.error(f"Error in risk level determination: {str(e)}")
            return {
                'level': 'HIGH',  # Default to HIGH on error
                'action': self.RISK_LEVELS['HIGH']['action'],
                'urgency': self.RISK_LEVELS['HIGH']['urgency'],
                'error': str(e)
            }

    def response_formatter(self, risk_assessment, patient_data=None):
        """
        Format risk assessment into user-friendly messages
        Returns: dict with formatted messages
        """
        # Define disclaimer
        disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice. Always consult a healthcare professional."
        
        try:
            # Format messages based on risk level
            if risk_assessment['level'] == 'EMERGENCY':
                messages = [
                    " EMERGENCY: SEEK IMMEDIATE MEDICAL ATTENTION",
                    f"Urgency: {risk_assessment['urgency']}",
                    f"Action: {risk_assessment['action']}",
                    "",
                    disclaimer
                ]
            
            # High risk message template
            elif risk_assessment['level'] == 'HIGH':
                messages = [
                    " URGENT MEDICAL ATTENTION RECOMMENDED",
                    f"Recommendation: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Get medical attention today",
                    "- If symptoms worsen, call emergency services",
                    "- Keep someone informed of your condition",
                    "",
                    disclaimer
                ]

            # Medium risk message template
            elif risk_assessment['level'] == 'MEDIUM':
                messages = [
                    " MEDICAL ATTENTION RECOMMENDED",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Options:",
                    "- Visit an urgent care center",
                    "- Book an urgent appointment with your doctor",
                    "- Monitor your symptoms closely",
                    "",
                    disclaimer
                ]

            # Low risk message template
            else:
                messages = [
                    " MEDICAL GUIDANCE",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Book a routine appointment",
                    "- Monitor your symptoms",
                    "- If condition worsens, seek urgent care",
                    "",
                    disclaimer
                ]

            # Add local emergency numbers if available
            resource_data = None
            
            if patient_data and isinstance(patient_data, dict):
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                    
            if resource_data and isinstance(resource_data, dict) and 'address' in resource_data:
                country = resource_data['address'][0].get('country', 'Unknown')
                messages.append(f"\nLocal emergency numbers for {country}:")
                if country == "Italy":
                    messages.append("Emergency: 112")
                    messages.append("Medical Emergency: 118")
                elif country == "United Kingdom":
                    messages.append("Emergency: 999")
                    messages.append("Non-emergency medical help: 111")
                elif country == "United States":
                    messages.append("Emergency: 911")
                else:
                    messages.append("Common Emergency Number: 112")
            
            return {"messages": messages}
            
        except Exception as e:
            logging.error(f"Error formatting response: {str(e)}")
            return {
                "messages": [
                    " MEDICAL ATTENTION RECOMMENDED",
                    "I encountered an error analyzing your symptoms. Please consult a healthcare professional.",
                    disclaimer
                ]
            }

    # Personalized Medical Advice Service (Hybrid Approach, Async)
# ------------------------------------------------------------------------------
class PersonalizedMedicalAdviceService:
    def __init__(self, gpt_client=None, openai_client=None):
        """Initialize with optional GPT client and/or OpenAI client"""
        from django.conf import settings
        from openai import AsyncOpenAI
        
        # Set up GPT client
        if gpt_client:
            self.gpt_client = gpt_client
        else:
            self.gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
        
        # Set up OpenAI client directly
        self.openai_client = openai_client or AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
            
        # Use your actual FHIRService from your codebase
        self.fhir_service = FHIRService()
        
        # Create symptom analyzer and pass the OpenAI client
        self.symptom_analyzer = SymptomAnalyzer(openai_client=self.openai_client)
        
        # Screening guidelines by age
        self.screening_guidelines = {
            "colonoscopy": {
                "min_age": 45,
                "high_risk_factors": [
                    "colorectal cancer", "colon cancer", "rectal cancer", "polyp", 
                    "inflammatory bowel disease", "crohn", "ulcerative colitis",
                    "lynch syndrome", "familial adenomatous polyposis"
                ],
                "frequency": "every 10 years if normal"
            },
            "mammogram": {
                "min_age": 40,
                "high_risk_factors": ["breast cancer", "brca", "dense breasts"],
                "frequency": "annually"
            },
            "psa_screening": {
                "min_age": 55,
                "high_risk_factors": ["prostate cancer"],
                "frequency": "discuss with doctor"
            }
        }

    async def get_personalized_advice(self, patient_id: str, user_query: str) -> str:
        """
        Combines patient data, conversation context, and evidence-based guidelines
        into a prompt for GPT-4, and returns personalized medical advice.
        """
        # Retrieve patient data via your FHIRService (using your real FHIR query)
        patient_resource = await asyncio.to_thread(self.fhir_service.get_patient, patient_id)
        if not patient_resource:
            return "Error: Patient data not found."

        patient_data = self._extract_patient_data(patient_resource)
        context = get_conversation_context(patient_id)
        recent_msgs = context.get("recent_messages", [])
        context_summary = await summarize_messages(recent_msgs, self.gpt_client)

        conditions = patient_data.get("conditions", [])
        guidelines = get_evidence_based_guidelines(conditions)

        prompt = self._build_prompt(user_query, patient_data, context_summary, guidelines)
        logger.info("Constructed prompt for GPT-4:")
        logger.info(prompt)

        advice = await self.gpt_client.generate_advice(prompt)
        advice = self._ensure_disclaimer(advice)
        return advice
        
    def _extract_medical_topic(self, message):
        """
        Extract the main medical topic from a user message.
        """
        # List of common medical topics to check for
        medical_topics = {
            "diabetes": ["diabetes", "blood sugar", "glucose", "insulin"],
            "high blood pressure": ["high blood pressure", "hypertension", "blood pressure"],
            "cold vs flu": ["cold", "flu", "influenza", "difference between cold and flu"],
            "chest pain": ["chest pain", "heart attack", "angina"],
            "sprained ankle": ["sprain", "ankle", "sprained ankle", "twisted ankle"],
            "cholesterol": ["cholesterol", "ldl", "hdl", "lipids", "triglycerides"]
        }
        
        # Convert message to lowercase for case-insensitive matching
        message_lower = message.lower()
        
        # Check for topic matches
        for topic, keywords in medical_topics.items():
            if any(keyword in message_lower for keyword in keywords):
                return topic
                
        # No specific topic found
        return None

    async def get_screening_recommendation(self, patient_data=None, screening_type=None, user_age=None):
        """
        Provides personalized recommendations for medical screenings based on 
        patient age, risk factors, and evidence-based guidelines.
        
        Args:
            patient_data: Patient data dictionary (optional)
            screening_type: Type of screening to provide recommendation for (e.g., "colonoscopy")
            user_age: Patient's age if known (optional, will extract from patient data if not provided)
            
        Returns:
            Dict with personalized recommendation messages
        """
        try:
            # Include the standard medical disclaimer
            disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
            
            # Default responses for unknown screenings
            if not screening_type or screening_type.lower() not in self.screening_guidelines:
                return {
                    "messages": [
                        "I don't have specific screening guidelines for that procedure.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Normalize screening type
            screening_type = screening_type.lower()
            for key in self.screening_guidelines:
                if key in screening_type or screening_type in key:
                    screening_type = key
                    break
            
            # Get guidelines for this screening type
            guidelines = self.screening_guidelines.get(screening_type)
            if not guidelines:
                return {
                    "messages": [
                        f"I don't have specific guidelines for {screening_type}.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Extract patient age if not provided
            age = user_age
            if not age and patient_data and isinstance(patient_data, dict):
                # Check if patient_data is a wrapped resource
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                
                if 'birthDate' in resource_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.fromisoformat(resource_data['birthDate'].replace('Z', '+00:00'))
                        today = datetime.now()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except (ValueError, TypeError):
                        pass
            
            # Check for risk factors
            has_risk_factors = False
            risk_factors_found = []
            
            if patient_data and isinstance(patient_data, dict):
                # Check conditions in patient data
                conditions = []
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                    if 'conditions' in resource_data:
                        conditions = resource_data['conditions']
                
                # Look for risk factors in conditions
                for condition in conditions:
                    condition_name = condition.get('name', '').lower() if isinstance(condition, dict) else str(condition).lower()
                    for risk_factor in guidelines['high_risk_factors']:
                        if risk_factor.lower() in condition_name:
                            has_risk_factors = True
                            risk_factors_found.append(risk_factor)
            
            # Personalized recommendation based on age and risk factors
            min_age = guidelines['min_age']
            frequency = guidelines['frequency']
            
            if age is None:
                # No age information available
                return {
                    "messages": [
                        f"General guideline: {screening_type.title()} screening typically begins at age {min_age} for most people, {frequency}.",
                        "I don't have your age information, so I can't provide a personalized recommendation.",
                        "Please consult with your healthcare provider to determine if this screening is appropriate for you.",
                        disclaimer
                    ]
                }
            elif age < min_age and not has_risk_factors:
                # Under recommended age with no risk factors
                return {
                    "messages": [
                        f"Based on current guidelines, routine {screening_type} screening is recommended starting at age {min_age} for average-risk individuals.",
                        f"Since you are {age} years old and have no documented high-risk factors, routine screening is not yet recommended.",
                        "However, if you have a family history or other risk factors not in your medical record, discuss earlier screening with your doctor.",
                        disclaimer
                    ]
                }
            elif age < min_age and has_risk_factors:
                # Under recommended age but has risk factors
                return {
                    "messages": [
                        f"While routine {screening_type} screening typically starts at age {min_age}, you have risk factors that may warrant earlier screening.",
                        f"Based on your medical record, you have: {', '.join(risk_factors_found)}",
                        f"At age {age} with these risk factors, you should discuss with your doctor about getting screened now.",
                        disclaimer
                    ]
                }
            else:
                # At or above recommended age
                return {
                    "messages": [
                        f"Based on current guidelines, you should have a {screening_type} screening now.",
                        f"At age {age}, routine {screening_type} screening is recommended {frequency}.",
                        "You can schedule this procedure through your healthcare provider's office or patient portal.",
                        disclaimer
                    ]
                }
                
        except Exception as e:
            logger.error(f"Error generating screening recommendation: {str(e)}")
            return {
                "messages": [
                    "I'm sorry, I couldn't generate a specific recommendation.",
                    "Please consult with your healthcare provider about appropriate screening tests for you.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }
            
    async def handle_symptom_query(self, message, patient_data=None, topic=None, additional_data=None, conversation_context=None):
        """
        Main method to handle symptom queries - providing personalized medical advice
        using structured templates for common conditions and GPT for others
        
        Args:
            message: The user's symptom description
            patient_data: Patient data from FHIR (optional)
            topic: Specific medical topic to focus on (optional)
            additional_data: Any additional data like lab results, conditions etc. (optional)
            conversation_context: Context from previous conversations (optional)
            
        Returns:
            Dict with personalized advice messages
        """
        try:
            # Import our new modules (only import on demand to avoid circular imports)
            from chatbot.views.utils.response_formatter import format_symptom_response, format_medical_response
            from chatbot.views.utils.medical_info_templates import get_template_for_topic
            
            # Extract relevant patient info if available
            name = "there"
            age = None
            gender = None
            
            if patient_data:
                if isinstance(patient_data, dict):
                    # Try to get name
                    if 'name' in patient_data and isinstance(patient_data['name'], list) and patient_data['name']:
                        given_name = patient_data['name'][0].get('given', [''])[0] if patient_data['name'][0].get('given') else ''
                        name = given_name or "there"
                        
                    # Try to get age
                    if 'birthDate' in patient_data:
                        from datetime import datetime
                        try:
                            birth_date = datetime.strptime(patient_data['birthDate'], "%Y-%m-%d")
                            today = datetime.today()
                            age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                        except:
                            pass  # Keep age as None if can't calculate
                            
                    # Get gender
                    if 'gender' in patient_data:
                        gender = patient_data['gender']
            
            # Check if we have additional data (FHIR resources like Condition or MedicationStatement)
            patient_conditions = []
            patient_allergies = []
            patient_medications = []
            relevant_history = []
            
            # Extract conditions, medications, and allergies from additional_data if available
            if additional_data:
                if isinstance(additional_data, dict):
                    # Check if it's a FHIR Bundle with entries
                    if 'resourceType' in additional_data and additional_data['resourceType'] == 'Bundle' and 'entry' in additional_data:
                        for entry in additional_data['entry']:
                            resource = entry.get('resource', {})
                            resource_type = resource.get('resourceType')
                            
                            # Extract conditions
                            if resource_type == 'Condition' and resource.get('clinicalStatus', {}).get('coding', [{}])[0].get('code') == 'active':
                                condition_name = resource.get('code', {}).get('text', 'Unknown condition')
                                patient_conditions.append(condition_name)
                                
                            # Extract medications
                            elif resource_type == 'MedicationStatement' and resource.get('status') == 'active':
                                med_name = resource.get('medicationCodeableConcept', {}).get('text', 'Unknown medication')
                                patient_medications.append(med_name)
                                
                            # Extract allergies
                            elif resource_type == 'AllergyIntolerance':
                                allergy_name = resource.get('code', {}).get('text', 'Unknown allergy')
                                patient_allergies.append(allergy_name)
            
            # Use provided topic or attempt to identify it from the message
            identified_topic = topic or await self._extract_symptom_keyphrase(message)
            template = get_template_for_topic(identified_topic) if identified_topic else None
            
            # Check for follow-up questions using context
            is_follow_up = False
            current_topic = None
            if conversation_context and conversation_context.get('user_facts'):
                # Check if we have a current_topic stored in user_facts
                current_topic = conversation_context.get('user_facts', {}).get('current_topic')
                
                # Check if this is a short message that might be a follow-up
                if len(message.split()) <= 8 and current_topic:
                    follow_up_indicators = [
                        "what", "why", "how", "should", "could", "when", "is it", "are there", 
                        "causes", "treated", "serious", "normal", "treatment", "cure", "heal",
                        "help", "manage", "deal with", "handle", "ease", "relieve", "mean"
                    ]
                    # Check if message contains follow-up indicators
                    if any(indicator in message.lower() for indicator in follow_up_indicators):
                        is_follow_up = True
                        # If we don't have a topic from the current message, use the current_topic
                        if not identified_topic and current_topic:
                            identified_topic = current_topic
                            template = get_template_for_topic(identified_topic) if identified_topic else None
                            logging.info(f"Follow-up detected, using previous topic: {current_topic}")
            
            # Check if this is an issue report - should be specifically routed to the new pathway
            is_issue_report = conversation_context and conversation_context.get('intent') == 'issue_report'
            
            # If we have a matching template, use it for a high-quality response
            if template and not is_issue_report:  # Skip template for issue reports to use our new pathway
                logging.info(f"Using template for topic: {identified_topic}")
                
                # Store the current topic in the response for context tracking
                # This will be helpful for follow-up questions
                if identified_topic:
                    if conversation_context and 'user_facts' in conversation_context:
                        conversation_context['user_facts']['current_topic'] = identified_topic
                        logging.info(f"Updated current_topic in user_facts: {identified_topic}")
                
                # Format using our new structured formatter
                if "variants" in template:
                    # This is a condition with variants (like cold vs flu)
                    from chatbot.views.utils.response_formatter import format_condition_variants
                    messages = format_condition_variants(
                        identified_topic, 
                        template["variants"]
                    )
                else:
                    # Standard medical info or symptom template
                    messages = format_medical_response(
                        question=message,
                        response_data=template,
                        include_brief_answer=True
                    )
                
                # For templates, also check if we need to add personalized warnings based on patient history
                if patient_conditions or patient_medications or patient_allergies:
                    # Try to determine if any conditions/meds/allergies are relevant to the current topic
                    relevant_history = await self._find_relevant_medical_history(
                        topic=identified_topic,
                        conditions=patient_conditions,
                        medications=patient_medications,
                        allergies=patient_allergies
                    )
                    
                    # If we found relevant history, include it at the top of the response
                    if relevant_history:
                        relevant_info = " Note: "
                        if len(relevant_history) == 1:
                            relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {identified_topic}."
                        else:
                            conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                            relevant_info += f"You have a history of {conditions_list}, which may affect management of {identified_topic}."
                        
                        # Insert at the beginning of the messages
                        messages.insert(0, relevant_info)
                
                return {"messages": messages}
            
            # For issue reports or if no template, try to get MedlinePlus info or generate a response
            if is_issue_report or identified_topic:
                logging.info(f"Processing issue report for: {identified_topic or message}")
                
                # Extract the symptom keyphrase if we don't already have it
                if not identified_topic:
                    identified_topic = await self._extract_symptom_keyphrase(message)
                
                # If we have a keyphrase, try to get guidelines
                medlineplus_results = None
                if identified_topic:
                    try:
                        # First check if we can resolve a SNOMED code for the keyphrase
                        condition_code = await self.resolve_condition_code(identified_topic)
                        
                        if condition_code:
                            # Try to get MedlinePlus guidelines
                            medlineplus_results = await self._get_direct_medlineplus_info(identified_topic, condition_code)
                    except Exception as e:
                        logging.error(f"Error getting MedlinePlus info for {identified_topic}: {str(e)}")
                
                # Generate personalized response
                messages = []
                
                # Start with personalized warnings based on patient history if available
                if patient_conditions or patient_medications or patient_allergies:
                    relevant_history = await self._find_relevant_medical_history(
                        topic=identified_topic,
                        conditions=patient_conditions,
                        medications=patient_medications,
                        allergies=patient_allergies
                    )
                    
                    if relevant_history:
                        relevant_info = " Note: "
                        if len(relevant_history) == 1:
                            relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {identified_topic}."
                        else:
                            conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                            relevant_info += f"You have a history of {conditions_list}, which may affect management of {identified_topic}."
                        
                        messages.append(relevant_info)
                        messages.append("")  # Add a blank line
                
                # Use MedlinePlus guidelines if available
                if medlineplus_results and 'messages' in medlineplus_results:
                    # Add the main MedlinePlus info
                    messages.extend(medlineplus_results['messages'])
                else:
                    # Use fallback generic guidance
                    messages.extend([
                        f"For {identified_topic or 'your symptoms'}:",
                        "- Rest and avoid exacerbating activities",
                        "- Apply ice or heat as appropriate",
                        "- Consider over-the-counter analgesics",
                        "- Consult your healthcare provider if symptoms persist beyond 3 days"
                    ])
                
                # Ensure we have the standard disclaimer at the end
                from chatbot.views.utils.response_formatter import STANDARD_DISCLAIMER
                if not any(STANDARD_DISCLAIMER.lower() in msg.lower() for msg in messages):
                    messages.append("")  # Add a blank line
                    messages.append(STANDARD_DISCLAIMER)
                
                # Update the session with the current topic
                if identified_topic and conversation_context and 'user_facts' in conversation_context:
                    conversation_context['user_facts']['current_topic'] = identified_topic
                
                return {"messages": messages, "extracted_topic": identified_topic}
            
            # Try the existing MedlinePlus info retrieval for backward compatibility
            try:
                logging.info(f"Attempting to retrieve specific MedlinePlus info for: {message}")
                
                # For follow-up questions, use the current topic if available
                lookup_message = message
                if is_follow_up and current_topic:
                    lookup_message = f"{current_topic} {message}"
                    logging.info(f"Enhanced lookup message for follow-up: {lookup_message}")
                
                specific_info = await self.provide_specific_info(lookup_message)
                if specific_info and specific_info.get("messages") and len(specific_info["messages"]) > 0:
                    # We have specific MedlinePlus info available, use it
                    logging.info(f"Successfully retrieved and using MedlinePlus info for: {lookup_message}")
                    
                    # Store the topic if it was extracted from provide_specific_info
                    if specific_info.get("extracted_topic") and conversation_context and 'user_facts' in conversation_context:
                        conversation_context['user_facts']['current_topic'] = specific_info["extracted_topic"]
                        logging.info(f"Updated current_topic from MedlinePlus: {specific_info['extracted_topic']}")
                    
                    # Add personalized warnings based on patient history if available
                    if patient_conditions or patient_medications or patient_allergies:
                        extracted_topic = specific_info.get("extracted_topic")
                        if extracted_topic:
                            relevant_history = await self._find_relevant_medical_history(
                                topic=extracted_topic,
                                conditions=patient_conditions,
                                medications=patient_medications,
                                allergies=patient_allergies
                            )
                            
                            if relevant_history:
                                relevant_info = " Note: "
                                if len(relevant_history) == 1:
                                    relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {extracted_topic}."
                                else:
                                    conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                                    relevant_info += f"You have a history of {conditions_list}, which may affect management of {extracted_topic}."
                                
                                # Insert at the beginning of the messages
                                specific_info["messages"].insert(0, relevant_info)
                    
                    return specific_info
                else:
                    logging.info(f"No specific MedlinePlus info found for: {lookup_message}")
            except Exception as e:
                logging.error(f"Error retrieving MedlinePlus info: {str(e)}")
                # Continue to fallback if MedlinePlus retrieval fails
                
            # Fallback to symptom analyzer for general symptom queries
            try:
                symptoms = message
                severity = "MEDIUM"  # Default severity
                analysis = None  # Initialize analysis variable
                
                # Check for emergency keywords
                emergency_keywords = [
                    "chest pain", "can't breathe", "difficulty breathing", "stroke", 
                    "heart attack", "severe bleeding", "unconscious", "passed out"
                ]
                if any(keyword in message.lower() for keyword in emergency_keywords):
                    severity = "EMERGENCY"
                
                # For non-emergency cases, get a more detailed assessment from symptom analyzer
                else:
                    # Use the symptom analyzer if available
                    if hasattr(self, 'symptom_analyzer'):
                        # Check for red flags first
                        red_flag_result, red_flags = await self.symptom_analyzer.red_flag_checker(message)
                        if red_flag_result:
                            severity = "EMERGENCY"
                        else:
                            analysis = await self.symptom_analyzer.symptom_analyzer(message, patient_data)
                            if analysis:
                                symptom_severity = analysis.get('severity', 'MODERATE').upper()
                                # Map to our severity levels
                                if symptom_severity in ['SEVERE', 'CRITICAL']:
                                    severity = "HIGH"
                                elif symptom_severity in ['MODERATE']:
                                    severity = "MEDIUM"
                                elif symptom_severity in ['MILD']:
                                    severity = "LOW"
                
                # Use our new structured symptom response formatter
                recommendations = [
                    "Rest and monitor your symptoms",
                    "Stay hydrated with plenty of fluids",
                    "Consider over-the-counter medications for symptom relief"
                ]
                
                when_to_seek_help = [
                    "Symptoms worsen or don't improve within a few days",
                    "You develop a high fever (over 102F/39C)",
                    "You experience severe pain or discomfort",
                    "You have difficulty breathing, chest pain, or severe headache",
                    "You feel dizzy, confused, or disoriented"
                ]
                
                # Add specific recommendations based on keywords in the query
                if "headache" in message.lower():
                    recommendations.append("Rest in a quiet, darkened room")
                    recommendations.append("Apply a cold or warm compress to your head")
                    
                if "sore throat" in message.lower():
                    recommendations.append("Gargle with warm salt water (1/4 tsp salt in 8 oz water)")
                    recommendations.append("Use throat lozenges or throat sprays for temporary relief")
                
                # Add personalized warnings based on patient history if available
                personalized_note = None
                if patient_conditions or patient_medications or patient_allergies:
                    # Extract symptom keyphrase for relevance check
                    keyphrase = await self._extract_symptom_keyphrase(message)
                    if keyphrase:
                        relevant_history = await self._find_relevant_medical_history(
                            topic=keyphrase,
                            conditions=patient_conditions,
                            medications=patient_medications,
                            allergies=patient_allergies
                        )
                        
                        if relevant_history:
                            if len(relevant_history) == 1:
                                personalized_note = f" Note: You have a history of {relevant_history[0]}, which may affect management of your symptoms."
                            else:
                                conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                                personalized_note = f" Note: You have a history of {conditions_list}, which may affect management of your symptoms."
                
                from chatbot.views.utils.response_formatter import format_symptom_response
                messages = format_symptom_response(
                    symptoms=symptoms,
                    severity=severity,
                    recommendations=recommendations,
                    when_to_seek_help=when_to_seek_help,
                    personalized_note=personalized_note  # Add the personalized note if available
                )
                
                return {"messages": messages}
                
            except Exception as symptom_error:
                logging.error(f"Error in symptom analysis: {str(symptom_error)}")
                
                # Fall back to GPT for personalization if symptom analysis fails
                # Format patient information string for prompt
                patient_info = []
                if name != "there":
                    patient_info.append(f"Name: {name}")
                if age:
                    patient_info.append(f"Age: {age}")
                if gender:
                    patient_info.append(f"Gender: {gender}")
                
                # Add conditions, medications, and allergies to patient info
                if patient_conditions:
                    patient_info.append(f"Conditions: {', '.join(patient_conditions)}")
                if patient_medications:
                    patient_info.append(f"Medications: {', '.join(patient_medications)}")
                if patient_allergies:
                    patient_info.append(f"Allergies: {', '.join(patient_allergies)}")
                
                # Format patient info string or use generic greeting if no data available
                patient_line = f"Patient: {', '.join(patient_info)}" if patient_info else "Patient"
                    
                # Build a prompt for personalized medical advice
                prompt = f"""As a helpful medical advisor, provide personalized advice for this person:

{patient_line}
Symptom query: "{message}"
"""
                # Add conversation context if provided
                if conversation_context:
                    if conversation_context.get('summary'):
                        prompt += f"\nConversation context: {conversation_context['summary']}\n"
                    
                    if conversation_context.get('user_facts') and len(conversation_context['user_facts']) > 0:
                        prompt += f"\nRelevant user facts: {json.dumps(conversation_context['user_facts'])}\n"
                    
                    # Include a few recent messages for context if available
                    recent_messages = conversation_context.get('recent_messages', [])
                    if recent_messages and len(recent_messages) > 0:
                        prompt += "\nRecent conversation:\n"
                        # Get up to 3 most recent messages
                        for msg in recent_messages[-3:]:
                            speaker = "User" if msg.get('is_user', True) else "Assistant"
                            content = msg.get('message', '').strip()
                            if content:
                                prompt += f"{speaker}: {content}\n"
                
                # Add topic information if provided
                if topic:
                    prompt += f"\nSpecific topic focus: {topic}\n"
                elif is_follow_up and current_topic:
                    prompt += f"\nThis is a follow-up question about: {current_topic}\n"
                
                # Add additional data if provided
                if additional_data:
                    prompt += f"\nAdditional patient data: {additional_data}\n"
                
                prompt += """
Please provide:
1. A brief, factual explanation of what might be happening
2. 3-5 practical steps they can take right now to address their symptoms
3. When they should see a doctor

Keep your advice concise and direct, focusing on clear guidance.
IMPORTANT: End with a disclaimer about this being educational not professional medical advice.
"""

                # Get personalized advice from GPT
                from openai import AsyncOpenAI
                from django.conf import settings
                
                # Use symptom_analyzer's client if available, or create a new one
                if hasattr(self, 'symptom_analyzer') and hasattr(self.symptom_analyzer, 'openai_client'):
                    client = self.symptom_analyzer.openai_client
                elif hasattr(self, 'gpt_client'):
                    client = self.gpt_client
                elif hasattr(self, 'openai_client'):
                    client = self.openai_client
                else:
                    # Create a new client as fallback
                    client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
                
                # Debug log for message processing
                print("USER TEXT:", message)
                
                # Create the GPT payload
                gpt_payload = {
                    "model": "gpt-4o-mini",
                    "messages": [
                        {"role": "system", "content": "You are a helpful medical advisor providing accurate, concise advice."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.3  # Lower temperature for more factual responses
                }
                
                # Debug log for the GPT payload
                print("GPT INPUT:", gpt_payload)
                
                response = await client.chat.completions.create(**gpt_payload)
                
                advice = response.choices[0].message.content.strip()
                
                # Split into paragraphs for better message formatting
                advice_paragraphs = [p.strip() for p in advice.split('\n') if p.strip()]
                
                # Add disclaimer if not already present
                from chatbot.views.utils.response_formatter import STANDARD_DISCLAIMER
                if not any(STANDARD_DISCLAIMER.lower() in p.lower() for p in advice_paragraphs):
                    advice_paragraphs.append(STANDARD_DISCLAIMER)
                
                return {"messages": advice_paragraphs}
            
        except Exception as e:
            logging.error(f"Error generating personalized advice: {str(e)}")
            return {
                "messages": [
                    "I apologize, but I encountered an error processing your symptoms.",
                    "For any concerning symptoms, it's best to consult with a healthcare professional.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }
    
    async def _find_relevant_medical_history(self, topic, conditions=None, medications=None, allergies=None):
        """
        Find relevant medical history (conditions, medications, allergies) related to the given topic.
        
        Args:
            topic: The health issue/symptom topic
            conditions: List of patient conditions
            medications: List of patient medications
            allergies: List of patient allergies
            
        Returns:
            List of relevant medical history items
        """
        if not conditions and not medications and not allergies:
            return []
        
        try:
            # Build lists for the API call
            conditions_list = conditions or []
            medications_list = medications or []
            allergies_list = allergies or []
            
            # Use GPT to identify relevant medical history
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": """You are a medical expert that identifies relevant medical history.
                    A person is asking about a health issue, and you need to determine which aspects of their medical history
                    are relevant to this issue. Return a JSON object with relevant items:
                    {
                        "relevant_history": ["item1", "item2", ...]
                    }
                    """},
                    {"role": "user", "content": f"""Health issue/symptom: {topic}
                    
                    Patient medical history:
                    Conditions: {", ".join(conditions_list) if conditions_list else "None"}
                    Medications: {", ".join(medications_list) if medications_list else "None"}
                    Allergies: {", ".join(allergies_list) if allergies_list else "None"}
                    
                    Return only the JSON with relevant history items that could impact management of this health issue."""}
                ],
                response_format={"type": "json_object"},
                temperature=0.1
            )
            
            # Parse the response
            result = json.loads(response.choices[0].message.content)
            relevant_items = result.get("relevant_history", [])
            
            return relevant_items
            
        except Exception as e:
            logging.error(f"Error finding relevant medical history: {str(e)}")
            return []
    
    async def _get_direct_medlineplus_info(self, keyphrase, condition_code):
        """
        Directly query MedlinePlus Connect with a keyphrase and SNOMED code.
        
        Args:
            keyphrase: The health issue/symptom keyphrase
            condition_code: The SNOMED CT code
            
        Returns:
            Dict with formatted messages or None if no info found
        """
        try:
            # Construct the MedlinePlus Connect API URL and parameters
            base_url = "https://connect.medlineplus.gov/service"
            params = {
                "mainSearchCriteria.v.c": condition_code,
                "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
                "mainSearchCriteria.v.dn": keyphrase.replace('_', ' '),
                "informationRecipient.language": "en",
                "knowledgeResponseType": "application/json"
            }
            
            # Make the API request
            import httpx
            async with httpx.AsyncClient() as client:
                response = await client.get(base_url, params=params, timeout=10)
                
                if response.status_code == 200:
                    response_data = json.loads(response.text)
                    guideline_text = None
                    
                    # Extract information from the JSON structure
                    if 'feed' in response_data and 'entry' in response_data['feed']:
                        entries = response_data['feed']['entry']
                        if entries and len(entries) > 0:
                            # Try to get the summary content first
                            if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                guideline_text = entries[0]['summary']['_value'].strip()
                            
                            # If no summary, look for content or title
                            elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                guideline_text = entries[0]['content']['_value'].strip()
                            
                            # Try title as last resort
                            elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                guideline_text = entries[0]['title']['_value'].strip()
                
                    if guideline_text:
                        # We got guidelines, format the response
                        from chatbot.views.utils.response_formatter import format_medical_info_response
                        
                        formatted_messages = format_medical_info_response(
                            topic=keyphrase.replace('_', ' '),
                            summary=f"Here's information about {keyphrase.replace('_', ' ')} from MedlinePlus, a trusted medical resource:",
                            details={
                                "MEDICAL INFORMATION": guideline_text,
                                "RECOMMENDATIONS": [
                                    "Consult with a healthcare provider for a proper diagnosis",
                                    "Follow treatment plans as prescribed by your healthcare provider",
                                    "Keep track of your symptoms and what makes them better or worse"
                                ]
                            }
                        )
                        
                        # Make sure formatted_messages is a list of strings
                        if not all(isinstance(msg, str) for msg in formatted_messages):
                            formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
                        
                        return {"messages": formatted_messages, "extracted_topic": keyphrase}
        
        except Exception as e:
            logging.error(f"Error in _get_direct_medlineplus_info: {str(e)}")
        
        return None

    def _extract_patient_data(self, patient_resource: dict) -> dict:
        """
        Extracts relevant patient data from the FHIR Patient resource.
        Adjust extraction logic according to your actual FHIR resource structure.
        """
        data = {}
        birth_date_str = getattr(patient_resource, "birthDate", None)
        data["age"] = self._calculate_age(birth_date_str) if birth_date_str else "Unknown"
        # Replace these with your actual extraction calls, e.g., using self.fhir_service.get_patient_conditions
        data["conditions"] = ["diabetes", "hypertension"]
        data["medications"] = ["Metformin", "Lisinopril"]
        return data

    def _calculate_age(self, birth_date_str: str) -> int:
        try:
            birth_date = datetime.strptime(birth_date_str, "%Y-%m-%d").date()
            today = datetime.today().date()
            return today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
        except Exception as e:
            logger.error(f"Error calculating age from {birth_date_str}: {e}")
            return 0

    def _build_prompt(self, user_query: str, patient_data: dict,
                      context_summary: str, guidelines: dict) -> str:
        system_message = (
            "You are a clinically accurate medical assistant providing personalized advice based on evidence-based guidelines. "
            "Always include this disclaimer at the end: 'This information is for educational purposes only and is not a substitute for professional medical advice.'"
        )
        prompt_lines = [system_message, "\nPatient Data:"]
        for key, value in patient_data.items():
            prompt_lines.append(f"- {key}: {value}")
        prompt_lines.append("\nEvidence-Based Guidelines:")
        if guidelines:
            for condition, rec in guidelines.items():
                prompt_lines.append(f"- {condition}: {rec}")
        else:
            prompt_lines.append("- None available")
        prompt_lines.append("\nConversation Context Summary:")
        prompt_lines.append(context_summary if context_summary else "No significant context.")
        prompt_lines.append("\nUser Query:")
        prompt_lines.append(user_query)
        return "\n".join(prompt_lines)

    def _ensure_disclaimer(self, advice_text: str) -> str:
        disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
        if disclaimer.lower() not in advice_text.lower():
            advice_text += "\n\n" + disclaimer
        return advice_text
        
    async def resolve_condition_code(self, keyphrase: str) -> str:
        """
        Dynamically resolves a symptom/condition keyphrase to a SNOMED CT code for MedlinePlus queries.
        
        Args:
            keyphrase: The noun or phrase representing the health issue
            
        Returns:
            The SNOMED code if found, or None if not resolvable
        """
        logger.info(f"Attempting to resolve condition code for: {keyphrase}")
        
        # 1. First check our existing mapping
        if keyphrase.lower() in CONDITION_CODE_MAPPING:
            code = CONDITION_CODE_MAPPING[keyphrase.lower()]
            logger.info(f"Found existing code mapping for {keyphrase}: {code}")
            return code
            
        # 2. For compound phrases, try some normalization
        normalized_keyphrase = keyphrase.lower().replace(' ', '_')
        if normalized_keyphrase in CONDITION_CODE_MAPPING:
            code = CONDITION_CODE_MAPPING[normalized_keyphrase]
            logger.info(f"Found normalized code mapping for {keyphrase} -> {normalized_keyphrase}: {code}")
            return code
            
        # 3. Try checking for partial matches (e.g. if "knee pain" is in mapping but keyphrase is "severe knee pain")
        for existing_condition in CONDITION_CODE_MAPPING:
            if existing_condition in keyphrase.lower() or keyphrase.lower() in existing_condition:
                code = CONDITION_CODE_MAPPING[existing_condition]
                logger.info(f"Found partial match mapping for {keyphrase} -> {existing_condition}: {code}")
                return code
                
        # 4. If not found, use GPT to suggest a SNOMED code
        try:
            logger.info(f"No direct mapping found for {keyphrase}, querying GPT for SNOMED code")
            
            # Use OpenAI to map to a standard condition code
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": """You are a medical coding expert that maps symptoms to SNOMED CT codes.
                    Return a JSON object with the following structure:
                    {
                        "snomed_code": "string", 
                        "condition_name": "string",
                        "confidence": float,
                        "explanation": "string"
                    }
                    If unable to map with confidence, set snomed_code to null."""},
                    {"role": "user", "content": f"""Map this health issue description to a SNOMED CT code: "{keyphrase}"
                    
                    Some examples of known mappings:
                    - "back pain" -> "161891005"
                    - "headache" -> "25064002"
                    - "high blood pressure" -> "38341003"
                    - "diabetes" -> "44054006"
                    
                    Please return only the JSON object with the mapping."""}
                ],
                response_format={"type": "json_object"},
                temperature=0.1
            )
            
            # Parse the response
            mapping_result = json.loads(response.choices[0].message.content)
            
            # Check if we got a valid code with good confidence
            if (mapping_result.get("snomed_code") and 
                mapping_result.get("confidence", 0) > 0.7 and
                mapping_result.get("condition_name")):
                
                code = mapping_result["snomed_code"]
                condition_name = mapping_result["condition_name"].lower().replace(' ', '_')
                
                # Add to our local mapping for future use
                CONDITION_CODE_MAPPING[condition_name] = code
                logger.info(f"Added new mapping from GPT: {condition_name} -> {code}")
                
                return code
            else:
                logger.info(f"GPT could not map with confidence: {mapping_result}")
                return None
                
        except Exception as e:
            logger.error(f"Error querying GPT for SNOMED code: {str(e)}")
            return None

    async def provide_specific_info(self, symptom_description):
        """
        Provide specific information for the symptom using MedlinePlus guidelines
        when available, and fallback to predefined guidance when not.
        """
        # Extract keyphrase from symptom description
        keyphrase = await self._extract_symptom_keyphrase(symptom_description)
        
        if not keyphrase:
            # If we couldn't extract a keyphrase, try the older location-based approach
            return await self._legacy_provide_specific_info(symptom_description)
            
        logger.info(f"Extracted keyphrase: {keyphrase} from symptom: {symptom_description}")
        
        # Try to resolve the SNOMED code for the keyphrase
        condition_code = await self.resolve_condition_code(keyphrase)
        
        if condition_code:
            # We have a code, try to get MedlinePlus info
            try:
                # Use a direct call to get_medlineplus_guidelines with the keyphrase and code
                # This is more flexible than the previous approach that required entries in CONDITION_CODE_MAPPING
                base_url = "https://connect.medlineplus.gov/service"
                params = {
                    "mainSearchCriteria.v.c": condition_code,
                    "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
                    "mainSearchCriteria.v.dn": keyphrase.replace('_', ' '),
                    "informationRecipient.language": "en",
                    "knowledgeResponseType": "application/json"
                }
                
                # Make the API request
                import httpx
                async with httpx.AsyncClient() as client:
                    # Make the API request with proper error handling
                    response = await client.get(base_url, params=params, timeout=10)
                    
                    if response.status_code == 200:
                        try:
                            # Parse the JSON response
                            response_data = json.loads(response.text)
                            guideline_text = None
                            
                            # Extract information from the JSON structure
                            # MedlinePlus Connect uses an Atom feed structure
                            if 'feed' in response_data and 'entry' in response_data['feed']:
                                entries = response_data['feed']['entry']
                                if entries and len(entries) > 0:
                                    # Try to get the summary content first
                                    if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                        guideline_text = entries[0]['summary']['_value'].strip()
                                    
                                    # If no summary, look for content or title
                                    elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                        guideline_text = entries[0]['content']['_value'].strip()
                                    
                                    # Try title as last resort
                                    elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                        guideline_text = entries[0]['title']['_value'].strip()
                        
                            if guideline_text:
                                # We got guidelines, format the response
                                from chatbot.views.utils.response_formatter import format_medical_info_response
                                
                                formatted_messages = format_medical_info_response(
                                    topic=keyphrase.replace('_', ' '),
                                    summary=f"Here's information about {keyphrase.replace('_', ' ')} from MedlinePlus, a trusted medical resource:",
                                    details={
                                        "MEDICAL INFORMATION": guideline_text,
                                        "RECOMMENDATIONS": [
                                            "Consult with a healthcare provider for a proper diagnosis",
                                            "Follow treatment plans as prescribed by your healthcare provider",
                                            "Keep track of your symptoms and what makes them better or worse"
                                        ]
                                    }
                                )
                                
                                # Make sure formatted_messages is a list of strings
                                if not all(isinstance(msg, str) for msg in formatted_messages):
                                    formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
                                
                                return {"messages": formatted_messages, "extracted_topic": keyphrase}
                            
                        except json.JSONDecodeError as json_error:
                            logger.error(f"JSON parsing error for MedlinePlus response: {json_error}")
                    
            except Exception as e:
                logger.error(f"Error getting MedlinePlus info for {keyphrase}: {str(e)}")
        
        # Generate a generic fallback response if we couldn't get MedlinePlus info
        messages = [
            f"For {keyphrase.replace('_', ' ')}:",
            "- Rest and avoid exacerbating activities",
            "- Apply ice or heat as appropriate",
            "- Consider over-the-counter analgesics",
            "- Consult your healthcare provider if symptoms persist beyond 3 days"
        ]
        
        return {"messages": messages, "extracted_topic": keyphrase}
    
    async def _extract_symptom_keyphrase(self, symptom_description):
        """
        Extract the key noun phrase representing the health issue from the user's description.
        Uses GPT for high-quality entity extraction.
        """
        try:
            # Debug log for symptom extraction
            print("USER TEXT:", symptom_description)
            
            # Create the GPT payload
            gpt_payload = {
                "model": "gpt-4o-mini",
                "messages": [
                    {"role": "system", "content": """You are a medical NLP expert that extracts key medical terms.
                    Extract the main health issue/symptom from the user's message as a simple noun phrase.
                    Return a JSON object with the following structure:
                    {
                        "keyphrase": "string", 
                        "normalized_term": "string"
                    }
                    For example, if user says "I've been having trouble sleeping for weeks",
                    you would return {"keyphrase": "trouble sleeping", "normalized_term": "insomnia"}"""},
                    {"role": "user", "content": f"""Extract the main health issue from this text: "{symptom_description}"
                    
                    Return only the JSON object with the keyphrase and normalized term."""}
                ],
                "response_format": {"type": "json_object"},
                "temperature": 0.1
            }
            
            # Debug log for the GPT payload
            print("GPT INPUT:", gpt_payload)
            
            response = await self.openai_client.chat.completions.create(**gpt_payload)
            
            # Parse the response
            result = json.loads(response.choices[0].message.content)
            
            # Return normalized term if available, otherwise the keyphrase
            keyphrase = result.get("normalized_term") or result.get("keyphrase")
            
            if keyphrase:
                return keyphrase.lower().strip()
            return None
            
        except Exception as e:
            logger.error(f"Error extracting keyphrase from symptom description: {str(e)}")
            return None
    
    # Keep the legacy method for backward compatibility and as a fallback
    async def _legacy_provide_specific_info(self, symptom_description):
        """
        Legacy implementation of provide_specific_info using location-based approach.
        """
        # Extract location and type of pain
        location = None
        pain_words = ['ache', 'pain', 'hurt', 'sore', 'discomfort']
        
        # Simple location extraction
        body_parts = ['head', 'back', 'chest', 'stomach', 'leg', 'arm', 'foot', 'hand', 'knee', 'ankle']
        for part in body_parts:
            if part in symptom_description.lower():
                location = part
                break
        
        # Generic response
        if not location:
            return {"messages": []}
            
        # Map location to medical condition for MedlinePlus
        condition_mapping = {
            'back': 'back_pain',
            'head': 'headache',
            'leg': 'leg_pain',
            'chest': 'chest_pain',
            'stomach': 'abdominal_pain',
            'arm': 'arm_pain',
            'knee': 'knee_pain',
            'foot': 'foot_pain',
            'hand': 'hand_pain',
            'ankle': 'ankle_pain'
        }
        
        # Try to get MedlinePlus information if available
        medline_info = None
        condition_name = None
        
        if location in condition_mapping:
            # Add to CONDITION_CODE_MAPPING if not already there
            condition_name = condition_mapping[location]
            if condition_name in CONDITION_CODE_MAPPING:
                try:
                    medline_info = await get_medlineplus_guidelines(condition_name)
                    logging.info(f"Retrieved MedlinePlus info for {condition_name}: {medline_info}")
                except Exception as e:
                    logging.error(f"Error getting MedlinePlus info for {condition_name}: {str(e)}")
        
        # If we got MedlinePlus info, use it with better formatting
        if medline_info and medline_info.strip():
            logging.info(f"Found MedlinePlus info for {location} pain")
            
            # Import the response formatter for consistent formatting
            from chatbot.views.utils.response_formatter import format_medical_info_response
            
            # Format the response with proper structure
            formatted_messages = format_medical_info_response(
                topic=f"{location} pain",
                summary=f"Here's information about {location} pain from MedlinePlus, a trusted medical resource:",
                details={
                    "MEDICAL INFORMATION": medline_info,
                    "RECOMMENDATIONS": [
                        "Consult with a healthcare provider for a proper diagnosis",
                        "Follow treatment plans as prescribed by your healthcare provider",
                        "Keep track of your symptoms and what makes them better or worse"
                    ]
                }
            )
            
            # Make sure formatted_messages is a list of strings
            if not all(isinstance(msg, str) for msg in formatted_messages):
                # Convert any non-string elements to strings
                formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
            
            return {"messages": formatted_messages, "extracted_topic": condition_name}
        
        # If no MedlinePlus info, use the more general AI-driven symptom analysis
        # by falling through to the general handler
        
        # Try to trigger a more personalized AI-based analysis instead
        try:
            analysis_response = await self.handle_symptom_query(
                f"{location} pain {symptom_description}", 
                None,  # No patient data needed for general response
                topic=condition_name  # Pass the identified condition as the topic
            )
            
            if analysis_response and "messages" in analysis_response and analysis_response["messages"]:
                # If we got a good AI-generated response, use it
                analysis_response["extracted_topic"] = condition_name
                return analysis_response
        except Exception as ai_error:
            logging.error(f"Error getting AI-based analysis: {str(ai_error)}")
        
        # As a last resort, fall back to predefined guidance
        messages = []
        
        if location == 'back':
            messages = [
                "For back pain:",
                "- Apply ice for the first 48-72 hours, then heat",
                "- Gentle stretching may help, but avoid strenuous activity",
                "- Over-the-counter pain relievers like ibuprofen may help reduce inflammation"
            ]
            condition_name = "back_pain"
        elif location == 'head':
            messages = [
                "For headaches:",
                "- Rest in a quiet, dark room",
                "- Stay hydrated",
                "- Try a cold compress on your forehead",
                "- Track your headaches to identify patterns and triggers"
            ]
            condition_name = "headache"
        elif location == 'leg':
            messages = [
                "For leg pain:",
                "- Rest and elevate the leg when possible",
                "- Apply ice to reduce swelling",
                "- Gentle stretching may help with muscle discomfort",
                "- Avoid prolonged standing if it worsens the pain"
            ]
            condition_name = "leg_pain"
        else:
            messages = [
                f"For {location} pain:",
                "- Rest the affected area when possible",
                "- Apply ice to reduce swelling and inflammation",
                "- Over-the-counter pain relievers may help with discomfort",
                "- Consult your healthcare provider if pain persists or worsens"
            ]
            condition_name = f"{location}_pain"
            
        return {"messages": messages, "extracted_topic": condition_name}

    async def get_screening_recommendation(self, patient_data=None, screening_type=None, user_age=None):
        """
        Provides personalized recommendations for medical screenings based on 
        patient age, risk factors, and evidence-based guidelines.
        
        Args:
            patient_data: Patient data dictionary (optional)
            screening_type: Type of screening to provide recommendation for (e.g., "colonoscopy")
            user_age: Patient's age if known (optional, will extract from patient data if not provided)
            
        Returns:
            Dict with personalized recommendation messages
        """
        try:
            # Include the standard medical disclaimer
            disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
            
            # Default responses for unknown screenings
            if not screening_type or screening_type.lower() not in self.screening_guidelines:
                return {
                    "messages": [
                        "I don't have specific screening guidelines for that procedure.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Normalize screening type
            screening_type = screening_type.lower()
            for key in self.screening_guidelines:
                if key in screening_type or screening_type in key:
                    screening_type = key
                    break
            
            # Get guidelines for this screening type
            guidelines = self.screening_guidelines.get(screening_type)
            if not guidelines:
                return {
                    "messages": [
                        f"I don't have specific guidelines for {screening_type}.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Extract patient age if not provided
            age = user_age
            if not age and patient_data and isinstance(patient_data, dict):
                # Check if patient_data is a wrapped resource
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                
                if 'birthDate' in resource_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.fromisoformat(resource_data['birthDate'].replace('Z', '+00:00'))
                        today = datetime.now()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except (ValueError, TypeError):
                        pass
            
            # Check for risk factors
            has_risk_factors = False
            risk_factors_found = []
            
            if patient_data and isinstance(patient_data, dict):
                # Check conditions in patient data
                conditions = []
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                    if 'conditions' in resource_data:
                        conditions = resource_data['conditions']
                
                # Look for risk factors in conditions
                for condition in conditions:
                    condition_name = condition.get('name', '').lower() if isinstance(condition, dict) else str(condition).lower()
                    for risk_factor in guidelines['high_risk_factors']:
                        if risk_factor.lower() in condition_name:
                            has_risk_factors = True
                            risk_factors_found.append(risk_factor)
            
            # Personalized recommendation based on age and risk factors
            min_age = guidelines['min_age']
            frequency = guidelines['frequency']
            
            if age is None:
                # No age information available
                return {
                    "messages": [
                        f"General guideline: {screening_type.title()} screening typically begins at age {min_age} for most people, {frequency}.",
                        "I don't have your age information, so I can't provide a personalized recommendation.",
                        "Please consult with your healthcare provider to determine if this screening is appropriate for you.",
                        disclaimer
                    ]
                }
            elif age < min_age and not has_risk_factors:
                # Under recommended age with no risk factors
                return {
                    "messages": [
                        f"Based on current guidelines, routine {screening_type} screening is recommended starting at age {min_age} for average-risk individuals.",
                        f"Since you are {age} years old and have no documented high-risk factors, routine screening is not yet recommended.",
                        "However, if you have a family history or other risk factors not in your medical record, discuss earlier screening with your doctor.",
                        disclaimer
                    ]
                }
            elif age < min_age and has_risk_factors:
                # Under recommended age but has risk factors
                return {
                    "messages": [
                        f"While routine {screening_type} screening typically starts at age {min_age}, you have risk factors that may warrant earlier screening.",
                        f"Based on your medical record, you have: {', '.join(risk_factors_found)}",
                        f"At age {age} with these risk factors, you should discuss with your doctor about getting screened now.",
                        disclaimer
                    ]
                }
            else:
                # At or above recommended age
                return {
                    "messages": [
                        f"Based on current guidelines, you should have a {screening_type} screening now.",
                        f"At age {age}, routine {screening_type} screening is recommended {frequency}.",
                        "You can schedule this procedure through your healthcare provider's office or patient portal.",
                        disclaimer
                    ]
                }
                
        except Exception as e:
            logger.error(f"Error generating screening recommendation: {str(e)}")
            return {
                "messages": [
                    "I'm sorry, I couldn't generate a specific recommendation.",
                    "Please consult with your healthcare provider about appropriate screening tests for you.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }

    async def handle_issue_report(self, issue_data: Dict[str, Any], openai_client: AsyncGPT4Client) -> Dict[str, Any]:
        """Handle issue report and generate appropriate response."""
        try:
            # Extract condition and symptoms
            condition = issue_data.get('condition', '').lower()
            symptoms = issue_data.get('symptoms', [])
            
            # Get evidence-based guidelines
            guidelines = get_evidence_based_guidelines([condition])
            
            # Generate personalized advice
            advice = await self.get_personalized_advice(condition, symptoms, guidelines, openai_client)
            
            # Create history note with proper format
            history_note = {
                'type': 'issue_report',
                'condition': condition,
                'condition_code': CONDITION_CODE_MAPPING.get(condition, ''),
                'confidence_level': 'high',
                'symptoms': symptoms,
                'advice': advice
            }
            
            return {
                'status': 'success',
                'advice': advice,
                'history_note': history_note
            }
            
        except Exception as e:
            logger.error(f"Error handling issue report: {str(e)}")
            return {
                'status': 'error',
                'message': 'Failed to process issue report'
            }

# ------------------------------------------------------------------------------
# Stand-Alone Async Script Entry Point for Testing
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)

    async def main():
        gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
        advice_service = PersonalizedMedicalAdviceService(gpt_client)
        example_patient_id = "12345"  # Replace with a valid patient ID from your FHIR server
        user_query = "How should I manage my diabetes effectively?"
        advice = await advice_service.get_personalized_advice(example_patient_id, user_query)
        print("Personalized Medical Advice:")
        print(advice)

    asyncio.run(main())
logger.debug("Personalized medical advice service initialization complete")

================
File: services/post_appointment_checkin_service.py
================
#!/usr/bin/env python
"""
post_appointment_checkin_service.py

A production-ready example of the Post-Appointment Check-In Service for Anna.
This script retrieves recently completed Appointments from a FHIR server (e.g., those
that ended ~24 hours ago), checks patient details, composes a follow-up SMS message,
and sends the message via an SMS provider (e.g., Twilio). It also contains stubs for
handling patient responses and escalating concerns.

FEATURES:
  1. Appointment Retrieval: Fetches Appointment resources with status='finished' (or 'completed')
     and filters them by end time to approximate a 24-hour post-appointment window.
  2. Patient Data Lookup: Retrieves the Patient resource for each appointment, pulling phone number,
     name, and preferred language.
  3. Personalized Follow-Up Message: Composes a message referencing the patient's appointment details
     and prompts them to respond if they have questions or concerns.
  4. SMS Sending: Integrates with your notification service (send_sms); in production, connect this
     to Twilio or another SMS provider.
  5. Logging & Tracking: Logs all sent messages. Includes a stub for storing these logs in a database
     if desired.
  6. Response Handling: Provides methods for processing inbound patient responses and escalating care
     team follow-up when certain keywords (e.g., "pain", "confused") appear.
  7. Internationalization (Optional): Illustrates a `_translate_message` stub, letting you integrate
     a translation API for patients whose preferred language is not English.

USAGE:
  - Schedule this script (e.g., via Celery or a cron job) to run periodically (daily or hourly),
    ensuring it checks which appointments ended ~24 hours ago.
  - Adjust the follow-up window, codes, and search parameters for your organization's needs.
  - Replace the placeholders in get_fhir_client() and send_sms() with real credentials
    and integration code.
  - Fully implement the response handling in a persistent store or inbound message queue.

IMPORTANT:
  - Thoroughly test in your staging environment before deploying to production.
  - Secure any PHI in logs, databases, and transmissions as required by HIPAA or relevant regulations.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.appointment as fhir_appointment
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("PostAppointmentCheckInService")
logger.setLevel(logging.INFO)

# ---------------------------------------------------------------------------------
# Production FHIR client and SMS notification integration
# ---------------------------------------------------------------------------------
print ("31")
def get_fhir_client():
    """
    Configure and return a FHIRClient instance pointed at your FHIR server.
    Update 'api_base' and any OAuth settings as required for production.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your actual endpoint
        # Uncomment/modify if OAuth is required:
        # 'client_id': 'YOUR_CLIENT_ID',
        # 'client_secret': 'YOUR_CLIENT_SECRET',
        # 'authorize_uri': 'https://fhirserver.example.com/auth',
        # 'redirect_uri': 'https://yourapp.example.com/redirect',
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS message via your SMS provider.
    Replace the contents of this function with your actual integration code (e.g., Twilio).
    """
    try:
        logger.info(f"Sending SMS to {to_number}: {message}")
        # Example Twilio usage (pseudo-code):
        # from twilio.rest import Client as TwilioClient
        # import settings  # or use environment variables
        #
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(
        #     body=message,
        #     from_=settings.TWILIO_PHONE_NUMBER,
        #     to=to_number
        # )
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {e}")
        return False

# ---------------------------------------------------------------------------------
# Post-Appointment Check-In Service
# ---------------------------------------------------------------------------------
class PostAppointmentCheckInService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        
        # How long after an appointment ends before sending a check-in (24h is typical)
        self.followup_delay = timedelta(hours=24)
        # A small tolerance window (in hours) around the exact follow-up time to decide
        # if it's "due now." This helps manage slight scheduling offsets.
        self.followup_tolerance = timedelta(hours=2)

    def process_checkins(self):
        """
        Main entry point:
          1. Retrieves 'finished' Appointments that ended ~24 hours ago.
          2. For each Appointment, fetches the associated Patient, composes an SMS,
             and sends the check-in message.
          3. Logs each successful check-in or any failures.
        """
        now = datetime.now()
        appointments = self._get_appointments_due_for_checkin(now)
        logger.info(f"Found {len(appointments)} appointments due for check-in at {now.isoformat()}")

        for appt in appointments:
            patient_id = self._extract_patient_id_from_appointment(appt)
            if not patient_id:
                logger.warning(f"No patient ID found in Appointment/{appt.id}, skipping check-in.")
                continue

            patient = self._get_patient_resource(patient_id)
            if not patient:
                logger.warning(f"Could not retrieve Patient/{patient_id}, skipping check-in.")
                continue

            phone = self._get_patient_phone_number(patient)
            if not phone:
                logger.warning(f"Patient {patient_id} has no phone number; skipping check-in.")
                continue

            patient_name = self._get_patient_name(patient)
            preferred_lang = self._get_patient_preferred_language(patient)

            message = self._compose_checkin_message(appt, patient_name)
            message = self._translate_message(message, preferred_lang)

            # Send the SMS check-in
            if self.notification_service(phone, message):
                logger.info(
                    f"Sent post-appointment check-in to patient {patient_id} for Appointment/{appt.id}"
                )
                self._log_checkin_sent(patient_id, appt.id, message)
            else:
                logger.error(f"Failed to send post-appointment check-in for Patient/{patient_id}")

    # ------------------------------------------------------------------
    # Appointment Retrieval & Filtering
    # ------------------------------------------------------------------
    def _get_appointments_due_for_checkin(self, now):
        """
        Retrieves Appointment resources whose status is 'finished' (or 'completed'),
        and whose 'end' time is about 'followup_delay' hours ago, within a tolerance window.
        
        For example, if followup_delay = 24h, we look for appointments that ended between
        (now - 24h - tolerance) and (now - 24h + tolerance).
        """
        # Calculate the time window in which appointments must have ended
        lower_bound = (now - self.followup_delay - self.followup_tolerance)
        upper_bound = (now - self.followup_delay + self.followup_tolerance)

        # We'll build a date filter that your FHIR server might accept. For instance,
        # some servers allow searching by 'date=lt' or 'end=lt'. Check your FHIR server's
        # documentation. Here we assume 'date' can refer to Appointment.start or end time,
        # or we might try a custom param:
        #
        #   'date=ge{lower_bound.isoformat()},le{upper_bound.isoformat()}'
        # 
        # but many servers differ. We'll keep it simple, then manually filter below.
        appointments = []
        try:
            search = fhir_appointment.Appointment.where({'status': 'finished'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for appt in bundle:
                    if not isinstance(appt, fhir_appointment.Appointment):
                        continue
                    end_time = self._get_appointment_end_time(appt)
                    if end_time and lower_bound <= end_time <= upper_bound:
                        appointments.append(appt)

                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving finished Appointments from FHIR: {e}")

        return appointments

    def _get_appointment_end_time(self, appt):
        """
        Extracts the 'end' time from the Appointment resource. 
        Appointment.end is an ISO8601 string. e.g. '2023-07-05T14:30:00Z'.
        """
        if hasattr(appt, 'end') and appt.end:
            try:
                return datetime.fromisoformat(appt.end.replace('Z', '+00:00'))
            except Exception as e:
                logger.warning(f"Error parsing appointment end time for Appointment/{appt.id}: {e}")
        return None

    # ------------------------------------------------------------------
    # Patient Data Retrieval
    # ------------------------------------------------------------------
    def _extract_patient_id_from_appointment(self, appt):
        """
        Extracts the Patient ID from Appointment.subject.reference (e.g. 'Patient/123').
        """
        if not appt.subject or not appt.subject.reference:
            return None
        parts = appt.subject.reference.split('/')
        return parts[-1] if len(parts) > 1 else None

    def _get_patient_resource(self, patient_id):
        """
        Retrieves a FHIR Patient resource by ID.
        """
        try:
            return fhir_patient.Patient.read(patient_id, self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient/{patient_id}: {e}")
            return None

    def _get_patient_phone_number(self, patient):
        """
        Searches Patient.telecom for a phone number to send SMS messages.
        """
        if patient.telecom:
            for telecom in patient.telecom:
                if telecom.system == 'phone' and telecom.value:
                    return telecom.value
        return None

    def _get_patient_name(self, patient):
        """
        Returns a readable patient name from patient.name.
        """
        if patient.name and len(patient.name) > 0:
            name = patient.name[0]
            given = " ".join(name.given) if name.given else ""
            family = name.family if name.family else ""
            full_name = f"{given} {family}".strip()
            return full_name if full_name else "Patient"
        return "Patient"

    def _get_patient_preferred_language(self, patient):
        """
        Tries to retrieve the patient's preferred language code from patient.communication.
        Returns 'en' if not found.
        """
        if patient.communication and len(patient.communication) > 0:
            comm = patient.communication[0]
            if hasattr(comm, 'language') and comm.language and comm.language.text:
                return comm.language.text.lower()  # e.g. 'en', 'es', etc.
        return 'en'

    # ------------------------------------------------------------------
    # Composing & Translating the Check-In Message
    # ------------------------------------------------------------------
    def _compose_checkin_message(self, appt, patient_name):
        """
        Builds a personalized message for the patient referencing their appointment.
        You can extract appointment date/time, provider name, or other relevant details.
        """
        provider_name = self._get_appointment_provider(appt) or "your provider"
        appt_start_str = self._format_appointment_time(appt)
        message = (
            f"Hello {patient_name},\n\n"
            f"We hope your appointment with {provider_name} on {appt_start_str} went well. "
            "Please reply with any questions you have or type 'OK' if everything is clear. "
            "If you are experiencing any issues (e.g., pain, confusion about instructions), reply 'HELP'."
        )
        return message

    def _get_appointment_provider(self, appt):
        """
        Example method to extract the provider's name (or org name) from the Appointment participants.
        In real usage, you'd look for the participant with role='primary performer' or similar,
        then read their display name or reference (e.g., Practitioner/123).
        """
        if not appt.participant:
            return None
        for participant in appt.participant:
            # Check if participant is a Practitioner or Organization with a display
            if participant.actor and participant.actor.display:
                return participant.actor.display
        return None

    def _format_appointment_time(self, appt):
        """
        Formats the appointment start time as a human-readable string.
        """
        if hasattr(appt, 'start') and appt.start:
            try:
                start_dt = datetime.fromisoformat(appt.start.replace('Z', '+00:00'))
                # Format as, e.g., 'July 5 at 2:30 PM'
                return start_dt.strftime("%B %d at %I:%M %p")
            except Exception as e:
                logger.warning(f"Error parsing appointment start time for Appointment/{appt.id}: {e}")
        return "your recent appointment"

    def _translate_message(self, message, target_language):
        """
        Stub for translating a message into another language.
        Integrate a real translation API (e.g., Google Cloud Translate) in production.
        """
        if target_language.lower() == 'en':
            return message
        # Example: prefix with language code for demonstration
        # In production, call your actual translation service here
        return f"[{target_language.upper()} Translation Placeholder] {message}"

    # ------------------------------------------------------------------
    # Logging & Response Handling
    # ------------------------------------------------------------------
    def _log_checkin_sent(self, patient_id, appointment_id, message):
        """
        Logs that we sent a check-in. In production, consider storing in a database
        for historical tracking.
        """
        logger.info(
            f"Check-in message recorded for Patient/{patient_id} Appointment/{appointment_id}: {message}"
        )

    def process_response(self, patient_id, appointment_id, response_text):
        """
        Example method to handle inbound responses from patients.
        In production, you'd call this from an SMS webhook or a queue.
        Checks for concerning keywords to decide if escalation is necessary.
        """
        self._log_patient_response(patient_id, appointment_id, response_text)
        if self._detect_concerning_keywords(response_text):
            self._escalate_issue(patient_id, appointment_id, response_text)

    def _log_patient_response(self, patient_id, appointment_id, response_text):
        """
        Logs the patient response. Again, store in a database if you want
        persistent records of inbound messages.
        """
        logger.info(
            f"Received response from Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )

    def _detect_concerning_keywords(self, response_text):
        """
        Very simple check for words that indicate patient distress or confusion.
        Expand with your own synonyms or logic as needed.
        """
        keywords = ['confused', 'side effect', 'pain', 'problem', 'worry', 'help']
        lower_text = response_text.lower()
        return any(keyword in lower_text for keyword in keywords)

    def _escalate_issue(self, patient_id, appointment_id, response_text):
        """
        Example of escalating a concerning response. In production, you might:
          - Notify a care coordinator via email or SMS
          - Generate a task in your EHR or ticket system
          - Prompt a telehealth nurse to call the patient
        """
        logger.warning(
            f"Escalation triggered for Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )
        # Implement your actual escalation workflow (alerts, tasks, etc.)

# ---------------------------------------------------------------------------------
# Script Entry Point (Scheduling / Cron / Celery)
# ---------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        checkin_service = PostAppointmentCheckInService(fhir_client, send_sms)
        checkin_service.process_checkins()
    except Exception as e:
        logger.error(f"Critical error in processing post-appointment check-ins: {e}")
print ("32")

================
File: services/post_discharge_service.py
================
# chatbot/views/services/post_discharge_service.py
from celery import shared_task
from django.conf import settings
from twilio.rest import Client
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import logging
from chatbot.views.services.fhir_service import FHIRService  # Adjust import as per your project structure
print ("33")
logger = logging.getLogger('chatbot')
 
@shared_task
async def send_post_discharge_reminders():
    """
    Identifies patients discharged 72 hours ago and sends reminders.
    """
    try:
        fhir_service = FHIRService()
        current_time = datetime.now(ZoneInfo("UTC"))
        reminder_time = current_time - timedelta(hours=72)
        reminder_time_iso = reminder_time.isoformat()
 
        # Search for Encounters that have ended 72 hours ago
        encounters = await fhir_service.search(
            resource_type='Encounter',
            params={
                'status': 'finished',
                'end': f"eq{reminder_time_iso}",
                '_sort': '-end'
            }
        )
 
        if not encounters or 'entry' not in encounters:
            logger.info("No discharged patients found for reminder.")
            return
 
        for entry in encounters['entry']:
            encounter = entry['resource']
            patient_ref = encounter.get('subject', {}).get('reference', '')
            patient_id = patient_ref.split('/')[-1] if '/' in patient_ref else None
 
            if not patient_id:
                logger.warning("Encounter without patient reference.")
                continue
 
            # Retrieve patient details
            patient = await fhir_service.read('Patient', patient_id)
            if not patient:
                logger.warning(f"Patient {patient_id} not found.")
                continue
 
            patient_phone = fhir_service.get_patient_phone(patient)
            if not patient_phone:
                logger.warning(f"No phone number for patient {patient_id}.")
                continue
 
            patient_name = fhir_service.get_patient_name(patient)
 
            # Send SMS reminder
            success = await send_sms_reminder(patient_phone, patient_name)
            if success:
                logger.info(f"Reminder sent to patient {patient_id} for encounter {encounter['id']}.")
            else:
                logger.error(f"Failed to send reminder to patient {patient_id} for encounter {encounter['id']}.")
 
    except Exception as e:
        logger.error(f"Error in send_post_discharge_reminders: {str(e)}", exc_info=True)
        
async def send_sms_reminder(to_number, patient_name):
    """
    Sends an SMS reminder via Twilio.
    """
    try:
        client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        message_body = (
            f"Hello {patient_name},\n\n"
            "We hope you're recovering well after your recent discharge. "
            "Please reply with how you're feeling today, or type 'help' if you have any concerns.\n\n"
            "Your Healthcare Team"
        )
        message = client.messages.create(
            body=message_body,
            from_=settings.TWILIO_PHONE_NUMBER,
            to=to_number
        )
        logger.info(f"Sent SMS to {to_number}: {message.sid}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {str(e)}", exc_info=True)
        return False
print ("34")

================
File: services/preventive_care_reminder_service.py
================
#!/usr/bin/env python
"""
preventive_care_reminder_service.py

A fully implemented example for the Preventive Care Reminder Service in Anna,
using the fhirclient library for querying a FHIR server. This script checks
patients' ages, risk factors (via Condition/Observation), and their latest
screening/Procedure dates to determine if they need various preventive services.
It then sends SMS reminders (via a Twilio-like function).

NOTES:
1. You must install fhirclient (e.g., `pip install fhirclient`) and have a valid
   FHIR endpoint (OAuth or basic auth, as configured in get_fhir_client()).
2. Replace the codes, URLs, and logic to suit your environment. This script
   demonstrates a typical approach but won't work out of the box without
   your actual codes and FHIR server configuration.
3. For real production usage, you may need pagination, concurrency, more refined
   search parameters, and handling of incomplete data or multiple payers.

Preventive Services Covered:
  - Colonoscopy (every 10 years starting at 45)
  - Mammogram (every 18 months starting at 50, or annually if high risk)
  - Diabetes Screening (every 3 years if at risk)
  - Hypertension Check (annually if borderline, every 2 years if normal)
  - Lipid Panel (every 5 years if at risk)
  - Osteoporosis Screening (every 2 years for postmenopausal women)
  - Vision & Hearing Screening (every 2 years)
  - Cervical Cancer Screening (Pap every 3 years from age 21+)
  - Prostate Cancer Screening (not automatically scheduled; discussion-based)
  - Lung Cancer Screening (annual for 5580 with smoking history)
  - Shingles Vaccine (once at age 50+ if not previously immunized)

If a patient had ANY preventive service in the last 18 months, you may skip sending
some reminders. This logic is handled by `_had_recent_preventive_care()`.

Risk Factor Determination is done by:
  - Checking Conditions or Observations for relevant codes (e.g., obesity, hypertension).
  - Checking the last BP Observation to decide if its borderline/elevated.

Robust Error Handling:
  - Each FHIR query is wrapped in try/except blocks to log and handle errors gracefully.
  - If a query fails, we skip that check and continue with other patients.

(c) Example only. Not guaranteed for production.
"""

import logging
from datetime import datetime, timedelta, date

# fhirclient library
from fhirclient import client
import fhirclient.models.patient as fhir_patient
import fhirclient.models.condition as fhir_condition
import fhirclient.models.observation as fhir_observation
import fhirclient.models.procedure as fhir_procedure
import fhirclient.models.immunization as fhir_immunization

# Logging setup
import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.debug("Preventive care reminder service module loaded")
# ----------------------------------------------------------------------
# REPLACE THESE WITH REAL CREDENTIALS / ENDPOINTS / OAUTH CONFIG
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient pointed at your FHIR server.
    This example uses a public test server. Replace with your details.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://server.fire.ly/r4',  # Example test server - change to your endpoint
        # If you have OAuth, you'll need 'authorize_uri', 'redirect_uri', 'client_id', etc.
    }
    return client.FHIRClient(settings=settings)

def send_sms(to_number, message):
    """
    Example of an SMS sending function (Twilio-like).
    Replace with actual integration in production.
    """
    logger.info(f"Sending SMS to {to_number}: {message}")
    # e.g.:
    # twilio_client.messages.create(to=to_number, from_="YourShortCode", body=message)
    return True

# ----------------------------------------------------------------------
# Preventive Care Service Implementation
# ----------------------------------------------------------------------
class PreventiveCareReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service

        # Intervals in days
        self.interval_18_months = 18 * 30  # 540 days
        self.colonoscopy_interval = 10 * 365
        self.mammogram_interval = 18 * 30
        self.mammogram_interval_highrisk = 365  # 1 year if high risk
        self.diabetes_interval = 3 * 365
        self.hypertension_interval_normal = 2 * 365
        self.hypertension_interval_elevated = 365
        self.lipid_interval = 5 * 365
        self.osteoporosis_interval = 2 * 365
        self.vision_hearing_interval = 2 * 365
        self.cervical_interval_pap = 3 * 365
        # For co-testing every 5 years, you could define self.cervical_interval_cotesting
        self.lung_interval = 365
        # Prostate screening is discussion-based
        # Shingles vaccine once after 50

    def process_reminders(self):
        """
        Main entry point: gets due reminders and sends them.
        """
        reminders = self.get_due_reminders()
        for reminder in reminders:
            self.send_reminder(reminder)

    def get_due_reminders(self):
        """
        Retrieves all Patients, checks each for needed services, returns a list of reminders.
        """
        reminders = []
        patients = self._get_all_patients()
        now = datetime.now()

        for patient in patients:
            if not patient.id:
                continue

            # Check opt-out
            if self._patient_has_opted_out(patient):
                continue

            phone_number = self._get_patient_phone_number(patient)
            if not phone_number:
                continue

            birth_date = self._get_birth_date(patient)
            if not birth_date:
                continue

            age = self._calculate_age(birth_date, now)

            # We'll collect potential reminders in a local list, then check if we skip some
            patient_reminders = []

            # Check each preventive service
            # 1. Colonoscopy
            if age >= 45:
                if self._needs_colonoscopy(patient.id, now):
                    patient_reminders.append(("Colonoscopy", now.isoformat()))

            # 2. Mammogram for women age >= 50, or high-risk 40+
            if self._is_female(patient):
                if age >= 50:
                    if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval):
                        patient_reminders.append(("Mammogram", now.isoformat()))
                else:
                    # If <50 but high-risk (BRCA, family history, etc.)
                    if age >= 40 and self._is_high_risk_breast_cancer(patient):
                        if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval_highrisk):
                            patient_reminders.append(("Mammogram (High-Risk)", now.isoformat()))

            # 3. Diabetes screening if at risk, every 3 years
            if self._is_at_risk_for_diabetes(patient):
                if self._needs_diabetes_screening(patient.id, now):
                    patient_reminders.append(("Diabetes Screening", now.isoformat()))

            # 4. Hypertension check
            if age >= 18:
                bp_interval = self.hypertension_interval_elevated if self._has_borderline_bp(patient) else self.hypertension_interval_normal
                if self._needs_blood_pressure_check(patient.id, now, bp_interval):
                    patient_reminders.append(("Hypertension Check", now.isoformat()))

            # 5. Lipid panel if at risk
            if self._is_at_risk_for_cardio(patient):
                if self._needs_lipid_panel(patient.id, now):
                    patient_reminders.append(("Cholesterol/Lipid Panel", now.isoformat()))

            # 6. Osteoporosis screening for postmenopausal women
            if self._is_female(patient) and self._is_postmenopausal(age, patient):
                if self._needs_osteoporosis_screening(patient.id, now):
                    patient_reminders.append(("Osteoporosis Screening", now.isoformat()))

            # 7. Vision & Hearing
            if self._needs_vision_hearing_screening(patient.id, now):
                patient_reminders.append(("Vision and Hearing Screening", now.isoformat()))

            # 8. Cervical screening for women 21+
            if self._is_female(patient) and age >= 21:
                if self._needs_cervical_screening(patient.id, now, age):
                    patient_reminders.append(("Cervical Cancer Screening", now.isoformat()))

            # 9. Lung cancer screening for 5580 with smoking history
            if 55 <= age <= 80 and self._is_eligible_for_lung_screening(patient):
                if self._needs_lung_screening(patient.id, now):
                    patient_reminders.append(("Lung Cancer Screening", now.isoformat()))

            # 10. Shingles vaccine at 50+
            if age >= 50:
                if self._needs_shingles_vaccine(patient.id):
                    patient_reminders.append(("Shingles Vaccine", now.isoformat()))

            # Skip sending if patient had any preventive care in last 18 months
            if patient_reminders and not self._had_recent_preventive_care(patient.id, now, self.interval_18_months):
                for service_name, due_date in patient_reminders:
                    reminders.append({
                        "patient_id": patient.id,
                        "service": service_name,
                        "due_date": due_date,
                        "phone_number": phone_number
                    })

        return reminders

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for a particular service.
        """
        message = (
            f"Hello! You are due for {reminder['service']}. "
            "Please call or visit us online to schedule your appointment."
        )
        try:
            self.notification_service(reminder['phone_number'], message)
            logger.info(f"Sent {reminder['service']} reminder to patient {reminder['patient_id']}")
        except Exception as e:
            logger.error(f"Error sending reminder to patient {reminder['patient_id']}: {e}")

    # -------------------------------------------------------------
    # PATIENT / DEMOGRAPHIC QUERIES
    # -------------------------------------------------------------
    def _get_all_patients(self):
        """
        Retrieves all Patient records from FHIR. Includes basic
        pagination handling for demonstration. Adjust as needed.
        """
        results = []
        search = fhir_patient.Patient.where({})
        try:
            bundle = search.perform_resources(self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient resources: {e}")
            return results  # Return empty list on error

        while bundle:
            for resource in bundle:
                if isinstance(resource, fhir_patient.Patient):
                    results.append(resource)
            # Attempt next page
            next_bundle = None
            try:
                next_bundle = bundle.next_bundle()
            except Exception:
                pass
            bundle = next_bundle

        return results

    def _get_patient_phone_number(self, patient):
        """
        Extracts phone number from the Patient.telecom array.
        """
        if not patient.telecom:
            return None
        for telecom in patient.telecom:
            if telecom.system == 'phone' and telecom.value:
                return telecom.value
        return None

    def _get_birth_date(self, patient):
        """
        Returns birth date as a date object, or None.
        """
        if not patient.birthDate:
            return None
        try:
            return datetime.strptime(patient.birthDate, '%Y-%m-%d').date()
        except ValueError:
            return None

    def _calculate_age(self, birth_date, now):
        """
        Returns integer age in years.
        """
        if not birth_date:
            return 0
        return now.year - birth_date.year - ((now.month, now.day) < (birth_date.month, birth_date.day))

    def _patient_has_opted_out(self, patient):
        """
        Example: checks a custom extension for an opt-out flag.
        Replace with how your system stores opt-out data.
        """
        # Suppose there's an extension with url "http://example.org/fhir/StructureDefinition/optOut"
        if not patient.extension:
            return False
        for ext in patient.extension:
            if ext.url == "http://example.org/fhir/StructureDefinition/optOut":
                if hasattr(ext, 'valueBoolean') and ext.valueBoolean is True:
                    return True
        return False

    def _is_female(self, patient):
        return (patient.gender or "").lower() == "female"

    def _is_postmenopausal(self, age, patient):
        """
        A simplistic assumption: age >= 50 -> postmenopausal.
        Replace with logic for actual Observations or Conditions.
        """
        return age >= 50

    # -------------------------------------------------------------
    # RISK FACTOR CHECKS: Real FHIR Queries for Conditions/Obs
    # -------------------------------------------------------------
    def _is_high_risk_breast_cancer(self, patient):
        """
        Example: checks for Conditions indicating a BRCA mutation or strong family history.
        (Using hypothetical SNOMED/ICD codes.)
        """
        high_risk_codes = [
            "195967001",  # SNOMED for BRCA1 mutation
            "254632001",  # Family history of breast cancer
        ]
        return self._has_any_condition(patient.id, high_risk_codes)

    def _is_at_risk_for_diabetes(self, patient):
        """
        Checks if patient has diabetes or is obese (BMI >30), or has a condition indicating
        prediabetes/family history.
        """
        # Condition codes for diabetes/prediabetes
        diabetes_codes = [
            "44054006",   # Diabetes mellitus type 2
            "15777000",   # Diabetes mellitus type 1
            "42954007",   # Prediabetes
            "73211009",   # Family history of diabetes
        ]
        if self._has_any_condition(patient.id, diabetes_codes):
            return True

        # Check Observations for obesity via last BMI
        bmi = self._get_latest_bmi(patient.id)
        if bmi and bmi >= 30.0:
            return True

        return False

    def _is_at_risk_for_cardio(self, patient):
        """
        Example: checks for existing hyperlipidemia condition or smoking status observation.
        """
        hyperlipidemia_codes = [
            "13644009",  # SNOMED: Hyperlipidemia
        ]
        if self._has_any_condition(patient.id, hyperlipidemia_codes):
            return True

        # Check if patient is a current smoker (Observation of tobacco use = 'current')
        if self._is_current_smoker(patient.id):
            return True

        return False

    def _has_borderline_bp(self, patient):
        """
        Check the last BP reading from Observations.
        Consider borderline if systolic 120129 or diastolic <80, or mild hypertension codes.
        """
        bp = self._get_latest_blood_pressure(patient.id)
        if not bp:
            return False

        systolic = bp.get('systolic')
        diastolic = bp.get('diastolic')

        # Example borderline criteria:
        # Systolic between 120129, diastolic <80 => borderline
        if systolic is not None and diastolic is not None:
            if 120 <= systolic <= 129 and diastolic < 80:
                return True

        # Alternatively, if they have a Condition for borderline hypertension:
        borderline_codes = ["60423000"]  # SNOMED for borderline hypertension
        if self._has_any_condition(patient.id, borderline_codes):
            return True

        return False

    def _is_eligible_for_lung_screening(self, patient):
        """
        Check if patient has a heavy smoking history (Condition or Observation).
        Example code for 'heavy tobacco smoker' or pack-year data.
        """
        # If patient has Condition "266919005" (Heavy tobacco smoker)
        heavy_smoker_codes = ["266919005"]
        if self._has_any_condition(patient.id, heavy_smoker_codes):
            return True
        # Could also parse Observations for pack-year calculations
        return False

    def _has_any_condition(self, patient_id, code_list):
        """
        Returns True if the patient has ANY Condition with a code in `code_list`.
        """
        for code in code_list:
            # We do partial or exact matches. In real usage, you may want a more robust approach
            found = self._search_condition_by_code(patient_id, code)
            if found:
                return True
        return False

    def _is_current_smoker(self, patient_id):
        """
        Checks Observations for a tobacco use code that indicates current smoker.
        Example SNOMED code for 'Current smoker' = 77176002
        LOINC code for Tobacco smoking status = 72166-2 (which might store a coded value).
        """
        # In real usage, you'd parse the valueCodeableConcept for 'current every day smoker', etc.
        return self._search_observation_value_code(patient_id, "72166-2", ["449868002", "77176002"])

    # -------------------------------------------------------------
    # CONDITION / OBSERVATION QUERIES
    # -------------------------------------------------------------
    def _search_condition_by_code(self, patient_id, code):
        """
        Searches Condition for a given SNOMED or ICD code.
        Returns True if found, False otherwise.
        """
        try:
            search = fhir_condition.Condition.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error searching Condition for code {code}, patient {patient_id}: {e}")
        return False

    def _search_observation_value_code(self, patient_id, loinc_code, answer_codes):
        """
        Example: searches Observations with code=loinc_code and a specific coded value
        in Observation.valueCodeableConcept. If any match an 'answer_code' that indicates
        current smoker, returns True.
        """
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': loinc_code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    valcc = getattr(obs, 'valueCodeableConcept', None)
                    if valcc and valcc.coding:
                        for coding in valcc.coding:
                            if coding.code in answer_codes:
                                return True
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Observations for code {loinc_code}, patient {patient_id}: {e}")
        return False

    def _get_latest_bmi(self, patient_id):
        """
        Returns the latest BMI value from Observations (LOINC 39156-5 or 60832-3).
        """
        bmi_codes = ["39156-5", "60832-3"]  # LOINC for Body Mass Index
        latest_date = None
        latest_bmi = None

        for code in bmi_codes:
            try:
                search = fhir_observation.Observation.where({
                    'subject': f'Patient/{patient_id}',
                    'code': code
                })
                bundle = search.perform_resources(self.fhir_client.server)
                while bundle:
                    for obs in bundle:
                        if isinstance(obs, fhir_observation.Observation):
                            obs_date = self._extract_obs_effective_date(obs)
                            value = self._extract_quantity_value(obs)
                            if obs_date and value is not None:
                                if not latest_date or obs_date > latest_date:
                                    latest_date = obs_date
                                    latest_bmi = value
                    bundle = bundle.next_bundle()
            except Exception as e:
                logger.error(f"Error retrieving BMI Observations for patient {patient_id}: {e}")

        return latest_bmi

    def _get_latest_blood_pressure(self, patient_id):
        """
        Returns a dict with 'systolic' and 'diastolic' from the latest BP observation
        (LOINC code 85354-9: Blood pressure panel).
        """
        code = "85354-9"
        bp_data = {}
        latest_date = None
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    obs_date = self._extract_obs_effective_date(obs)
                    if obs_date and (not latest_date or obs_date > latest_date):
                        # Extract components for systolic (8480-6) & diastolic (8462-4)
                        components = getattr(obs, 'component', [])
                        s_val, d_val = None, None
                        for comp in components:
                            coding_list = getattr(comp.code, 'coding', None)
                            if not coding_list:
                                continue
                            for c in coding_list:
                                if c.code == "8480-6":  # Systolic
                                    s_val = self._extract_quantity_value(comp)
                                elif c.code == "8462-4":  # Diastolic
                                    d_val = self._extract_quantity_value(comp)
                        bp_data = {'systolic': s_val, 'diastolic': d_val}
                        latest_date = obs_date
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error retrieving Blood Pressure for patient {patient_id}: {e}")
        return bp_data

    # -------------------------------------------------------------
    # NEEDS-* CHECKS: LOOK FOR LAST SERVICE DATE OR IMMUNIZATION
    # -------------------------------------------------------------
    def _needs_colonoscopy(self, patient_id, now):
        last_date = self._get_last_procedure_date(patient_id, ["73761001"])  # SNOMED for colonoscopy
        if not last_date:
            return True
        return (now.date() - last_date).days > self.colonoscopy_interval

    def _needs_mammogram(self, patient_id, now, interval):
        codes = ["72313002"]  # SNOMED for screening mammogram
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_diabetes_screening(self, patient_id, now):
        # E.g. LOINC for A1c or Glucose Tolerance
        codes = ["4548-4", "6298-4"]  # Some LOINC placeholders
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.diabetes_interval

    def _needs_blood_pressure_check(self, patient_id, now, interval):
        # If no BP reading coded as a Procedure, or if it's older than interval
        # Some places record BP as Observations only, but let's assume you might have a
        # "vitals check" procedure code. We'll just re-use the "85354-9" LOINC for demonstration.
        last_date = self._get_last_procedure_date(patient_id, ["85354-9"])
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_lipid_panel(self, patient_id, now):
        # LOINC for Lipid panel = "24331-1", etc.
        codes = ["24331-1"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lipid_interval

    def _needs_osteoporosis_screening(self, patient_id, now):
        # SNOMED for DXA = "398181004"
        codes = ["398181004"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.osteoporosis_interval

    def _needs_vision_hearing_screening(self, patient_id, now):
        # SNOMED example code = "424732000"
        codes = ["424732000"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.vision_hearing_interval

    def _needs_cervical_screening(self, patient_id, now, age):
        # Pap test code example: "19762-4" (LOINC) or "Pap" as SNOMED
        # We'll just pick one LOINC for demonstration
        codes = ["19762-4"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.cervical_interval_pap

    def _needs_lung_screening(self, patient_id, now):
        # SNOMED: "168537006" for low-dose CT
        codes = ["168537006"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lung_interval

    def _needs_shingles_vaccine(self, patient_id):
        # Check if we have an Immunization with relevant code
        # Example: SNOMED for zoster vaccination is "212527006"
        immun_code = ["212527006"]
        last_date = self._get_last_immunization_date(patient_id, immun_code)
        return (last_date is None)

    def _had_recent_preventive_care(self, patient_id, now, interval_days):
        """
        Returns True if the patient had ANY preventive procedure in the last `interval_days`.
        We'll define a broad list of codes for all the services we consider "preventive."
        """
        codes = [
            "73761001",   # Colonoscopy
            "72313002",   # Mammogram
            "4548-4", "6298-4",  # Diabetes screening
            "85354-9",    # BP check
            "24331-1",    # Lipid panel
            "398181004",  # DXA
            "424732000",  # Vision/hearing
            "19762-4",    # Pap
            "168537006",  # Lung screening
        ]
        cutoff = now.date() - timedelta(days=interval_days)

        for code in codes:
            recent = self._has_procedure_after(patient_id, code, cutoff)
            if recent:
                return True

        return False

    # -------------------------------------------------------------
    # FHIR Procedure & Immunization queries
    # -------------------------------------------------------------
    def _get_last_procedure_date(self, patient_id, codes):
        """
        Searches Procedure for any of the given codes, returns the latest date.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_procedure_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_procedure_latest(self, patient_id, code):
        """
        Returns the most recent procedure date for `code`.
        """
        latest_date = None
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for proc in bundle:
                    if not isinstance(proc, fhir_procedure.Procedure):
                        continue
                    dt = self._extract_procedure_date(proc)
                    if dt and (not latest_date or dt > latest_date):
                        latest_date = dt
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Procedure for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _extract_procedure_date(self, procedure):
        """
        Extracts a date from procedure.performedDateTime or procedure.performedPeriod.
        Returns a date object or None.
        """
        pdt = getattr(procedure, 'performedDateTime', None)
        pperiod = getattr(procedure, 'performedPeriod', None)

        # performedDateTime is typically an ISO8601 string
        if pdt:
            return self._parse_date_str(pdt)
        if pperiod:
            if pperiod.end:
                return self._parse_date_str(pperiod.end)
            if pperiod.start:
                return self._parse_date_str(pperiod.start)
        return None

    def _get_last_immunization_date(self, patient_id, codes):
        """
        Returns the most recent immunization date for any code in `codes`.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_immunization_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_immunization_latest(self, patient_id, code):
        """
        Returns the most recent Immunization date for a code.
        """
        latest_date = None
        try:
            search = fhir_immunization.Immunization.where({
                'patient': f'Patient/{patient_id}',
                'vaccine-code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for imm in bundle:
                    if not isinstance(imm, fhir_immunization.Immunization):
                        continue
                    dt = getattr(imm, 'occurrenceDateTime', None)
                    if dt:
                        d = self._parse_date_str(dt)
                        if d and (not latest_date or d > latest_date):
                            latest_date = d
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Immunization for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _has_procedure_after(self, patient_id, code, cutoff_date):
        """
        Returns True if there's a Procedure with `code` after `cutoff_date`.
        """
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code,
                'date': f'ge{cutoff_date.isoformat()}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error checking recent Procedure for code {code}, patient {patient_id}: {e}")
        return False

    # -------------------------------------------------------------
    # OBSERVATION UTILS
    # -------------------------------------------------------------
    def _extract_obs_effective_date(self, obs):
        """
        Extracts the date from Observation.effectiveDateTime or Observation.effectivePeriod.
        """
        edt = getattr(obs, 'effectiveDateTime', None)
        epd = getattr(obs, 'effectivePeriod', None)
        if edt:
            return self._parse_date_str(edt)
        if epd:
            if epd.end:
                return self._parse_date_str(epd.end)
            if epd.start:
                return self._parse_date_str(epd.start)
        return None

    def _extract_quantity_value(self, obj):
        """
        If the Observation or component has a valueQuantity, return the .value as a float.
        """
        valQ = getattr(obj, 'valueQuantity', None)
        if valQ and valQ.value is not None:
            return float(valQ.value)
        return None

    # -------------------------------------------------------------
    # DATE PARSING
    # -------------------------------------------------------------
    def _parse_date_str(self, date_str):
        """
        Attempts to parse a date/time string to a datetime.date.
        """
        if not date_str:
            return None
        try:
            dt = datetime.fromisoformat(date_str)
            return dt.date()
        except ValueError:
            # Possibly just YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d").date()
            except ValueError:
                logger.warning(f"Unable to parse date string: {date_str}")
                return None


# ----------------------------------------------------------------------
# SCRIPT ENTRY POINT
# ----------------------------------------------------------------------
if __name__ == "__main__":
    # Configure logging to console
    logging.basicConfig(level=logging.INFO)

    # Initialize FHIR client and the reminder service
    fhir = get_fhir_client()
    reminder_service = PreventiveCareReminderService(fhir, send_sms)

    # Option 1: Generate a list of due reminders
    # reminders = reminder_service.get_due_reminders()
    # for r in reminders:
    #     print(r)

    # Option 2: Directly process (send) all reminders
    reminder_service.process_reminders()
logger.debug("Preventive care reminder service initialization complete")

================
File: services/scheduler.py
================
from datetime import datetime, time, timedelta, timezone
from zoneinfo import ZoneInfo
from chatbot.views.utils.shared import get_resource_name 
import dateparser
from django.conf import settings
from ..config import config as app_config
import logging
import openai
from celery import shared_task
from celery.schedules import crontab
from .medication_service import MedicationAdherenceReminderService
from ..utils.datetime_utils import get_current_time
openai.api_key = settings.OPENAI_API_KEY

fhir_client = app_config.get_fhir_client()
# Configure logging
logger = logging.getLogger('chatbot')

# Initialize FHIR Client


# Initialize OpenAI client
client = settings.OPENAI_API_KEY

print ("36")

class ScheduleManager:
    def __init__(self, fhir_client, logger=None):
        self.fhir_client = fhir_client
        self.logger = logger or logging.getLogger(__name__)

    def create_unlimited_schedule(self, practitioner_id):
        """Creates a schedule with an extended planning horizon"""
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": "2024-01-01T00:00:00Z",
                "end": "2050-12-31T23:59:59Z"
            }
        }
        return self.fhir_client.create("Schedule", schedule)

    def update_all_schedules(self):
        """Updates all existing schedules with unlimited planning horizon"""
        results = {"success": 0, "failed": 0}
        schedules = self.fhir_client.search("Schedule", {})
        
        if not schedules or 'entry' not in schedules:
            self.logger.warning("No schedules found to update")
            return results

        for entry in schedules.get('entry', []):
            schedule = entry.get('resource', {})
            schedule_id = schedule.get('id')
            try:
                schedule['planningHorizon'] = {
                    "start": "2024-01-01T00:00:00Z",
                    "end": "2050-12-31T23:59:59Z"
                }
                if self.fhir_client.update("Schedule", schedule_id, schedule):
                    results["success"] += 1
                else:
                    results["failed"] += 1
            except Exception as e:
                results["failed"] += 1
                self.logger.error(f"Error updating schedule {schedule_id}: {str(e)}")

        return results

    def create_slots(self, schedule_id, start_date="2024-01-01", end_date="2050-12-31"):
        """Creates slots for a given schedule between start and end dates"""
        try:
            start = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            end = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            current = start
            
            while current < end:
                if 9 <= current.hour < 17:  # Business hours
                    slot = {
                        "resourceType": "Slot",
                        "schedule": {"reference": f"Schedule/{schedule_id}"},
                        "status": "free",
                        "start": current.isoformat() + 'Z',
                        "end": (current + timedelta(minutes=30)).isoformat() + 'Z'
                    }
                    self.fhir_client.create("Slot", slot)
                
                current += timedelta(minutes=30)
                
            return {"status": "success", "message": "Slots created successfully"}
        except Exception as e:
            self.logger.error(f"Error creating slots: {str(e)}")
            return {"status": "error", "message": str(e)}

# Initialize Schedule Manager
def search_available_slots(practitioner_id, datetime_requested):
    """Search for available slots for a practitioner at a specific time"""
    try:
        logger.info(f"Searching for slots for practitioner {practitioner_id} at {datetime_requested}")
        
        fhir_client = app_config.get_fhir_client()
        if not fhir_client:
            logger.error("FHIR client is None")
            return []
            
        # First, get or create the schedule
        schedule_search = fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_search or 'entry' not in schedule_search or not schedule_search['entry']:
            logger.info(f"No schedule found for practitioner {practitioner_id}, creating new schedule")
            schedule = create_practitioner_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return []
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_search['entry'][0]['resource']['id']
        
        # Ensure slots exist for the requested date
        create_slots_if_needed(schedule_id, datetime_requested)
        
        # Search for specific slot
        start_time = datetime_requested
        start_range = start_time - timedelta(minutes=30)
        end_range = start_time + timedelta(minutes=30)
        
        slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_range.isoformat()}&le{end_range.isoformat()}",
            "status": "free"
        })
        
        if not slots or 'entry' not in slots:
            logger.info(f"No slots found for time {start_time}")
            return []
            
        return slots['entry']

    except Exception as e:
        logger.error(f"Error searching for slots: {str(e)}", exc_info=True)
        return []

def create_slots_if_needed(schedule_id, target_datetime):
    """Create slots for a specific date if they don't exist"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        # Convert to start of day
        start_of_day = target_datetime.replace(hour=9, minute=0, second=0, microsecond=0)
        end_of_day = target_datetime.replace(hour=17, minute=0, second=0, microsecond=0)
        
        # Check if slots already exist
        existing_slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}&le{end_of_day.isoformat()}"
        })
        
        if not existing_slots or 'entry' not in existing_slots or not existing_slots['entry']:
            logger.info(f"Creating slots for {start_of_day.date()}")
            current_time = start_of_day
            
            while current_time < end_of_day:
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current_time.isoformat(),
                    "end": (current_time + timedelta(minutes=30)).isoformat()
                }
                
                try:
                    fhir_client.create("Slot", slot)
                    logger.debug(f"Created slot for {current_time.isoformat()}")
                except Exception as e:
                    logger.error(f"Failed to create slot for {current_time.isoformat()}: {str(e)}")
                
                current_time += timedelta(minutes=30)
            
            return True
        
        return True
        
    except Exception as e:
        logger.error(f"Error creating slots: {str(e)}", exc_info=True)
        return False
    

schedule_manager = ScheduleManager(fhir_client, logger)
def get_appointment_schedule(practitioner_id):
    """Retrieve the appointment schedule for a practitioner."""
    return fhir_client.search("Schedule", {"actor": f"Practitioner/{practitioner_id}"})


def create_practitioner_schedule(practitioner_id):
    """Creates a new schedule for a practitioner"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "serviceType": [{"text": "Primary Care Physician"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": datetime.now(ZoneInfo("UTC")).isoformat(),
                "end": (datetime.now(ZoneInfo("UTC")) + timedelta(days=90)).isoformat()
            }
        }
        
        return fhir_client.create("Schedule", schedule)
        
    except Exception as e:
        logger.error(f"Error creating schedule: {str(e)}", exc_info=True)
        return None

def create_slots_for_date(schedule_id, date):
    """
    Creates slots for a specific date only.
    """
    try:
        # Convert to clinic timezone if not already
        clinic_tz = ZoneInfo("America/New_York")
        if isinstance(date, str):
            date = datetime.fromisoformat(date.replace('Z', '+00:00'))
        date = date.astimezone(clinic_tz)
        
        # Start and end times in clinic timezone
        current = datetime.combine(date.date(), time(9, 0), tzinfo=clinic_tz)
        end_time = datetime.combine(date.date(), time(17, 0), tzinfo=clinic_tz)
        
        created_slots = []
        while current < end_time:
            if current.weekday() < 5:  # Weekdays only
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current.isoformat(),
                    "end": (current + timedelta(minutes=30)).isoformat()
                }
                created = fhir_client.create("Slot", slot)
                if created:
                    created_slots.append(created)
            current += timedelta(minutes=30)
            
        logger.info(f"Created {len(created_slots)} slots for date {date.date()}")
        return True
    except Exception as e:
        logger.error(f"Error creating slots: {e}", exc_info=True)
        return False
    
def ensure_extended_schedule(practitioner_id, requested_date):
    """
    Ensures schedule exists and has slots for the requested date.
    Creates schedule and slots if needed.
    """
    try:
        schedule_manager = ScheduleManager(app_config.get_fhir_client(), logger)
        
        # Search for existing schedule
        schedule_results = schedule_manager.fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_results or 'entry' not in schedule_results:
            # Create new schedule
            schedule = schedule_manager.create_unlimited_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return False
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_results['entry'][0]['resource']['id']
        
        # Create slots for the date if they don't exist
        start_of_day = requested_date.replace(hour=9, minute=0, second=0, microsecond=0)
        slots = schedule_manager.fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}"
        })
        
        if not slots or 'entry' not in slots:
            return create_slots_for_date(schedule_id, requested_date)
            
        return True
        
    except Exception as e:
        logger.error(f"Error ensuring schedule: {str(e)}", exc_info=True)
        return False
def find_next_available_slots(practitioner_id, from_datetime, limit=5):
    """
    Finds the next available slots, checking for existing appointments.
    """
    try:
        logger.debug(f"Finding next available slots for practitioner {practitioner_id} from {from_datetime}")
        
        # Convert input datetime
        from_dt = datetime.fromisoformat(from_datetime.replace('Z', '+00:00'))
        end_dt = from_dt + timedelta(days=30)  # Look ahead 30 days
        
        # Get all existing appointments within the date range
        appointment_params = {
            'practitioner': f"Practitioner/{practitioner_id}",
            'date': f"ge{from_dt.isoformat()}&le{end_dt.isoformat()}",
            'status': 'booked,pending'
        }
        existing_appointments = fhir_client.search('Appointment', appointment_params)
        booked_times = set()
        
        if existing_appointments and 'entry' in existing_appointments:
            for appt in existing_appointments['entry']:
                start_time = appt['resource'].get('start')
                if start_time:
                    booked_times.add(start_time)
        
        available_slots = []
        current = from_dt
        
        while current <= end_dt and len(available_slots) < limit:
            # Skip weekends
            if current.weekday() >= 5:
                current += timedelta(days=1)
                continue
                
            # Check each time slot during business hours
            day_start = current.replace(hour=9, minute=0, second=0, microsecond=0)
            day_end = current.replace(hour=17, minute=0, second=0, microsecond=0)
            
            slot_time = day_start
            while slot_time < day_end:
                # Skip if slot is already booked
                if slot_time.isoformat() not in booked_times:
                    available_slots.append(slot_time.strftime("%A, %B %d, %Y at %I:%M %p"))
                    if len(available_slots) >= limit:
                        break
                slot_time += timedelta(minutes=30)
                
            current += timedelta(days=1)
        
        return available_slots
        
    except Exception as e:
        logger.error(f"Error in find_next_available_slots: {str(e)}")
        return []
    
def get_patient_appointments(patient_id):
    """Get all upcoming appointments for a patient"""
    try:
        fhir_client = app_config.get_fhir_client()
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        
        response = fhir_client.search("Appointment", {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "_sort": "date",
            "_count": 10
        })
        
        if not response or 'entry' not in response:
            return []
            
        return response['entry']
        
    except Exception as e:
        logger.error(f"Error getting patient appointments: {str(e)}", exc_info=True)
        return []
    
@shared_task
def process_medication_reminders():
    """Process all due medication reminders."""
    reminder_service = MedicationAdherenceReminderService()
    current_time = get_current_time()
    
    try:
        due_reminders = reminder_service.get_due_reminders(current_time)
        
        for reminder in due_reminders:
            try:
                send_reminder(reminder)
            except Exception as e:
                logger.error(f"Failed to send reminder for patient {reminder['patient_id']}: {str(e)}")
                
    except Exception as e:
        logger.error(f"Failed to process medication reminders: {str(e)}")
        raise

async def send_reminder(reminder):
    """Send individual reminder message."""
    from ..handlers.chat_handler import ChatHandler
    
    chat_handler = ChatHandler(session_data={}, user_message="", user_id=None)
    message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
    
    await chat_handler.send_message(
        to_number=reminder["phone_number"], 
        message=message
    )

# Add to your CELERYBEAT_SCHEDULE in settings or scheduler config
CELERYBEAT_SCHEDULE = {
    # ... your existing scheduled tasks ...
    'morning-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=9, minute=0)
    },
    'afternoon-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=14, minute=0)
    },
    'evening-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=20, minute=0)
    }
}
print ("37")

================
File: services/screening_guideline_service.py
================
"""
screening_guideline_service.py

Service for determining if a patient should undergo specific screening procedures
based on their age, risk factors, and medical history.
"""

import logging
from datetime import datetime
from typing import Dict, Tuple, Optional, Any, List

logger = logging.getLogger(__name__)

class ScreeningGuidelineService:
    """
    Service that implements evidence-based screening guidelines.
    Determines if a patient should undergo specific screening procedures
    based on their age, risk factors, and medical history.
    """
    
    # Age-based screening guidelines (based on USPSTF recommendations)
    COLONOSCOPY_MIN_AGE = 45
    MAMMOGRAM_MIN_AGE = 40
    PSA_MIN_AGE = 55
    
    def __init__(self):
        # Initialize any needed resources
        pass
        
    def should_get_screening(self, 
                            screening_type: str, 
                            patient_data: Optional[Dict[str, Any]] = None) -> Tuple[bool, str]:
        """
        Determine if a patient should get a specific screening based on guidelines
        
        Args:
            screening_type: Type of screening (colonoscopy, mammogram, etc.)
            patient_data: Patient FHIR data dictionary
            
        Returns:
            Tuple of (recommendation boolean, explanation string)
        """
        screening_type = screening_type.lower()
        
        if not patient_data:
            return False, "Unable to provide a personalized recommendation without patient information."
        
        # Calculate patient age
        patient_age = self._calculate_age(patient_data)
        if patient_age is None:
            return False, "Unable to determine your age from record. Please consult your healthcare provider."
        
        # Check for specific screening types
        if "colonoscopy" in screening_type:
            return self._evaluate_colonoscopy_need(patient_age, patient_data)
        elif "mammogram" in screening_type:
            return self._evaluate_mammogram_need(patient_age, patient_data)
        elif any(term in screening_type for term in ["psa", "prostate"]):
            return self._evaluate_prostate_screening_need(patient_age, patient_data)
        else:
            return False, f"Specific guidelines for {screening_type} screening are not available. Please consult your healthcare provider."
    
    def _calculate_age(self, patient_data: Dict[str, Any]) -> Optional[int]:
        """Calculate patient age from birth date in FHIR data"""
        try:
            if "birthDate" in patient_data:
                birth_date = datetime.fromisoformat(patient_data["birthDate"].replace('Z', '+00:00'))
                today = datetime.now()
                age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                return age
            return None
        except (ValueError, TypeError):
            logger.error("Unable to parse birthDate from patient data")
            return None
    
    def _has_risk_factors(self, patient_data: Dict[str, Any], condition_list: List[str]) -> bool:
        """Check if patient has specific risk factors based on conditions"""
        try:
            # Check if there are conditions in the patient data
            if "conditions" in patient_data and isinstance(patient_data["conditions"], list):
                conditions = patient_data["conditions"]
                for condition in conditions:
                    if "code" in condition and "text" in condition["code"]:
                        condition_text = condition["code"]["text"].lower()
                        if any(risk.lower() in condition_text for risk in condition_list):
                            return True
            return False
        except Exception as e:
            logger.error(f"Error checking risk factors: {str(e)}")
            return False
    
    def _evaluate_colonoscopy_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs a colonoscopy based on age and risk factors"""
        # List of risk factors that might necessitate earlier or more frequent screening
        colon_risk_factors = [
            "colorectal cancer", "colon cancer", "rectal cancer", "polyp", 
            "inflammatory bowel disease", "crohn", "ulcerative colitis",
            "lynch syndrome", "familial adenomatous polyposis"
        ]
        
        # Check for family history
        has_family_history = False
        if "family_history" in patient_data and isinstance(patient_data["family_history"], list):
            for history in patient_data["family_history"]:
                if any(risk in str(history).lower() for risk in colon_risk_factors):
                    has_family_history = True
                    break
        
        # Check for personal risk factors
        has_risk_factors = self._has_risk_factors(patient_data, colon_risk_factors)
        
        # Make recommendation based on guidelines
        if age >= self.COLONOSCOPY_MIN_AGE:
            return True, f"Based on your age ({age}), the US Preventive Services Task Force recommends colorectal cancer screening starting at age {self.COLONOSCOPY_MIN_AGE}."
        elif has_risk_factors or has_family_history:
            return True, "Based on your medical or family history, you may need earlier colorectal cancer screening. Please consult with your healthcare provider."
        else:
            return False, f"Current guidelines don't recommend routine colonoscopy screening before age {self.COLONOSCOPY_MIN_AGE} unless you have specific risk factors."

    def _evaluate_mammogram_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs a mammogram based on age and risk factors"""
        # Implementation similar to colonoscopy evaluation
        gender = patient_data.get("gender", "").lower()
        
        if gender == "male":
            return False, "Routine mammogram screening is not typically recommended for men, but please consult your provider if you have specific concerns."
        
        # Check age and risk factors
        if age >= self.MAMMOGRAM_MIN_AGE:
            return True, f"Based on your age ({age}), mammogram screening is recommended starting at age {self.MAMMOGRAM_MIN_AGE}."
        else:
            return False, f"Current guidelines don't recommend routine mammogram screening before age {self.MAMMOGRAM_MIN_AGE} unless you have specific risk factors."
    
    def _evaluate_prostate_screening_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs prostate screening"""
        gender = patient_data.get("gender", "").lower()
        
        if gender != "male":
            return False, "Prostate cancer screening is only applicable to men."
            
        if age >= self.PSA_MIN_AGE:
            return True, f"For men aged {self.PSA_MIN_AGE} and older, discussing prostate cancer screening with your doctor is recommended to make an informed decision."
        else:
            return False, f"Current guidelines don't routinely recommend prostate cancer screening for men under age {self.PSA_MIN_AGE} unless you have specific risk factors."

# Singleton instance
screening_guideline_service = ScreeningGuidelineService()

================
File: services/session.py
================
import logging
import json
from datetime import datetime, timezone, timedelta
import asyncio
import time
from redis import asyncio as aioredis
from contextlib import asynccontextmanager
from django.conf import settings
from .fhir_service import FHIRService
from typing import Optional, Dict, Any, List

logger = logging.getLogger(__name__)

class SessionManager:
    # In-memory session fallback storage with timestamps
    _memory_sessions: Dict[str, Dict] = {}
    
    def __init__(self):
        self._redis_client = None
        self._lock = None  # Initialize in async context
        self.session_timeout = timedelta(seconds=settings.SESSION_TTL_SECONDS)
        self.fhir_service = FHIRService()  # Using existing FHIRService
        self.redis_url = getattr(settings, 'REDIS_URL', 'redis://localhost:6379/0')

    def _get_session_key(self, session_id: str) -> str:
        """Get consistent session key format"""
        return f"chat_session:{session_id}"
        
    def cleanup_expired_memory_sessions(self):
        """
        Remove in-memory sessions that have expired according to TTL
        This prevents memory leaks from abandoned sessions
        """
        now = time.time()
        expired_keys = []
        
        for session_id, session_data in SessionManager._memory_sessions.items():
            # Extract timestamp from session data
            last_interaction = session_data.get('last_interaction')
            if not last_interaction:
                # No timestamp, consider expired
                expired_keys.append(session_id)
                continue
                
            try:
                # Convert ISO timestamp to Unix time
                if isinstance(last_interaction, str):
                    last_time = datetime.fromisoformat(last_interaction.replace('Z', '+00:00'))
                    last_unix_time = last_time.timestamp()
                    
                    # Check if expired based on TTL
                    if now - last_unix_time > settings.SESSION_TTL_SECONDS:
                        expired_keys.append(session_id)
            except (ValueError, TypeError):
                # Invalid timestamp format, consider expired
                expired_keys.append(session_id)
        
        # Remove expired sessions
        for key in expired_keys:
            SessionManager._memory_sessions.pop(key, None)
            
        if expired_keys:
            logger.info(f"Cleaned up {len(expired_keys)} expired memory sessions")

    async def initialize(self):
        """Initialize session manager for ASGI application"""
        self._lock = asyncio.Lock()
        await self._initialize_redis()

    async def _initialize_redis(self):
        """Initialize Redis connection"""
        try:
            if self._redis_client is None:
                self._redis_client = await aioredis.from_url(
                    self.redis_url,
                    encoding='utf-8',
                    decode_responses=True
                )
        except Exception as e:
            logger.error(f"Redis initialization failed: {e}")
            self._redis_client = None

    async def cleanup(self):
        """Cleanup session manager resources"""
        if self._redis_client:
            await self._redis_client.close()
            self._redis_client = None

    @asynccontextmanager
    async def get_redis(self):
        """Get Redis connection with proper error handling"""
        if self._redis_client is None:
            try:
                if self._lock is None:
                    self._lock = asyncio.Lock()
                    
                async with self._lock:
                    if self._redis_client is None:
                        await self._initialize_redis()
            except Exception as e:
                logger.error(f"Redis connection failed: {e}")
                self._redis_client = None
        
        if self._redis_client is not None:
            try:
                yield self._redis_client
            except Exception as e:
                logger.error(f"Redis operation failed: {e}")
                self._redis_client = None
                raise  # Re-raise to ensure proper error handling
        else:
            logger.warning("Redis connection not available, using in-memory storage")
            yield None

    async def get_session(self, session_id: str) -> Dict[str, Any]:
        """Get existing session or create new one"""
        try:
            # Clean up expired memory sessions first
            self.cleanup_expired_memory_sessions()
            
            # Check in-memory sessions
            if session_id in SessionManager._memory_sessions:
                logger.info(f"Using in-memory session for {session_id}")
                return SessionManager._memory_sessions[session_id]
        
            async with self.get_redis() as redis:
                if redis is None:
                    logger.warning("Redis connection not available, using in-memory fallback")
                    # Check again for memory sessions
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    # No session found, create default
                    new_session = await self._create_or_verify_session(session_id)
                    SessionManager._memory_sessions[session_id] = new_session
                    return new_session
                
                session_key = self._get_session_key(session_id)
                try:
                    session_data = await redis.get(session_key)
                    if session_data:
                        parsed_session = json.loads(session_data)
                        # Store in memory for faster access
                        SessionManager._memory_sessions[session_id] = parsed_session
                        return parsed_session
                except Exception as e:
                    logger.error(f"Error reading session: {e}")
                    # Check memory fallback
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    raise
                
                # Create new session
                new_session = await self._create_or_verify_session(session_id)
                try:
                    await redis.set(
                        session_key,
                        json.dumps(new_session),
                        ex=settings.SESSION_TTL_SECONDS
                    )
                    # Store in memory too
                    SessionManager._memory_sessions[session_id] = new_session
                except Exception as e:
                    logger.error(f"Error saving new session: {e}")
                    # Still store in memory
                    SessionManager._memory_sessions[session_id] = new_session
                return new_session
                
        except Exception as e:
            logger.error(f"Session operation failed: {e}")
            raise
    
    async def update_session(self, session_id: str, session_data: Dict[str, Any]) -> None:
        """Update existing session"""
        try:
            # Update last interaction time
            session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
            
            async with self.get_redis() as redis:
                if redis is None:
                    # Redis not available, use in-memory storage
                    logger.warning("Redis connection not available, using in-memory storage")
                    # Store in memory
                    SessionManager._memory_sessions[session_id] = session_data
                    return
                
                # Store updated session using consistent key format
                session_key = self._get_session_key(session_id)
                await redis.set(
                    session_key,
                    json.dumps(session_data),
                    ex=settings.SESSION_TTL_SECONDS
                )
                # Update memory cache
                SessionManager._memory_sessions[session_id] = session_data
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            # Fall back to in-memory storage
            SessionManager._memory_sessions[session_id] = session_data

    async def reset_session(self, session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
        """Reset session while optionally preserving patient data"""
        try:
            current_session = await self.get_session(session_id)
            patient_data = current_session.get('patient') if preserve_patient else None
            
            new_session = self._create_default_session(session_id)
            if patient_data:
                new_session['patient'] = patient_data
            
            await self.save_session(session_id, new_session)
            return new_session
            
        except Exception as e:
            logger.error(f"Error resetting session: {e}")
            return self._create_default_session(session_id)

    async def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """Save complete session data"""
        try:
            # Update last interaction time
            session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
            
            # Update memory cache
            SessionManager._memory_sessions[session_id] = session_data
            
            async with self.get_redis() as redis:
                if redis is None:
                    return False
                
                await redis.set(
                    self._get_session_key(session_id),
                    json.dumps(session_data),
                    ex=settings.SESSION_TTL_SECONDS
                )
                return True
                
        except aioredis.RedisError as e:
            logger.error(f"Redis error saving session: {e}")
            return False
        except Exception as e:
            logger.error(f"Error saving session: {e}")
            return False

    async def _create_or_verify_session(self, session_id: str) -> Dict[str, Any]:
        """Creates a new session and verifies patient data if email provided"""
        session = self._create_default_session(session_id)
        
        # Verify patient if session_id looks like an email
        if '@' in session_id:
            try:
                patient_data = await self.fhir_service.get_patient_by_email(session_id)
                if patient_data:
                    logger.info(f"Found patient data for {session_id}")
                    session['patient'] = patient_data
            except Exception as e:
                logger.error(f"Error verifying patient: {e}")
        
        return session

    def _create_default_session(self, session_id: str) -> Dict[str, Any]:
        """Create a default session with all required fields"""
        return {
            'id': session_id,
            'greeted': False,
            'booking_state': None,
            'cancellation_options': None,
            'requested_datetime': None,
            'last_interaction': datetime.now(timezone.utc).isoformat(),
            'verified': False,
            'patient': None
        }

    async def _verify_patient(self, session_id):
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                return patient_data
            return None
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return None

    async def verify_patient(self, session_id: str) -> bool:
        """Verify patient exists in FHIR"""
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                self.session['patient'] = patient_data
                self.session['verified'] = True
                return True
            return False
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return False

# Global instance
session_manager = SessionManager()

# For backwards compatibility with existing imports
async def get_session(session_id: str) -> Dict[str, Any]:
    return await session_manager.get_session(session_id)

async def update_session(session_id: str, updates: Dict[str, Any]) -> bool:
    # Added basic validation to avoid sending None as updates
    if not session_id or not updates:
        logger.error("Invalid parameters for update_session: session_id or updates missing")
        return False
        
    # Create a new dict to avoid modifying the original
    safe_updates = {}
    for k, v in updates.items():
        if k and v is not None:  # Only include non-None values
            safe_updates[k] = v
    
    return await session_manager.update_session(session_id, safe_updates)

async def reset_session(session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
    return await session_manager.reset_session(session_id, preserve_patient)

async def save_session(session_id: str, session_data: Dict[str, Any]) -> bool:
    return await session_manager.save_session(session_id, session_data)

================
File: services/symptom_guidance_service.py
================
# chatbot/views/services/symptom_guidance_service.py

import logging
from django.conf import settings
import json
from ..utils.formatters import format_message
from .fhir_service import FHIRService
import openai
from datetime import datetime
from asgiref.sync import sync_to_async
from openai import AsyncOpenAI
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
class SymptomGuidanceService:
    def __init__(self):
        self.fhir_service = FHIRService()
        self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        
        # Define red flag symptoms
        self.RED_FLAGS = {
            'chest_pain': [
                'chest pain', 'chest tightness', 'crushing pain',
                'heart attack', 'cardiac', 'heart pain'
            ],
            'breathing': [
                'cannot breathe', 'difficulty breathing', 'shortness of breath',
                'struggling to breathe', 'gasping', 'choking'
            ],
            'stroke': [
                'face drooping', 'arm weakness', 'speech difficulty',
                'numbness one side', 'sudden confusion', 'sudden dizziness'
            ],
            'consciousness': [
                'unconscious', 'passed out', 'fainting',
                'not responding', 'lost consciousness'
            ],
            'bleeding': [
                'severe bleeding', 'heavy bleeding', 'uncontrolled bleeding',
                'bleeding heavily', 'blood loss'
            ],
            'allergic': [
                'anaphylaxis', 'allergic reaction', 'throat swelling',
                'cannot swallow', 'severe allergy'
            ]
        }
        
        # Risk levels with their descriptions
        self.RISK_LEVELS = {
            'EMERGENCY': {
                'level': 4,
                'action': 'CALL EMERGENCY SERVICES IMMEDIATELY (112 or 999)',
                'urgency': 'Immediate emergency attention required'
            },
            'HIGH': {
                'level': 3,
                'action': 'Seek immediate medical attention or go to the nearest urgent care center',
                'urgency': 'Urgent medical attention recommended'
            },
            'MEDIUM': {
                'level': 2,
                'action': 'Consider visiting urgent care or booking an urgent appointment',
                'urgency': 'Prompt medical attention advised'
            },
            'LOW': {
                'level': 1,
                'action': 'Schedule a routine appointment with your healthcare provider',
                'urgency': 'Non-urgent medical attention'
            }
        }

    async def red_flag_checker(self, symptom_description):
        """
        Check for red flag symptoms that require immediate emergency attention
        Returns: tuple (bool, list of matched red flags)
        """
        try:
            symptom_description = symptom_description.lower()
            matched_flags = []

            for category, phrases in self.RED_FLAGS.items():
                if any(phrase in symptom_description for phrase in phrases):
                    matched_flags.append(category)
                    await sync_to_async(logger.warning)(f"Red flag detected: {category} in symptom: {symptom_description}")

            return bool(matched_flags), matched_flags

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in red flag checking: {str(e)}")
            return True, ['error_defaulting_to_emergency']  # Err on side of caution

    async def symptom_analyzer(self, symptom_description, patient_data=None):
        """
        Analyze symptoms using OpenAI for severity assessment
        Returns: dict with analysis results
        """
        try:
            prompt = await sync_to_async(self._build_analysis_prompt)(symptom_description, patient_data)
            
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a medical triage assistant. Always err on the side of caution."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )

            analysis = json.loads(response.choices[0].message.content)
            await sync_to_async(logger.info)(f"Symptom analysis completed: {analysis}")
            return analysis

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in symptom analysis: {str(e)}")
            return {
                'severity': 'HIGH',
                'confidence': 0.0,
                'recommendation': 'Due to analysis error, recommending careful evaluation',
                'error': str(e)
            }

    async def risk_level_determiner(self, symptom_analysis, red_flags=None):
        """
        Determine risk level based on symptom analysis and red flags
        Returns: dict with risk assessment
        """
        try:
            if red_flags:
                return {
                    'level': 'EMERGENCY',
                    'action': self.RISK_LEVELS['EMERGENCY']['action'],
                    'urgency': self.RISK_LEVELS['EMERGENCY']['urgency'],
                    'red_flags': red_flags,
                    'timestamp': datetime.utcnow().isoformat()
                }

            # Map severity to risk level
            severity_mapping = {
                'MILD': 'LOW',
                'MODERATE': 'MEDIUM',
                'SEVERE': 'HIGH',
                'CRITICAL': 'EMERGENCY'
            }

            assessed_level = severity_mapping.get(
                symptom_analysis.get('severity', 'SEVERE'),  # Default to SEVERE if unclear
                'HIGH'  # Default to HIGH if mapping fails
            )

            return {
                'level': assessed_level,
                'action': self.RISK_LEVELS[assessed_level]['action'],
                'urgency': self.RISK_LEVELS[assessed_level]['urgency'],
                'confidence': symptom_analysis.get('confidence', 0.0),
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in risk level determination: {str(e)}")
            return {
                'level': 'HIGH',
                'action': self.RISK_LEVELS['HIGH']['action'],
                'urgency': 'Due to assessment error, recommending urgent evaluation',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    async def response_formatter(self, risk_assessment, patient_data=None):
        """
        Format the response based on risk assessment
        Returns: dict with formatted response messages
        """
        try:
            # Standard disclaimer
            disclaimer = (
                "IMPORTANT: This is an automated guidance system and not a medical diagnosis. "
                "If you're unsure or your condition worsens, please seek immediate medical attention."
            )

            # Emergency message template
            if risk_assessment['level'] == 'EMERGENCY':
                messages = [
                    " EMERGENCY MEDICAL ATTENTION RECOMMENDED ",
                    f"ACTION NEEDED: {risk_assessment['action']}",
                    "Key points:",
                    "- Call emergency services (112 or 999) immediately",
                    "- Do not delay seeking help",
                    "- Stay calm and find a safe location",
                    "",
                    disclaimer
                ]

            # High risk message template
            elif risk_assessment['level'] == 'HIGH':
                messages = [
                    " URGENT MEDICAL ATTENTION ADVISED ",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Next steps:",
                    "- Visit your nearest urgent care center",
                    "- If symptoms worsen, call emergency services",
                    "- Keep someone informed of your condition",
                    "",
                    disclaimer
                ]

            # Medium risk message template
            elif risk_assessment['level'] == 'MEDIUM':
                messages = [
                    " MEDICAL ATTENTION RECOMMENDED",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Options:",
                    "- Visit an urgent care center",
                    "- Book an urgent appointment with your doctor",
                    "- Monitor your symptoms closely",
                    "",
                    disclaimer
                ]

            # Low risk message template
            else:
                messages = [
                    " MEDICAL GUIDANCE",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Book a routine appointment",
                    "- Monitor your symptoms",
                    "- If condition worsens, seek urgent care",
                    "",
                    disclaimer
                ]

            # Add local emergency numbers if available
            if patient_data and 'address' in patient_data:
                country = patient_data['address'][0].get('country', 'Unknown')
                messages.append(f"\nLocal emergency numbers for {country}:")
                if country == "Italy":
                    messages.append("Emergency: 112")
                    messages.append("Medical Emergency: 118")
                elif country == "United Kingdom":
                    messages.append("Emergency: 999 or 112")
                    messages.append("NHS Non-emergency: 111")

            return {
                'messages': messages,
                'risk_level': risk_assessment['level'],
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error formatting response: {str(e)}")
            return {
                'messages': [
                    " ERROR IN PROCESSING",
                    "For your safety, please seek medical attention or call emergency services if you're concerned.",
                    "",
                    disclaimer
                ],
                'risk_level': 'ERROR',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    def _build_analysis_prompt(self, symptom_description, patient_data):
        """Helper method to build the analysis prompt"""
        base_prompt = f"""
        Analyze the following symptoms and provide a severity assessment.
        Symptoms: {symptom_description}
        
        Respond in the following JSON format:
        {{
            "severity": "MILD|MODERATE|SEVERE|CRITICAL",
            "confidence": <float 0-1>,
            "recommendation": <string>,
            "key_symptoms": [<list of key symptoms identified>],
            "reasoning": <string explaining assessment>
        }}
        
        Always err on the side of caution. If in doubt, rate severity higher.
        """

        if patient_data:
            # Add relevant patient information to the prompt
            age = None
            if 'birthDate' in patient_data:
                birth_date = datetime.strptime(patient_data['birthDate'], '%Y-%m-%d')
                age = (datetime.now() - birth_date).days // 365

            additional_context = f"""
            Patient Context:
            - Age: {age if age else 'Unknown'} years
            - Gender: {patient_data.get('gender', 'Unknown')}
            """
            base_prompt += additional_context

        return base_prompt

    async def provide_specific_info(self, user_query):
        """
        Provide detailed information addressing the user's specific query.
        Uses OpenAI to generate a structured and informative response.
        """
        try:
            prompt = f"""
            You are a medical information assistant. Provide a detailed, accurate, and easy-to-understand answer to the following question:

            "{user_query}"

            Structure your response with numbered points, covering the following aspects:
            1. Explanation of the condition: what it is, what causes it, how it's transmitted, etc.
            2. Common symptoms.
            3. Diagnostic methods.
            4. Treatment options.
            5. When to seek medical attention.

            Include a disclaimer at the end stating that this information is for educational purposes only and should not replace professional medical advice.
            """

            response = await openai.ChatCompletion.acreate(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a helpful and accurate medical information assistant."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=500
            )

            detailed_info = response.choices[0].message.content.strip()

            return {
                'messages': [detailed_info]
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in provide_specific_info: {str(e)}")
            return {
                'messages': ["I'm sorry, I couldn't retrieve detailed information at this time."]
            }
print ("41")

================
File: utils/constants.py
================
# project/utils/constants.py
from datetime import timedelta

# Business Hours and Time Settings
BUSINESS_HOURS_START = 9
BUSINESS_HOURS_END = 17
DEFAULT_TIMEZONE = "America/New_York"
MAX_FUTURE_BOOKING_DAYS = 90
SLOT_DURATION_MINUTES = 30
SCHEDULE_HORIZON_START = "2024-01-01T00:00:00Z"
SCHEDULE_HORIZON_END = "2050-12-31T23:59:59Z"

# Session Settings
SESSION_EXPIRY_SECONDS = 1800  # 30 minutes
SESSION_KEY_PREFIX = "session:"
SESSION_STORAGE_DAYS = 1  # Store sessions for 1 day

# Appointment Settings
APPOINTMENT_STATUS = {
    'BOOKED': 'booked',
    'PENDING': 'pending',
    'CANCELLED': 'cancelled',
    'COMPLETED': 'completed'
}

APPOINTMENT_TYPES = {
    '1': 'GP',
    '2': 'Nurse',
    '3': 'Specialist'
}

# FHIR Resource Types
RESOURCE_TYPES = {
    'PATIENT': 'Patient',
    'PRACTITIONER': 'Practitioner',
    'APPOINTMENT': 'Appointment',
    'SCHEDULE': 'Schedule',
    'SLOT': 'Slot',
    'CONDITION': 'Condition',
    'MEDICATION': 'MedicationStatement',
    'PROCEDURE': 'Procedure',
    'IMMUNIZATION': 'Immunization',
    'ALLERGY': 'AllergyIntolerance'
}

# Response Messages
MESSAGES = {
    'NO_APPOINTMENTS': "You don't have any upcoming appointments scheduled.",
    'BOOKING_CANCELLED': "Booking cancelled. Is there anything else I can help you with?",
    'VERIFY_IDENTITY': "Please verify your identity first by providing your email address.",
    'INVALID_EMAIL': "I couldn't find your record. Please verify your email address.",
    'SESSION_ERROR': "There was an error with your session. Please try again.",
    'BOOKING_ERROR': "There was an error with your booking. Please try again.",
    'WEEKEND_ERROR': "We are closed on weekends. Please select a weekday.",
    'HOURS_ERROR': "Our hours are 9 AM to 5 PM. Please select a time during business hours.",
    'PAST_DATE_ERROR': "Please select a future date and time.",
    'DATETIME_FORMAT_ERROR': """Could not understand the date/time format. Please try:
        - 'tomorrow at 2pm'
        - 'October 31st at 2pm'
        - 'next Tuesday at 2pm'"""
}

# Search Parameters
SEARCH_ATTEMPTS = [
    {'telecom': "email|{email}"},
    {'email': "{email}"},
    {'telecom': "{email}"},
    {'telecom:contains': "{email}"},
    {'telecom:exact': "email|{email}"}
]

# Intent Detection Settings
INTENT_CONFIDENCE_THRESHOLD = 0.7
MAX_TOKENS = 500
TEMPERATURE = 0

# Logging Settings
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
LOG_LEVEL = 'DEBUG'

# API Settings
OPENAI_MODEL = "gpt-4o-mini"
OPENAI_MAX_RETRIES = 3
OPENAI_TIMEOUT = 30

# Default Mock Patient Data (for testing)
DEFAULT_MOCK_PATIENT = {
    "extension": [
        {
            "url": "http://example.org/fhir/StructureDefinition/height",
            "valueQuantity": {
                "value": 170,
                "unit": "cm"
            }
        },
        {
            "url": "http://example.org/fhir/StructureDefinition/weight",
            "valueQuantity": {
                "value": 70,
                "unit": "kg"
            }
        }
    ]
}

================
File: utils/datetime_utils.py
================
from datetime import datetime, timedelta
from chatbot.views.config import config as app_config
from zoneinfo import ZoneInfo
import re
import dateparser
from datetime import datetime, timedelta, time
import logging
from django.conf import settings
import openai
openai.api_key = settings.OPENAI_API_KEY
# Configure logging
logger = logging.getLogger('chatbot')

from chatbot.views.config import config as app_config

fhir_client = app_config.fhir_client

# Initialize OpenAI client
client = settings.OPENAI_API_KEY


def parse_datetime(text):
    """
    Parse date and time from natural language text.
    Returns tuple of (datetime object, confidence level)
    """
    try:
        # Clean the text
        text = text.lower().strip()
        
        # Get current time in UTC
        now = datetime.now(ZoneInfo("UTC"))
        
        # Handle "tomorrow" explicitly
        if "tomorrow" in text:
            # Start with tomorrow's date
            target_date = now.date() + timedelta(days=1)
            
            # Extract time
            time_match = re.search(r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)', text)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if time_match.group(2) else 0
                if time_match.group(3) == 'pm' and hour != 12:
                    hour += 12
                elif time_match.group(3) == 'am' and hour == 12:
                    hour = 0
                
                # Create datetime with extracted time
                parsed = datetime.combine(
                    target_date, 
                    time(hour=hour, minute=minute), 
                    tzinfo=ZoneInfo("UTC")
                )
                return parsed, 'high'
        
        # For other cases, use dateparser
        parsed = dateparser.parse(text, settings={
            'PREFER_DATES_FROM': 'future',
            'RELATIVE_BASE': now
        })
        
        if parsed:
            # Make timezone-aware if it isn't already
            if parsed.tzinfo is None:
                parsed = parsed.replace(tzinfo=ZoneInfo("UTC"))
            
            # If only date is mentioned (no time), set a default time
            if any(word in text for word in ['am', 'pm', ':']) or 'time' in text:
                return parsed, 'high'
            else:
                # Set default time to 9:00 AM
                parsed = parsed.replace(hour=9, minute=0, second=0, microsecond=0)
                return parsed, 'medium'
                
        return None, 'low'
        
    except Exception as e:
        logger.error(f"Error parsing datetime: {e}")
        return None, 'low'

def get_current_time(timezone='America/New_York'):
    """
    Get the current time in the specified timezone
    """
    try:
        current_time = datetime.now(ZoneInfo(timezone))
        logger.debug(f"Current time in {timezone}: {current_time}")
        return current_time
    except Exception as e:
        logger.error(f"Error getting current time: {e}")
        # Fallback to UTC if there's an error
        fallback_time = datetime.now(timezone.utc)
        logger.warning(f"Falling back to UTC time: {fallback_time}")
        return fallback_time


def format_datetime(datetime_str):
    """
    Converts a datetime string to a more readable format.
    """
    try:
        parsed_datetime = datetime.fromisoformat(datetime_str.rstrip('Z'))
        return parsed_datetime.strftime("%B %d, %Y at %I:%M %p")
    except Exception as e:
        logger.error(f"Error formatting datetime: {e}")
        return datetime_str


def format_datetime_for_user(dt, timezone='America/New_York'):
    """
    Formats a datetime object into a user-friendly string with validation
    """
    if not dt:
        return None
    
    try:
        # Convert to specified timezone
        local_dt = dt.astimezone(ZoneInfo(timezone))
        
        # Format date and time
        date_str = local_dt.strftime("%A, %B %d, %Y")
        time_str = local_dt.strftime("%I:%M %p").lstrip("0")
        
        return f"{date_str} at {time_str}"
    except Exception as e:
        logger.error(f"Error formatting datetime: {e}")
        return None

def format_slot_time(slot):
    """
    Formats a slot's time for display.
    """
    try:
        start_time = datetime.fromisoformat(slot['start'].replace('Z', '+00:00'))
        return start_time.strftime("%B %d, %Y at %I:%M %p")
    except Exception as e:
        logger.error(f"Error formatting slot time: {e}")
        return "Time not available"

================
File: utils/formatters.py
================
from datetime import datetime
from django.conf import settings
from django.urls import resolve
from django.http import HttpRequest
from chatbot.views.config import config as app_config
import json
import logging

logger = logging.getLogger('chatbot')

# Use app_config instead of config
fhir_client = app_config.fhir_client

def get_resource_name(resource):
    """Get the display name of a FHIR resource."""
    if not resource:
        return "Unknown"
    
    if resource.get('name'):
        names = resource['name']
        if isinstance(names, list) and names:
            name = names[0]
            if isinstance(name, dict):
                return name.get('text') or f"{name.get('given', [''])[0]} {name.get('family', '')}"
        elif isinstance(names, dict):
            return names.get('text') or f"{names.get('given', [''])[0]} {names.get('family', '')}"
    
    return f"{resource.get('resourceType', 'Unknown')} {resource.get('id', 'Unknown')}"

def format_medications(medications_entries):
    """Format medications for display"""
    formatted = []
    for entry in medications_entries:
        med = entry.get('resource', {})
        if med:
            medication_name = med.get('medicationCodeableConcept', {}).get('text', 'Unknown Medication')
            dosage = med.get('dosageInstruction', [{}])[0]
            dose = dosage.get('doseAndRate', [{}])[0].get('doseQuantity', {})
            timing = dosage.get('timing', {}).get('repeat', {})
            
            med_str = f"- {medication_name}"
            if dose:
                med_str += f" {dose.get('value', '')} {dose.get('unit', '')}"
            if timing:
                med_str += f" {timing.get('frequency', '')} times per {timing.get('period', '')} {timing.get('periodUnit', '')}"
            
            formatted.append(med_str)
    
    return "\n".join(formatted) if formatted else "No medications found"

def format_appointments(appointment_entries):
    """Format appointments for display"""
    formatted = []
    for entry in appointment_entries:
        appt = entry.get('resource', {})
        if appt and appt.get('status') in ['booked', 'pending']:
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            formatted_time = start_time.strftime("%A, %B %d at %I:%M %p")
            
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('resourceType') == 'Practitioner':
                    practitioner = fhir_client.read("Practitioner", participant['actor']['reference'].split('/')[-1])
                    if practitioner:
                        practitioner_name = f"Dr. {get_resource_name(practitioner)}"
                    break
            
            appt_str = f"- {formatted_time} with {practitioner_name}"
            if appt.get('description'):
                appt_str += f" ({appt['description']})"
            
            formatted.append(appt_str)
    
    return "\n".join(formatted) if formatted else "No appointments found"
# chatbot/views/utils/formatters.py

def format_message(message, **kwargs):
    """Format messages with given parameters"""
    try:
        if isinstance(message, list):
            return '\n'.join(message)
        return str(message)
    except Exception as e:
        return str(message)
def send_message(message, user_id):
    """Sends a message and retrieves the response from the chat view."""
    try:
        from django.test import RequestFactory
        
        factory = RequestFactory()
        request = factory.post(
            '/chat',
            data=json.dumps({'message': message, 'user_id': user_id}),
            content_type='application/json'
        )

        view_func = resolve('/chat').func
        response = view_func(request)
        
        response_data = json.loads(response.content)
        return response_data.get('messages', ["No response received."])[0]
    except Exception as e:
        logger.error(f"Error in send_message: {str(e)}")
        return "Sorry, I couldn't process that message."

================
File: utils/medical_info_templates.py
================
"""
medical_info_templates.py

This module provides accurate, structured templates for common medical conditions
and questions. These templates ensure consistency, accuracy, and completeness
in ANNA's responses to frequently asked medical questions.
"""

# DIABETES INFORMATION TEMPLATE
# Addresses issue #1: Topic mismatch in diabetes response
DIABETES_INFO = {
    "brief_answer": "Diabetes is a chronic condition that affects how your body processes blood sugar (glucose). Common symptoms include increased thirst, frequent urination, unexplained weight loss, fatigue, blurred vision, slow-healing sores, and frequent infections.",
    
    "detailed_info": {
        "COMMON SYMPTOMS": [
            "Increased thirst and frequent urination", 
            "Extreme hunger", 
            "Unexplained weight loss",
            "Fatigue and weakness",
            "Blurred vision",
            "Slow-healing sores or frequent infections",
            "Tingling or numbness in hands/feet (more common in type 2)"
        ],
        
        "TYPE 1 VS TYPE 2": [
            "Type 1: Symptoms often develop quickly (days to weeks) and can be severe",
            "Type 2: Symptoms typically develop gradually and may be mild or absent initially",
            "Gestational: Often asymptomatic, detected through screening tests during pregnancy"
        ],
        
        "RISK FACTORS": [
            "Type 1: Family history, genetics, certain viruses may trigger onset",
            "Type 2: Overweight, physical inactivity, family history, age (over 45), ethnicity",
            "Gestational: Previous gestational diabetes, family history, obesity, older maternal age"
        ]
    },
    
    "emergency_symptoms": [
        "Extreme thirst and very frequent urination",
        "Severe nausea and vomiting",
        "Breath that smells fruity or like acetone",
        "Confusion or loss of consciousness",
        "Severe abdominal pain"
    ],
    
    "when_to_see_doctor": [
        "If you experience multiple symptoms listed above",
        "If you have risk factors for diabetes",
        "For routine screening, especially if you're over 45"
    ],
    
    "prevention": [
        "Maintain a healthy weight",
        "Be physically active for at least 30 minutes most days",
        "Eat a balanced diet rich in fruits, vegetables, and whole grains",
        "Limit processed foods and added sugars",
        "Get regular check-ups and screenings"
    ]
}

# BLOOD PRESSURE INFORMATION TEMPLATE
# Addresses issues #1 and #9: Provide comprehensive information with normal ranges
BLOOD_PRESSURE_INFO = {
    "brief_answer": "Blood pressure is the force of blood pushing against the walls of your arteries. High blood pressure (hypertension) often has no symptoms, which is why it's called the 'silent killer.' The only reliable way to know if you have high blood pressure is to have it measured.",
    
    "detailed_info": {
        "HOW TO CHECK": [
            "Have your blood pressure measured by a healthcare professional",
            "Use a home blood pressure monitor (available at most pharmacies)",
            "Public blood pressure machines (in some pharmacies and stores)",
            "Take multiple readings at different times for accuracy"
        ],
        
        "UNDERSTANDING READINGS": [
            "Blood pressure is recorded as two numbers: systolic/diastolic",
            "Systolic (top number): Pressure when heart beats",
            "Diastolic (bottom number): Pressure when heart rests between beats"
        ],
        
        "RISK FACTORS": [
            "Family history of high blood pressure",
            "Age (risk increases as you get older)",
            "Race (more common in African Americans)",
            "Obesity or being overweight",
            "Physical inactivity",
            "High sodium diet",
            "Excessive alcohol consumption",
            "Stress",
            "Certain chronic conditions (diabetes, kidney disease)"
        ]
    },
    
    "normal_values": {
        "Normal": {"range": "Below 120/80 mmHg"},
        "Elevated": {"range": "120-129/<80 mmHg", "note": "Risk of developing high blood pressure without intervention"},
        "Stage 1 Hypertension": {"range": "130-139/80-89 mmHg", "note": "Lifestyle changes typically recommended, medication may be considered"},
        "Stage 2 Hypertension": {"range": "140+/90+ mmHg", "note": "Likely to need medication along with lifestyle changes"},
        "Hypertensive Crisis": {"range": "Higher than 180/120 mmHg", "note": "EMERGENCY - Requires immediate medical attention"}
    },
    
    "when_to_see_doctor": [
        "Blood pressure consistently above 130/80 mmHg",
        "Symptoms like headaches, vision changes, chest pain with high readings",
        "To develop a comprehensive plan addressing blood pressure"
    ],
    
    "practical_steps": [
        "Reduce sodium intake (processed foods, restaurant meals)",
        "Follow the DASH diet (rich in fruits, vegetables, whole grains)",
        "Regular physical activity (at least 150 minutes/week)",
        "Maintain a healthy weight",
        "Limit alcohol consumption",
        "Quit smoking",
        "Manage stress through relaxation techniques"
    ]
}

# COLD VS. FLU INFORMATION TEMPLATE
# Addresses issue #4: Condition variants clarification
COLD_VS_FLU_INFO = {
    "brief_answer": "Colds and flu are both respiratory infections caused by different viruses. The flu tends to be more severe with a sudden onset, while colds generally develop more gradually and are milder. Understanding the differences can help determine appropriate care.",
    
    "variants": {
        "COLD": {
            "description": "Common colds are mild viral infections primarily affecting the nose and throat.",
            "symptoms": [
                "Gradual onset over several days",
                "Mild to moderate symptoms",
                "Runny or stuffy nose (main symptom)",
                "Sneezing and sore throat are common",
                "Mild cough",
                "Rarely causes fever in adults (slight fever possible in children)",
                "Rarely causes significant fatigue or body aches",
                "Typically does not cause headaches",
                "Does not usually result in serious health problems"
            ],
            "treatment": [
                "Rest and hydration",
                "Over-the-counter cold medications for symptom relief",
                "Saline nasal spray",
                "Humidifier to ease congestion",
                "Typically resolves in 7-10 days"
            ]
        },
        "FLU": {
            "description": "Influenza (flu) is a more severe viral infection that affects the respiratory system and can impact the whole body.",
            "symptoms": [
                "Rapid onset (can develop within hours)",
                "Moderate to severe symptoms",
                "Fever, usually high (100F-104F), lasting 3-4 days",
                "Prominent fatigue and weakness (can last up to 2-3 weeks)",
                "Severe body aches and headaches",
                "Dry cough",
                "Chills",
                "Less prominent nasal symptoms compared to colds",
                "Can lead to complications like pneumonia"
            ],
            "treatment": [
                "Rest and hydration",
                "Antiviral medications if started within 48 hours of symptoms",
                "Over-the-counter medications for fever and pain",
                "Typically improves within 1-2 weeks",
                "May require medical attention for severe cases"
            ]
        }
    },
    
    "when_to_see_doctor": [
        "Difficulty breathing or shortness of breath",
        "Persistent chest or abdominal pain",
        "Persistent dizziness or confusion",
        "Seizures",
        "Severe muscle pain",
        "Severe weakness or unsteadiness",
        "Fever or cough that improves then returns worse",
        "Worsening of chronic medical conditions"
    ],
    
    "prevention": [
        "Annual flu vaccination",
        "Frequent handwashing with soap and water",
        "Avoid close contact with sick individuals",
        "Cover coughs and sneezes with tissues or your elbow",
        "Clean and disinfect frequently touched surfaces",
        "Avoid touching your face"
    ]
}

# CHEST PAIN INFORMATION TEMPLATE
# Addresses issue #10: Clear emergency information
CHEST_PAIN_INFO = {
    "brief_answer": "Chest pain can have many different causes ranging from non-life-threatening conditions to serious medical emergencies like heart attacks. Because chest pain can be a sign of a serious problem, it's important to seek immediate medical care if you experience certain warning signs.",
    
    "detailed_info": {
        "EMERGENCY SIGNS (CALL 911/EMERGENCY SERVICES)": [
            "Pressure, squeezing, or fullness in the center of your chest lasting more than a few minutes or that comes and goes",
            "Pain spreading to shoulders, arms, neck, jaw, or back",
            "Cold sweat, nausea, or lightheadedness accompanying chest pain",
            "Shortness of breath with or without chest discomfort",
            "Sudden severe chest pain with palpitations and anxiety"
        ],
        
        "NON-EMERGENCY CHEST PAIN THAT STILL REQUIRES MEDICAL ATTENTION": [
            "Sharp pain that worsens when breathing deeply or coughing (may indicate lung issues)",
            "Tenderness when pressing on the chest wall",
            "Pain that improves or worsens when changing positions",
            "Persistent mild to moderate chest pain",
            "Chest pain with fever and cough"
        ],
        
        "POSSIBLE CAUSES OF CHEST PAIN": [
            "Heart-related: Heart attack, angina, myocarditis, pericarditis",
            "Lung-related: Pulmonary embolism, pneumonia, pleurisy, pneumothorax, asthma",
            "Digestive: Acid reflux (GERD), esophageal spasm, gallbladder issues, pancreatitis",
            "Musculoskeletal: Costochondritis, sore muscles, injured ribs",
            "Other: Panic attack, shingles, severe anxiety"
        ]
    },
    
    "emergency_symptoms": [
        "Crushing, squeezing pressure or tightness in chest",
        "Chest pain spreading to jaw, neck, shoulder, arm, or back",
        "Chest pain accompanied by shortness of breath, sweating, dizziness, or nausea",
        "Sudden, sharp chest pain with shortness of breath, especially after long periods of inactivity",
        "Very rapid or irregular heartbeat with chest pain"
    ],
    
    "when_to_see_doctor": [
        "Chest pain that's not going away and you're not sure if it's an emergency",
        "Recurring chest pain triggered by exertion",
        "Persistent chest discomfort of any kind",
        "Chest pain that concerns you, even if standard tests come back normal"
    ],
    
    "practical_steps": [
        "For emergency symptoms, call 911 or local emergency number immediately",
        "For non-emergency chest pain, record when it occurs and what makes it better or worse",
        "Note related symptoms (like coughing or anxiety)",
        "Don't ignore chest pain and hope it goes away",
        "Don't diagnose yourself - seek professional evaluation"
    ]
}

# SPRAINED ANKLE INFORMATION TEMPLATE
# Addresses issues #3 and #6: Detailed home care instructions
SPRAINED_ANKLE_INFO = {
    "brief_answer": "A sprained ankle occurs when the ligaments that connect the bones at the ankle joint are stretched or torn. Treatment involves rest, ice, compression, and elevation, along with proper rehabilitation to prevent future sprains.",
    
    "detailed_info": {
        "IMMEDIATE TREATMENT (FIRST 24-72 HOURS)": [
            "Rest: Avoid putting weight on the injured ankle",
            "Ice: Apply ice for 15-20 minutes every 2-3 hours to reduce swelling",
            "Compression: Use an elastic bandage to support the ankle and reduce swelling",
            "Elevation: Keep your ankle raised above the level of your heart when possible"
        ],
        
        "GRADES OF ANKLE SPRAINS": [
            "Grade 1 (Mild): Minimal pain, swelling, and no joint instability",
            "Grade 2 (Moderate): Moderate pain, swelling, and some joint looseness",
            "Grade 3 (Severe): Significant pain, swelling, and joint instability"
        ],
        
        "RECOVERY PHASE (AFTER INITIAL SWELLING SUBSIDES)": [
            "Begin gentle range-of-motion exercises (ankle circles, flexing and pointing)",
            "Gradually increase weight-bearing as tolerated",
            "Use supportive footwear when walking",
            "Consider physical therapy for moderate to severe sprains",
            "Use of assistive devices (crutches, walking boot) as recommended by healthcare provider"
        ]
    },
    
    "when_to_see_doctor": [
        "Inability to bear weight on the affected foot",
        "Severe swelling or bruising",
        "Pain directly over the ankle bones",
        "Heard or felt a 'pop' at the time of injury",
        "Pain and swelling don't improve after several days of home treatment"
    ],
    
    "practical_steps": [
        "Properly wrap the ankle with an elastic bandage (not too tight)",
        "Keep ice in a cloth (never apply directly to skin)",
        "Take over-the-counter pain relievers as directed for pain",
        "Use crutches if needed to avoid bearing weight",
        "Begin rehabilitation exercises only when recommended"
    ],
    
    "prevention": [
        "Warm up before physical activity",
        "Use supportive shoes appropriate for your activity",
        "Gradually increase exercise intensity",
        "Improve balance and strength with ankle exercises",
        "Consider ankle braces for high-risk activities if you have previous sprains"
    ]
}

# CHOLESTEROL INFORMATION TEMPLATE
# Addresses issue #4: Complete medical information with normal ranges
CHOLESTEROL_INFO = {
    "brief_answer": "Cholesterol is a waxy, fat-like substance found in all cells of the body. Your body needs cholesterol to make hormones, vitamin D, and substances that help digest foods. While your body makes all the cholesterol it needs, it's also found in foods from animal sources.",
    
    "detailed_info": {
        "TYPES OF CHOLESTEROL": [
            "LDL (Low-Density Lipoprotein): Often called 'bad' cholesterol; can build up on artery walls",
            "HDL (High-Density Lipoprotein): Known as 'good' cholesterol; helps remove LDL from arteries",
            "Triglycerides: Another type of fat in the blood; high levels increase heart disease risk",
            "Total cholesterol: The overall amount of cholesterol in your blood"
        ],
        
        "HOW CHOLESTEROL AFFECTS HEALTH": [
            "High LDL increases risk of heart disease and stroke",
            "Low HDL also increases cardiovascular risk",
            "Total cholesterol gives an overall picture but isn't as informative as the breakdown",
            "The ratio of total cholesterol to HDL can be a useful measure of risk"
        ],
        
        "FACTORS THAT AFFECT CHOLESTEROL LEVELS": [
            "Diet high in saturated and trans fats",
            "Lack of physical activity",
            "Obesity or overweight",
            "Smoking",
            "Age and gender",
            "Genetics and family history",
            "Certain medical conditions (diabetes, hypothyroidism)"
        ]
    },
    
    "normal_values": {
        "Total Cholesterol": {"normal": "Below 200 mg/dL", "abnormal": "Borderline high: 200-239 mg/dL, High: 240 mg/dL and above"},
        "LDL Cholesterol": {"normal": "Below 100 mg/dL", "abnormal": "Near optimal: 100-129 mg/dL, Borderline high: 130-159 mg/dL, High: 160-189 mg/dL, Very high: 190 mg/dL and above"},
        "HDL Cholesterol": {"normal": "60 mg/dL and above (higher is better)", "abnormal": "Low: Below 40 mg/dL for men, Below 50 mg/dL for women"},
        "Triglycerides": {"normal": "Below 150 mg/dL", "abnormal": "Borderline high: 150-199 mg/dL, High: 200-499 mg/dL, Very high: 500 mg/dL and above"}
    },
    
    "when_to_see_doctor": [
        "For regular cholesterol screening (every 4-6 years for adults, more frequently with risk factors)",
        "If you have a family history of high cholesterol or heart disease",
        "If you have other risk factors like diabetes, high blood pressure, or smoking",
        "If you're on cholesterol-lowering medication, for monitoring"
    ],
    
    "practical_steps": [
        "Eat a heart-healthy diet (limit saturated fats, eliminate trans fats, increase fiber)",
        "Exercise regularly (aim for at least 150 minutes of moderate activity weekly)",
        "Maintain a healthy weight",
        "Quit smoking",
        "Limit alcohol consumption"
    ]
}

# COLONOSCOPY INFORMATION TEMPLATE
COLONOSCOPY_INFO = {
    "brief_answer": "A colonoscopy is a procedure that lets doctors examine the inner lining of your large intestine (colon and rectum) using a flexible tube with a camera. It's primarily used to screen for colorectal cancer and find or remove polyps before they become cancerous.",
    
    "detailed_info": {
        "WHAT IS A COLONOSCOPY": [
            "An examination procedure using a colonoscope (long, flexible tube with a camera and light source)",
            "Allows doctors to view the entire colon and rectum",
            "Usually lasts 30-60 minutes",
            "Performed under mild sedation so patients are comfortable"
        ],
        
        "WHY IT IS DONE": [
            "Screens for colorectal cancer (the third most common cancer)",
            "Detects and removes precancerous polyps before they become malignant",
            "Investigates unexplained changes in bowel habits or abdominal symptoms",
            "Evaluates inflammatory bowel disease, bleeding, or other abnormalities",
            "Follow-up examination after previous findings"
        ],
        
        "WHAT TO EXPECT": [
            "Bowel prep required the day before (clear liquids and laxative solution)",
            "You'll receive sedation through an IV before the procedure",
            "The doctor gently inserts the colonoscope through the rectum",
            "Air or carbon dioxide inflates the colon for better viewing",
            "If polyps are found, they can typically be removed during the procedure",
            "Recovery usually takes about 1-2 hours after the procedure",
            "You'll need someone to drive you home due to the sedation"
        ],
        
        "WHEN IS IT RECOMMENDED": [
            "Average-risk adults should begin screening at age 45",
            "If you have a family history of colorectal cancer, screenings may start earlier",
            "Typically repeated every 10 years if normal and you have average risk",
            "More frequent follow-ups if polyps are found or you have other risk factors"
        ]
    },
    
    "when_to_see_doctor": [
        "Follow your doctor's recommendations for screening based on your risk factors",
        "If you experience unexplained abdominal pain, blood in stool, or changes in bowel habits",
        "If you have a family history of colorectal cancer or polyps"
    ],
    
    "practical_steps": [
        "Follow bowel prep instructions exactly - clean colon is essential for effective screening",
        "Arrange for someone to drive you home after the procedure",
        "Take the day off work on the day of the procedure",
        "Discuss any medications you're taking with your doctor before the procedure",
        "After the procedure, you may experience some bloating or gas pain, which is normal"
    ]
}

# Add more templates as needed...

# Dictionary of templates by topic for easy lookup
MEDICAL_INFO_TEMPLATES = {
    "diabetes": DIABETES_INFO,
    "blood pressure": BLOOD_PRESSURE_INFO,
    "hypertension": BLOOD_PRESSURE_INFO,
    "cold vs flu": COLD_VS_FLU_INFO,
    "chest pain": CHEST_PAIN_INFO,
    "sprained ankle": SPRAINED_ANKLE_INFO,
    "cholesterol": CHOLESTEROL_INFO,
    "colonoscopy": COLONOSCOPY_INFO,
}

def get_template_for_topic(topic: str):
    """
    Get the appropriate template for a given medical topic.
    Returns None if no specific template is available.
    """
    topic_lower = topic.lower()
    
    # Direct match
    if topic_lower in MEDICAL_INFO_TEMPLATES:
        return MEDICAL_INFO_TEMPLATES[topic_lower]
    
    # Partial match
    for key in MEDICAL_INFO_TEMPLATES:
        if key in topic_lower or topic_lower in key:
            return MEDICAL_INFO_TEMPLATES[key]
    
    # No match
    return None

================
File: utils/response_formatter.py
================
"""
response_formatter.py

This module provides consistent formatting for all ANNA's responses.
It ensures medical information is presented clearly, accurately, and with appropriate
structure and warnings.
"""

import logging
from typing import List, Dict, Any, Optional, Union

logger = logging.getLogger(__name__)

# Medical disclaimer to use consistently
STANDARD_DISCLAIMER = "This information is for educational purposes only and is not a substitute for professional medical advice."

# Emergency warning text
EMERGENCY_WARNING = "SEEK IMMEDIATE MEDICAL ATTENTION if you experience severe symptoms."

def format_medical_response(
    question: str,
    response_data: Dict[str, Any],
    include_brief_answer: bool = True,
    condition_info: Optional[Dict[str, Any]] = None
) -> List[str]:
    """
    Format a medical response with consistent structure.
    
    Args:
        question: The original user question
        response_data: Dictionary containing response components
        include_brief_answer: Whether to include a brief answer at the beginning
        condition_info: Optional condition-specific information
        
    Returns:
        List of formatted message strings
    """
    messages = []
    
    # 1. Direct brief answer if requested (Implementation #1)
    if include_brief_answer and "brief_answer" in response_data:
        messages.append(response_data["brief_answer"])
    
    # 2. Add detailed information with clear structure
    if "detailed_info" in response_data:
        # If no brief answer but we have details, start with a clean lead-in
        if not (include_brief_answer and "brief_answer" in response_data):
            if "intro" in response_data:
                messages.append(response_data["intro"])
                
        # Add detailed explanation
        if isinstance(response_data["detailed_info"], list):
            messages.extend(response_data["detailed_info"])
        else:
            messages.append(response_data["detailed_info"])
    
    # 3. Add emergency warnings when appropriate (Implementation #8)
    if "emergency_symptoms" in response_data and response_data["emergency_symptoms"]:
        messages.append("\nSEEK IMMEDIATE MEDICAL ATTENTION if you experience:")
        for symptom in response_data["emergency_symptoms"]:
            messages.append(f" {symptom}")
    
    # 4. Add non-emergency "when to see doctor" guidance (Implementation #4)
    if "when_to_see_doctor" in response_data and response_data["when_to_see_doctor"]:
        messages.append("\nSEEK MEDICAL ADVICE if you experience:")
        for symptom in response_data["when_to_see_doctor"]:
            messages.append(f" {symptom}")
    
    # 5. Add practical steps when available (Implementation #3)
    if "practical_steps" in response_data and response_data["practical_steps"]:
        messages.append("\nPRACTICAL STEPS:")
        for step in response_data["practical_steps"]:
            messages.append(f" {step}")
    
    # 6. Add prevention information when relevant (Implementation #5)
    if "prevention" in response_data and response_data["prevention"]:
        messages.append("\nPREVENTION:")
        for measure in response_data["prevention"]:
            messages.append(f" {measure}")
    
    # 7. Always include medical disclaimer (Implementation #8)
    messages.append(f"\n{STANDARD_DISCLAIMER}")
    
    return messages

def format_symptom_response(
    symptoms: str,
    severity: str,
    recommendations: List[str],
    when_to_seek_help: List[str],
    possible_causes: Optional[List[str]] = None,
    personalized_note: Optional[str] = None
) -> List[str]:
    """
    Format a response for symptom-related queries with safety warnings.
    
    Args:
        symptoms: Description of symptoms
        severity: Assessed severity level (EMERGENCY, HIGH, MEDIUM, LOW)
        recommendations: List of recommended actions
        when_to_seek_help: Warning signs to seek medical help
        possible_causes: Optional list of possible causes
        personalized_note: Optional personalized warning based on patient history
        
    Returns:
        List of formatted message strings
    """
    messages = []
    
    # Add personalized note at the top if provided
    if personalized_note:
        messages.append(personalized_note)
        messages.append("")  # Add a blank line for better readability
    
    # Severity-based formatting (Implementation #4)
    if severity == "EMERGENCY":
        messages.append(" EMERGENCY: SEEK IMMEDIATE MEDICAL ATTENTION")
        messages.append("This may indicate a serious condition requiring immediate care.")
    elif severity == "HIGH":
        messages.append(" URGENT MEDICAL ATTENTION RECOMMENDED")
        messages.append("These symptoms may require prompt medical evaluation.")
    elif severity == "MEDIUM":
        messages.append(" MEDICAL ATTENTION ADVISED")
        messages.append("These symptoms should be evaluated by a healthcare provider.")
    else:  # LOW
        messages.append(" GENERAL HEALTH INFORMATION")
        messages.append("These symptoms can often be managed with self-care, but monitor for changes.")
    
    # Add possible causes if provided
    if possible_causes and len(possible_causes) > 0:
        messages.append("\nPOSSIBLE CAUSES:")
        for cause in possible_causes:
            messages.append(f" {cause}")
    
    # Add recommendations
    if recommendations and len(recommendations) > 0:
        messages.append("\nRECOMMENDATIONS:")
        for rec in recommendations:
            messages.append(f" {rec}")
    
    # Add warning signs
    if when_to_seek_help and len(when_to_seek_help) > 0:
        messages.append("\nSEEK MEDICAL CARE IF YOU EXPERIENCE:")
        for sign in when_to_seek_help:
            messages.append(f" {sign}")
    
    # Always include medical disclaimer
    messages.append(f"\n{STANDARD_DISCLAIMER}")
    
    return messages

def format_medical_info_response(
    topic: str,
    summary: str,
    details: Dict[str, Any],
    normal_values: Optional[Dict[str, Any]] = None,
    include_disclaimer: bool = True
) -> List[str]:
    """
    Format a response for medical information queries with clear categories.
    
    Args:
        topic: The medical topic being explained
        summary: Brief summary of the topic
        details: Dictionary with detailed information categories
        normal_values: Optional dictionary with normal/abnormal range information
        include_disclaimer: Whether to include the standard medical disclaimer (default True)
        
    Returns:
        List of formatted message strings
    """
    messages = []
    
    # Brief answer first (Implementation #1)
    messages.append(summary)
    
    # Add details by category with clear headings
    for category, info in details.items():
        if isinstance(info, list) and info:
            messages.append(f"\n{category.upper()}:")
            for item in info:
                messages.append(f" {item}")
        elif isinstance(info, str) and info:
            messages.append(f"\n{category.upper()}:")
            messages.append(info)
    
    # Add normal vs. abnormal values when relevant (Implementation #9)
    if normal_values:
        messages.append("\nNORMAL RANGES:")
        for name, value_info in normal_values.items():
            normal_range = value_info.get("normal", "Not specified")
            messages.append(f" {name}: {normal_range}")
            
            # Add abnormal context when available
            if "abnormal" in value_info:
                messages.append(f"  - {value_info['abnormal']}")
    
    # Add disclaimer only when requested (default = True)
    if include_disclaimer:
        messages.append(f"\n{STANDARD_DISCLAIMER}")
    
    return messages

def format_condition_variants(
    condition: str,
    variants: Dict[str, Dict[str, Any]]
) -> List[str]:
    """
    Format information about condition variants with clear differentiation.
    
    Args:
        condition: The main condition name
        variants: Dictionary of variant types and their information
        
    Returns:
        List of formatted message strings
    """
    messages = []
    
    # Overview of condition
    messages.append(f"Different types of {condition}:")
    
    # Add each variant with consistent structure
    for variant_name, variant_info in variants.items():
        messages.append(f"\n{variant_name.upper()}:")
        
        # Add description
        if "description" in variant_info:
            messages.append(variant_info["description"])
        
        # Add symptoms
        if "symptoms" in variant_info and variant_info["symptoms"]:
            messages.append("Symptoms:")
            for symptom in variant_info["symptoms"]:
                messages.append(f" {symptom}")
        
        # Add treatment
        if "treatment" in variant_info and variant_info["treatment"]:
            messages.append("Treatment:")
            for treatment in variant_info["treatment"]:
                messages.append(f" {treatment}")
    
    # Always include medical disclaimer
    messages.append(f"\n{STANDARD_DISCLAIMER}")
    
    return messages

================
File: utils/shared.py
================
# chatbot/views/utils/shared.py
def get_resource_name(resource):
    """Extracts the name from a FHIR resource."""
    if 'name' in resource and len(resource['name']) > 0:
        name_entry = resource['name'][0]
        if 'given' in name_entry and 'family' in name_entry:
            given = " ".join(name_entry.get('given', []))
            family = name_entry.get('family', '')
            return f"{given} {family}".strip()
        elif 'text' in name_entry and name_entry.get('text'):
            return name_entry.get('text').strip()
    return 'Unknown'

================
File: config.py
================
from django.conf import settings
from openai import AsyncOpenAI
from redis import Redis
from redis.asyncio import Redis as AsyncRedis
import logging
from .utils.constants import LOG_FORMAT, LOG_LEVEL, SESSION_EXPIRY_SECONDS
import openai
from fhirclient import client
from fhirclient.server import FHIRServer

# Configure logging
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format=LOG_FORMAT
)
logger = logging.getLogger('chatbot')

class Config:
    def __init__(self):
        self._fhir_client = None
        self._async_fhir_client = None
        self._redis_client = None
        self._async_redis_client = None
        self._openai_client = None
        self.initialize_clients()

    def initialize_clients(self):
        """Initialize all client connections"""
        try:
            # Initialize FHIR client
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            self._fhir_client = client.FHIRClient(settings=settings_dict)
            logger.info("FHIR client initialized successfully")

            # Initialize Redis clients - both sync and async
            self._redis_client = Redis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
            self._async_redis_client = AsyncRedis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
            self._redis_client.ping()  # Test connection
            logger.info("Redis clients initialized successfully")
            
            # Initialize OpenAI client
            self._openai_client = AsyncOpenAI(
                api_key=settings.OPENAI_API_KEY,
                timeout=60.0
            )
            logger.info("OpenAI client initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing clients: {str(e)}")
            raise

    async def get_async_fhir_client(self):
        """Get async FHIR server with lazy initialization"""
        if not self._async_fhir_client:
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            smart = client.FHIRClient(settings=settings_dict)
            self._async_fhir_client = smart.server
        return self._async_fhir_client

    def get_fhir_client(self):
        """Get synchronous FHIR server with lazy initialization"""
        if not self._fhir_client:
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            smart = client.FHIRClient(settings=settings_dict)
            self._fhir_client = smart.server
        return self._fhir_client

    def get_redis_client(self):
        """Get synchronous Redis client with lazy initialization"""
        if not self._redis_client:
            self._redis_client = Redis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
        return self._redis_client

    def get_async_redis_client(self):
        """Get asynchronous Redis client with lazy initialization"""
        if not self._async_redis_client:
            self._async_redis_client = AsyncRedis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
        return self._async_redis_client
        
    def get_openai_client(self):
        """Get OpenAI client with lazy initialization"""
        if not self._openai_client:
            self._openai_client = AsyncOpenAI(
                api_key=settings.OPENAI_API_KEY,
                timeout=60.0
            )
        return self._openai_client

    @property
    def fhir_client(self):
        """Property accessor for FHIR client"""
        return self.get_fhir_client()

    @property
    def redis_client(self):
        """Property accessor for Redis client"""
        return self.get_redis_client()

    @property
    def async_redis_client(self):
        """Property accessor for asynchronous Redis client"""
        return self.get_async_redis_client()

    @property
    def openai_client(self):
        """Property accessor for OpenAI client"""
        return self.get_openai_client()

    def reset_clients(self):
        """Reset all clients - useful for testing or error recovery"""
        self._fhir_client = None
        self._redis_client = None 
        self._async_redis_client = None
        self._openai_client = None
        self.initialize_clients()

# Add to existing config
INTENT_CONFIDENCE_THRESHOLDS = {
    # ... existing thresholds ...
    'lab_results': 0.8,
    'lab_query': 0.7
}

LAB_RESULT_CACHE_DURATION = 3600  # Cache lab results for 1 hour

# Create singleton instance
config = Config()

================
File: utils.py
================
# utils.py
from django.conf import settings
from openai import OpenAI
import redis
import logging

from fhir_client_module import FHIRClient

# Configure logging
logger = logging.getLogger('chatbot')

# Initialize shared clients
fhir_client = FHIRClient(base_url=settings.FHIR_SERVER_URL)
redis_client = redis.StrictRedis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=settings.REDIS_DB,
    decode_responses=True
)
openai_client = OpenAI(api_key=settings.OPENAI_API_KEY)

# Shared utility functions
def get_resource_name(resource):
    """Shared utility to extract name from FHIR resource"""
    if 'name' in resource and len(resource['name']) > 0:
        name_entry = resource['name'][0]
        if 'given' in name_entry and 'family' in name_entry:
            given = " ".join(name_entry.get('given', []))
            family = name_entry.get('family', '')
            return f"{given} {family}".strip()
        elif 'text' in name_entry and name_entry.get('text'):
            return name_entry.get('text').strip()
    return 'Unknown'



================================================================
End of Codebase
================================================================
