This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
email_service.py
explanation_service.py
fhir_service.py
intent_service.py
language_service.py
medication_service.py
notification_service.py
personalized_medical_advice_service.py
post_appointment_checkin_service.py
post_discharge_service.py
preventive_care_reminder_service.py
scheduler.py
screening_guideline_service.py
session.py
symptom_guidance_service.py

================================================================
Files
================================================================

================
File: email_service.py
================
"""
Email Verification Service for ANNA
Handles email verification for patient authentication
"""

import logging
import secrets
from datetime import datetime, timedelta
from typing import Dict, Optional
from django.core.mail import send_mail
from django.conf import settings
from asgiref.sync import sync_to_async

logger = logging.getLogger(__name__)

class EmailVerificationService:
    """Service for email verification and notifications"""
    
    def __init__(self):
        # In production, use Redis or database for verification codes
        self.verification_codes: Dict[str, Dict] = {}
        self.code_expiry_minutes = 15
    
    async def send_verification_email(
        self, 
        email: str, 
        patient_name: str = "User"
    ) -> str:
        """Send verification code via email"""
        try:
            # Generate 6-digit code
            code = ''.join([str(secrets.randbelow(10)) for _ in range(6)])
            
            # Store with expiration (15 minutes)
            self.verification_codes[email] = {
                'code': code,
                'expires': datetime.now() + timedelta(minutes=self.code_expiry_minutes),
                'attempts': 0
            }
            
            # Prepare email content
            subject = "ANNA Chatbot - Email Verification"
            message = f"""
Hello {patient_name},

Your verification code for ANNA Health Assistant is: {code}

This code will expire in {self.code_expiry_minutes} minutes.

For your security, please do not share this code with anyone.

Best regards,
ANNA Healthcare Team
"""
            
            # Send email asynchronously
            from_email = getattr(settings, 'DEFAULT_FROM_EMAIL', 'noreply@anna-health.com')
            
            await sync_to_async(send_mail)(
                subject,
                message,
                from_email,
                [email],
                fail_silently=False
            )
            
            logger.info(f"Verification email sent to {email}")
            return code
            
        except Exception as e:
            logger.error(f"Email send error: {e}")
            raise
    
    def verify_code(self, email: str, code: str) -> bool:
        """Verify email code"""
        if email not in self.verification_codes:
            logger.warning(f"No verification code found for {email}")
            return False
        
        stored_data = self.verification_codes[email]
        
        # Check expiration
        if datetime.now() > stored_data['expires']:
            del self.verification_codes[email]
            logger.warning(f"Verification code expired for {email}")
            return False
        
        # Increment attempts
        stored_data['attempts'] += 1
        
        # Check for too many attempts (max 3)
        if stored_data['attempts'] > 3:
            del self.verification_codes[email]
            logger.warning(f"Too many verification attempts for {email}")
            return False
        
        # Verify code
        if stored_data['code'] == code:
            del self.verification_codes[email]
            logger.info(f"Email verification successful for {email}")
            return True
        
        logger.warning(f"Invalid verification code for {email}")
        return False
    
    def resend_code(self, email: str) -> bool:
        """Check if code can be resent (prevent spam)"""
        if email not in self.verification_codes:
            return True
        
        stored_data = self.verification_codes[email]
        time_since_sent = datetime.now() - (stored_data['expires'] - timedelta(minutes=self.code_expiry_minutes))
        
        # Allow resend after 2 minutes
        return time_since_sent.total_seconds() > 120
    
    async def send_welcome_email(
        self,
        email: str,
        patient_name: str = "User"
    ) -> bool:
        """Send welcome email after successful verification"""
        try:
            subject = "Welcome to ANNA Health Assistant"
            message = f"""
Hello {patient_name},

Welcome to ANNA, your AI-powered health assistant!

You can now:
• Schedule and manage appointments
• Access your medical records
• Get health information and guidance
• Receive medication reminders
• Ask health-related questions

Your privacy and data security are our top priorities. All communications are HIPAA-compliant.

Start chatting with ANNA anytime to manage your health!

Best regards,
ANNA Healthcare Team
"""
            
            from_email = getattr(settings, 'DEFAULT_FROM_EMAIL', 'noreply@anna-health.com')
            
            await sync_to_async(send_mail)(
                subject,
                message,
                from_email,
                [email],
                fail_silently=False
            )
            
            logger.info(f"Welcome email sent to {email}")
            return True
            
        except Exception as e:
            logger.error(f"Welcome email error: {e}")
            return False
    
    async def send_password_reset_email(
        self,
        email: str,
        reset_link: str,
        patient_name: str = "User"
    ) -> bool:
        """Send password reset email"""
        try:
            subject = "ANNA Health Assistant - Password Reset"
            message = f"""
Hello {patient_name},

You requested a password reset for your ANNA Health Assistant account.

Click the link below to reset your password:
{reset_link}

This link will expire in 1 hour for your security.

If you didn't request this reset, please ignore this email.

Best regards,
ANNA Healthcare Team
"""
            
            from_email = getattr(settings, 'DEFAULT_FROM_EMAIL', 'noreply@anna-health.com')
            
            await sync_to_async(send_mail)(
                subject,
                message,
                from_email,
                [email],
                fail_silently=False
            )
            
            logger.info(f"Password reset email sent to {email}")
            return True
            
        except Exception as e:
            logger.error(f"Password reset email error: {e}")
            return False
    
    def cleanup_expired_codes(self):
        """Clean up expired verification codes"""
        expired_emails = []
        now = datetime.now()
        
        for email, data in self.verification_codes.items():
            if now > data['expires']:
                expired_emails.append(email)
        
        for email in expired_emails:
            del self.verification_codes[email]
        
        if expired_emails:
            logger.info(f"Cleaned up {len(expired_emails)} expired verification codes")

# Global instance
email_service = EmailVerificationService()

# Convenience functions
async def send_verification_email(email: str, patient_name: str = "User") -> str:
    return await email_service.send_verification_email(email, patient_name)

def verify_email_code(email: str, code: str) -> bool:
    return email_service.verify_code(email, code)

async def send_welcome_email(email: str, patient_name: str = "User") -> bool:
    return await email_service.send_welcome_email(email, patient_name)

async def send_password_reset_email(email: str, reset_link: str, patient_name: str = "User") -> bool:
    return await email_service.send_password_reset_email(email, reset_link, patient_name)

================
File: explanation_service.py
================
"""
explanation_service.py

Service for generating explanations about medical topics, procedures, and conditions.
This service is separate from symptom analysis to ensure clear educational responses
for questions that are asking for information rather than reporting health issues.
"""

import logging
import json
import asyncio
import httpx
from typing import Dict, List, Any, Optional

from django.conf import settings
from ...utils.openai_manager import openai_manager

from ..utils.medical_info_templates import get_template_for_topic
from ..utils.response_formatter import STANDARD_DISCLAIMER, format_medical_info_response

# Configure logging
logger = logging.getLogger(__name__)

class ExplanationService:
    """
    Service for providing educational explanations about medical topics.
    Focuses on medical procedures, tests, conditions, and general health information.
    """
    
    def __init__(self):
        """Initialize the service"""
        pass
    
    async def get_explanation(self, topic: str, patient_data: Optional[Dict] = None) -> Dict[str, List[str]]:
        """
        Get an explanation for a medical topic.
        
        Args:
            topic: The medical topic or procedure to explain
            patient_data: Optional patient data for personalization
            
        Returns:
            Dictionary with message list for the response
        """
        try:
            logger.info(f"Generating explanation for topic: {topic}")
            
            # 1. Check for template match first
            template = get_template_for_topic(topic)
            if template:
                logger.info(f"Found template for {topic}")
                return {"messages": format_medical_info_response(
                    topic=topic,
                    summary=template.get("brief_answer", ""),
                    details=template.get("detailed_info", {}),
                    include_disclaimer=True
                )}
            
            # 2. Try MedlinePlus Health Topic lookup
            medline_info = await self._fetch_health_topic(topic)
            if medline_info:
                logger.info(f"Found MedlinePlus info for {topic}")
                return {"messages": medline_info}
            
            # 3. Generate an explanation with AI
            gpt_explanation = await self._generate_ai_explanation(topic, patient_data)
            return {"messages": gpt_explanation}
            
        except Exception as e:
            logger.error(f"Error generating explanation for {topic}: {str(e)}")
            # Fallback response
            return {"messages": [
                f"I apologize, but I don't have specific information about {topic} at the moment.",
                "I recommend discussing this with your healthcare provider for accurate information.",
                STANDARD_DISCLAIMER
            ]}
    
    async def _fetch_health_topic(self, topic: str) -> List[str]:
        """
        Fetch information from MedlinePlus Health Topics API.
        Different from symptom lookup - this targets educational content.
        """
        try:
            # Use MedlinePlus Health Topics API
            base_url = "https://wsearch.nlm.nih.gov/ws/query"
            params = {
                "db": "healthTopics",
                "term": f"{topic} site:medlineplus.gov",
                "retmax": 1,
                "rettype": "json"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(base_url, params=params, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Extract the relevant information
                    if "result" in data and data["result"].get("documentList", {}).get("document"):
                        document = data["result"]["documentList"]["document"][0]
                        title = document.get("title", "")
                        snippet = document.get("snippet", "")
                        url = document.get("accessibleVersion", "")
                        
                        messages = [
                            f"# {title}",
                            "",
                            snippet,
                            "",
                            f"For more information: {url}",
                            "",
                            STANDARD_DISCLAIMER
                        ]
                        return messages
                        
            return []
        except Exception as e:
            logger.error(f"Error fetching health topic information: {str(e)}")
            return []
    
    async def _generate_ai_explanation(self, topic: str, patient_data: Optional[Dict] = None) -> List[str]:
        """
        Generate an explanation using AI when no template or MedlinePlus data is available.
        """
        try:
            # Create a prompt for the topic
            prompt = self._create_explanation_prompt(topic, patient_data)
            
            response = await openai_manager.chat_completion(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You are a medical education assistant providing accurate, structured explanations of medical topics."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )
            
            explanation = response.choices[0].message.content.strip()
            
            # Format into paragraphs
            paragraphs = [p.strip() for p in explanation.split('\n') if p.strip()]
            
            # Ensure we have the disclaimer
            if STANDARD_DISCLAIMER not in explanation:
                paragraphs.append(STANDARD_DISCLAIMER)
                
            return paragraphs
            
        except Exception as e:
            logger.error(f"Error generating AI explanation: {str(e)}")
            return [
                f"I'm sorry, I couldn't generate specific information about {topic}.",
                "Please consult with your healthcare provider for accurate information.",
                STANDARD_DISCLAIMER
            ]
    
    def _create_explanation_prompt(self, topic: str, patient_data: Optional[Dict] = None) -> str:
        """Create a prompt for generating an explanation about a medical topic."""
        prompt = f"""Provide a clear, structured explanation about {topic} covering:

1. WHAT IS IT: Brief definition and description
2. PURPOSE: Why it's done or recommended
3. WHAT TO EXPECT: The procedure or experience
4. BENEFITS: Key benefits or reasons for it
5. RISKS/SIDE EFFECTS: Potential risks or side effects 
6. PREPARATION: How patients should prepare (if applicable)
7. ALTERNATIVES: Alternative options (if applicable)

Format your response in clear paragraphs with headings (using Markdown # for headings).
Focus on educational information rather than diagnostic advice.
Keep your explanation accurate, balanced, and easy to understand.
End with a clear reminder that this is educational information, not personalized medical advice.
"""
        
        # Add patient context if available
        if patient_data and isinstance(patient_data, dict):
            # Extract relevant demographic info without revealing PII
            age = None
            gender = None
            
            if "birthDate" in patient_data:
                from datetime import datetime
                try:
                    birth_date = datetime.fromisoformat(patient_data["birthDate"].replace('Z', '+00:00'))
                    today = datetime.now()
                    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                except (ValueError, TypeError):
                    pass
            
            if "gender" in patient_data:
                gender = patient_data["gender"]
            
            if age or gender:
                prompt += f"\n\nConsider demographics: "
                if age:
                    prompt += f"age {age}, "
                if gender:
                    prompt += f"{gender}, "
                prompt = prompt.rstrip(", ")
                prompt += " when providing relevant information."
        
        return prompt

# Singleton instance
explanation_service = ExplanationService()

================
File: fhir_service.py
================
# chatbot/views/services/fhir_service.py
import httpx
import urllib.parse
from django.conf import settings
from datetime import datetime
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger('chatbot')

class FHIRService:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(FHIRService, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        self.base_url = settings.FHIR_SERVER_URL.rstrip('/')
        self.timeout = httpx.Timeout(30.0)
        self.headers = {
            "Accept": "application/fhir+json",
            "Content-Type": "application/fhir+json"
        }
        
        # Add auth headers if configured
        if hasattr(settings, 'FHIR_AUTH_TOKEN'):
            self.headers["Authorization"] = f"Bearer {settings.FHIR_AUTH_TOKEN}"
        
        logger.info(f"FHIR service initialized with base URL: {self.base_url}")
    
    async def search(self, resource_type: str, params: Optional[Dict[str, Any]] = None) -> Optional[Dict]:
        """Unified async search method with proper URL encoding"""
        try:
            url = f"{self.base_url}/{resource_type}"
            
            # Properly encode parameters
            if params:
                # Handle special FHIR search parameters
                encoded_params = {}
                for key, value in params.items():
                    if isinstance(value, list):
                        # Handle multiple values for same parameter
                        encoded_params[key] = ','.join(str(v) for v in value)
                    else:
                        encoded_params[key] = str(value)
                
                query_string = urllib.parse.urlencode(encoded_params)
                url = f"{url}?{query_string}"
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, headers=self.headers)
                response.raise_for_status()
                return response.json()
                
        except httpx.HTTPStatusError as e:
            logger.error(f"FHIR search HTTP error: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"FHIR search error: {str(e)}")
            return None
    
    async def read(self, resource_type: str, resource_id: str) -> Optional[Dict]:
        """Unified async read method"""
        try:
            url = f"{self.base_url}/{resource_type}/{resource_id}"
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.get(url, headers=self.headers)
                response.raise_for_status()
                return response.json()
                
        except httpx.HTTPStatusError as e:
            logger.error(f"FHIR read HTTP error: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"FHIR read error: {str(e)}")
            return None
    
    async def create(self, resource_type: str, resource: Dict) -> Optional[Dict]:
        """Unified async create method"""
        try:
            url = f"{self.base_url}/{resource_type}"
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(
                    url, 
                    json=resource, 
                    headers=self.headers
                )
                response.raise_for_status()
                return response.json()
                
        except httpx.HTTPStatusError as e:
            logger.error(f"FHIR create HTTP error: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"FHIR create error: {str(e)}")
            return None
    
    async def update(self, resource_type: str, resource_id: str, resource: Dict) -> Optional[Dict]:
        """Unified async update method"""
        try:
            url = f"{self.base_url}/{resource_type}/{resource_id}"
            resource['id'] = resource_id
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.put(
                    url,
                    json=resource,
                    headers=self.headers
                )
                response.raise_for_status()
                return response.json()
                
        except httpx.HTTPStatusError as e:
            logger.error(f"FHIR update HTTP error: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"FHIR update error: {str(e)}")
            return None
    
    async def delete(self, resource_type: str, resource_id: str) -> bool:
        """Delete a FHIR resource"""
        try:
            url = f"{self.base_url}/{resource_type}/{resource_id}"
            
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.delete(url, headers=self.headers)
                response.raise_for_status()
                return True
                
        except Exception as e:
            logger.error(f"FHIR delete error: {str(e)}")
            return False

# Create singleton instance
fhir_service = FHIRService()

# Improved standalone functions
async def get_patient_by_email(email: str) -> Optional[Dict]:
    """Get patient by email using proper FHIR search"""
    result = await fhir_service.search('Patient', {'email': email})
    return result

async def get_patient_by_phone(phone_number: str) -> Optional[Dict]:
    """Get patient by phone number with improved search"""
    # Clean the phone number
    clean_phone = ''.join(c for c in phone_number if c.isdigit())
    
    # FHIR search for telecom uses 'value' parameter
    search_params = [
        {'telecom': phone_number},
        {'telecom': clean_phone},
        {'phone': phone_number},  # Some servers support this
        {'phone': clean_phone}
    ]
    
    for params in search_params:
        result = await fhir_service.search('Patient', params)
        if result and 'entry' in result and result['entry']:
            logger.info(f"Found patient with phone search params: {params}")
            return result
    
    # Fallback for demo - log this
    logger.warning(f"No patient found for phone {phone_number}, returning first patient for demo")
    return await fhir_service.search('Patient', {'_count': '1'})

async def get_patient_allergies(patient_id: str) -> Optional[Dict]:
    """Get patient allergies with proper patient reference"""
    return await fhir_service.search('AllergyIntolerance', {'patient': f'Patient/{patient_id}'})

async def get_patient_conditions(patient_id: str) -> Optional[Dict]:
    """Get patient conditions"""
    return await fhir_service.search('Condition', {'patient': f'Patient/{patient_id}'})

async def get_patient_immunizations(patient_id: str) -> Optional[Dict]:
    """Get patient immunizations"""
    return await fhir_service.search('Immunization', {'patient': f'Patient/{patient_id}'})

async def get_patient_medications(patient_id: str) -> Optional[Dict]:
    """Get patient medications"""
    return await fhir_service.search('MedicationRequest', {
        'patient': f'Patient/{patient_id}',
        'status': 'active'
    })

async def get_practitioner_for_patient(patient_id: str) -> Optional[Dict]:
    """Get practitioners associated with a patient"""
    # This might need to search through appointments or care team
    appointments = await fhir_service.search('Appointment', {
        'patient': f'Patient/{patient_id}',
        'status': 'booked,fulfilled'
    })
    
    if not appointments or 'entry' not in appointments:
        return None
    
    # Extract unique practitioners
    practitioners = set()
    for entry in appointments['entry']:
        for participant in entry.get('resource', {}).get('participant', []):
            actor = participant.get('actor', {})
            if 'Practitioner' in actor.get('reference', ''):
                practitioners.add(actor['reference'])
    
    return {'practitioners': list(practitioners)}

async def get_available_practitioners() -> Optional[Dict]:
    """Get all available practitioners"""
    return await fhir_service.search('Practitioner', {'active': 'true'})

async def get_practitioner(practitioner_id: str) -> Optional[Dict]:
    """Get specific practitioner"""
    return await fhir_service.read('Practitioner', practitioner_id)

async def get_patient_procedures(patient_id: str) -> Optional[Dict]:
    """Get patient procedures"""
    return await fhir_service.search('Procedure', {
        'patient': f'Patient/{patient_id}',
        '_sort': '-date'
    })

async def get_complete_medical_record(patient_id: str) -> Dict[str, Any]:
    """Get complete medical record with error handling"""
    record = {}
    
    # Fetch all data concurrently
    try:
        results = await asyncio.gather(
            get_patient_allergies(patient_id),
            get_patient_conditions(patient_id),
            get_patient_immunizations(patient_id),
            get_patient_medications(patient_id),
            get_patient_procedures(patient_id),
            return_exceptions=True
        )
        
        record['allergies'] = results[0] if not isinstance(results[0], Exception) else None
        record['conditions'] = results[1] if not isinstance(results[1], Exception) else None
        record['immunizations'] = results[2] if not isinstance(results[2], Exception) else None
        record['medications'] = results[3] if not isinstance(results[3], Exception) else None
        record['procedures'] = results[4] if not isinstance(results[4], Exception) else None
        
    except Exception as e:
        logger.error(f"Error fetching complete medical record: {str(e)}")
    
    return record

async def get_user_appointments(patient_id: str, timezone: str = 'America/New_York') -> Optional[Dict]:
    """Get user appointments with status filter"""
    from datetime import datetime
    
    return await fhir_service.search('Appointment', {
        'patient': f'Patient/{patient_id}',
        'date': f'ge{datetime.now().isoformat()}',
        'status': 'booked,arrived,fulfilled',
        '_sort': 'date'
    })

async def get_user_appointments_direct(patient_id: str, timezone: str = 'America/New_York') -> Optional[Dict]:
    """Alias for get_user_appointments"""
    return await get_user_appointments(patient_id, timezone)

async def get_user_appointments_formatted(patient_id: str, timezone: str = 'America/New_York') -> List[Dict]:
    """Get formatted appointment list"""
    appointments = await get_user_appointments(patient_id, timezone)
    if not appointments or 'entry' not in appointments:
        return []
    
    formatted = []
    for entry in appointments['entry']:
        appointment = entry.get('resource', {})
        
        # Extract practitioner reference
        practitioner_ref = None
        for participant in appointment.get('participant', []):
            actor = participant.get('actor', {})
            if 'Practitioner' in actor.get('reference', ''):
                practitioner_ref = actor['reference'].split('/')[-1]
                break
        
        formatted.append({
            'id': appointment.get('id'),
            'start': appointment.get('start'),
            'end': appointment.get('end'),
            'status': appointment.get('status'),
            'description': appointment.get('description', ''),
            'practitioner': practitioner_ref
        })
    
    return formatted

async def search_available_slots() -> Optional[Dict]:
    """Search for available appointment slots"""
    from datetime import datetime, timedelta
    
    # Search for free slots in the next 30 days
    start_date = datetime.now().isoformat()
    end_date = (datetime.now() + timedelta(days=30)).isoformat()
    
    return await fhir_service.search('Slot', {
        'status': 'free',
        'start': f'ge{start_date}',
        'start': f'le{end_date}',
        '_sort': 'start'
    })

async def get_patient_appointments(patient_id: str) -> Optional[Dict]:
    """Alias for get_user_appointments"""
    return await get_user_appointments(patient_id)

# Add missing import at the top
import asyncio

================
File: intent_service.py
================
from collections.abc import Coroutine
import logging
import json
import re
from datetime import datetime
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional

from openai import AsyncOpenAI
from django.conf import settings
from asgiref.sync import sync_to_async

# FHIR and Language Imports
from fhirclient.client import FHIRClient
from chatbot.views.config import config  # Assuming this contains FHIR server settings
from chatbot.views.services.language_service import LanguageService

# Load your OpenAI model name from a constants file or environment
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
logger.debug("Intent service module loaded")
# Global fallback cache for GPT fallback responses (to reduce redundant API calls)
FALLBACK_CACHE = {}

# ============================================
#   FHIR Client Initialization (async)
# ============================================
#figure out if any of this shit is necessary and wht it is exactly
def get_async_fhir_client():
    """
    Asynchronously get a configured FHIR client instance.
    Ensures that FHIR server methods are available as async functions.
    """
    settings_dict = {
        'app_id': 'anna_chatbot',
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        fhir_client = FHIRClient(settings=settings_dict)
        # Convert blocking methods to async versions
        fhir_client.server.request_json = sync_to_async(fhir_client.server.request_json, thread_sensitive=False)
        fhir_client.server.update = sync_to_async(fhir_client.server.update, thread_sensitive=False)
        fhir_client.server.create = sync_to_async(fhir_client.server.create, thread_sensitive=False)
        fhir_client.server.delete = sync_to_async(fhir_client.server.delete, thread_sensitive=False)
        fhir_client.server.perform_request = sync_to_async(fhir_client.server.perform_request, thread_sensitive=False)
        logger.info("Asynchronous FHIR client initialized successfully")
        return fhir_client
    except Exception as e:
        logger.error(f"Failed to initialize asynchronous FHIR client: {e}")
        raise

# ============================================
#   Service Initialization
# ============================================

from ...utils.openai_manager import openai_manager
language_service = LanguageService()

# ============================================
#   Intent Enumeration and Data Class
# ============================================

class Intent(Enum):
    SET_APPOINTMENT = 'set_appointment'
    SHOW_APPOINTMENTS = 'show_appointments'
    MEDICAL_RECORD_QUERY = 'medical_record_query'
    MEDICAL_INFO_QUERY = 'medical_info_query'
    SYMPTOM_REPORT = 'symptom_report'
    LAB_RESULTS_QUERY = 'lab_results_query'
    LAB_RESULTS = 'lab_results'
    CAPABILITIES = 'capabilities'
    EXPLANATION_QUERY = 'explanation_query'
    EMAIL_VERIFICATION = 'email_verification'
    RESET_CONTEXT = 'reset_context'
    DELETE_CONTEXT = 'delete_context'
    GREETING = 'greeting'
    CONDITION_QUERY = 'condition_query'
    MENTAL_HEALTH_QUERY = 'mental_health_query'
    SCREENING = 'screening'
    ISSUE_REPORT = 'issue_report'  # New intent for any user-reported health issue
    UNKNOWN = 'unknown'

@dataclass
class IntentData:
    """
    A structured container for intent detection results.
    """
    intent: Intent
    confidence: float
    entities: Dict[str, str]
    original_text: str = None
    context_type: str = None

# ============================================
#   Pre-compiled Regex Patterns
# ============================================

# --- Appointment Patterns ---
APPOINTMENT_KEYWORDS = (
    r"(?:book|schedule|make|arrange|reserve|organize|plan|fix|request|create|initiate|set(?:\s*up)?|secure|hold|slot|enroll|register|put\s+down)"
)
APPOINTMENT_PATTERNS_RAW = [
    fr"{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"(?:i|we|would like to|i'd like to|i need to|i want to)\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"need\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"want\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)"
]
COMPILED_APPOINTMENT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_PATTERNS_RAW]

APPOINTMENT_VIEW_PATTERNS_RAW = [
    r'(?:show|view|see|check|list|get|display|pull\s+up|fetch|retrieve)\s+(?:my|all|any|upcoming)?\s+appointments?',
    r'what\s+(?:appointments?|bookings?)\s+do\s+i\s+have(?:\s+scheduled)?',
    r'(?:my|all|upcoming|scheduled)\s+appointments?'
]
COMPILED_APPOINTMENT_VIEW_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_VIEW_PATTERNS_RAW]

# --- Symptom Patterns ---
SYMPTOM_PATTERNS_RAW = {
    'pain': [r'hurts?', r'aching?', r'pain(?:ful)?', r'sore', r'tender', r'burning',
             r'sharp\s+pain', r'dull\s+pain', r'throbbing', r'joint', r'joints',
             r'ankle', r'elbow', r'knee', r'leg\s+pain', r'foot\s+pain', r'back\s+ache'],
    'respiratory': [r'cough(?:ing)?', r'breathing', r'short\s+of\s+breath', r'wheez(?:e|ing)',
                    r'chest\s+tight(?:ness)?', r"can't\s+breathe", r'difficulty\s+breathing',
                    r'asthma', r'lung\s+pain'],
    'gastrointestinal': [r'stomach', r'nausea(?:ted)?', r'vomiting', r'diarrhea', r'constipation',
                         r'abdominal\s+pain', r'indigestion', r'cramps?', r'gastro'],
    'neurological': [r'headache', r'dizzy', r'migraine', r'faint(?:ing)?', r'numbness',
                     r'tingling', r'balance', r'vision', r'hearing', r'seizure', r'epilepsy'],
    'general': [r'fever(?:ish)?', r'tired(?:ness)?', r'fatigue', r'weak(?:ness)?', r'exhausted',
                r'not\s+feeling\s+well', r'unwell', r'sick', r'ill'],
    'musculoskeletal': [r'joint\s+pain', r'muscle\s+pain', r'stiffness', r'swelling',
                        r'limited\s+movement', r'difficulty\s+moving', r'arthritis',
                        r'sprain', r'strain', r'inflammation']
}
COMPILED_SYMPTOM_PATTERNS = {}
for category, patterns in SYMPTOM_PATTERNS_RAW.items():
    COMPILED_SYMPTOM_PATTERNS[category] = [re.compile(p, flags=re.IGNORECASE) for p in patterns]

# --- Medical Record Patterns ---
MEDICAL_RECORD_PATTERNS_RAW = [
    r'(?:show|view|see|access|get|pull\s+up|retrieve)\s+(?:my|all)?\s+(?:medical|health)?\s+records?',
    r'(?:my|full|complete)\s+(?:medical|health)?\s+records?',
    r'history',
    r'(?:my|the)\s+(?:chart|ehr|patient\s*portal|medical\s*file)'
]
COMPILED_MEDICAL_RECORD_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_RECORD_PATTERNS_RAW]

# --- Medical Info Patterns ---
MEDICAL_INFO_PATTERNS_RAW = [
    r'what\s+is', r'tell\s+me\s+about', r'explain', r'information\s+about',
    r'learn\s+about', r'understand', r'how\s+do\s+i\s+know\s+if', r'how\s+can\s+i\s+tell\s+if',
    r'what\s+are\s+the\s+signs\s+of', r'how\s+do\s+you\s+know\s+if', r'how\s+to\s+tell\s+if',
    r'can\s+you\s+provide\s+info', r'give\s+me\s+information', r'differences?\s+between'
]
COMPILED_MEDICAL_INFO_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_INFO_PATTERNS_RAW]

# --- Mental Health Patterns ---
MENTAL_HEALTH_PATTERNS_RAW = [
    r'depression', r'anxiety', r'(?:mental|emotional)\s+health', r'sad(?:ness)?',
    r'unhappy', r'stress(?:ed)?', r'mood', r'therap(?:y|ist)', r'psychological',
    r'crying', r'hopeless(?:ness)?', r'worthless(?:ness)?', r'panic', r'insomnia',
    r'burnout', r'trauma', r'ptsd', r'bipolar', r'schizophrenia', r'suicid(?:e|al)',
    r'self[-\s]*harm', r'counseling'
]
COMPILED_MENTAL_HEALTH_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MENTAL_HEALTH_PATTERNS_RAW]

# --- Condition Patterns ---
CONDITION_PATTERNS_RAW = [
    r'(?:my|current|existing)\s+conditions?', r'medical\s+conditions?',
    r'what\s+(?:conditions?|illnesses?)\s+do\s+i\s+have', r'what\s+am\s+i\s+diagnosed\s+with',
    r'health\s+conditions?', r'ongoing\s+diagnoses?', r'active\s+conditions?'
]
COMPILED_CONDITION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CONDITION_PATTERNS_RAW]

# --- Screening Patterns ---
# Only match screening intent in the context of a response to a screening reminder
# Rather than detecting general questions about screenings/health checks
SCREENING_PATTERNS_RAW = [
    r'screening\s+reminder', r'responding\s+to\s+screening',
    r'about\s+(?:the|my|your)\s+screening\s+(?:reminder|notification|message)',
    r'received\s+(?:a|the)\s+screening'
]
COMPILED_SCREENING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in SCREENING_PATTERNS_RAW]

# --- Lab Result Patterns ---
LAB_RESULT_PATTERNS_RAW = [
    r".*\b(?:cholesterol|glucose|hdl|ldl|triglycerides|potassium|sodium|chloride|bicarbonate|bun|creatinine|calcium|protein|albumin|bilirubin|ast|alt|alkaline\s+phosphatase|ggt|tsh|t4|t3|cortisol|testosterone|estradiol|progesterone|psa|uric\s+acid|crp|esr|inr|pt|aptt|d-dimer|troponin|ck|ldh|amylase|lipase|magnesium|phosphorus|iron|ferritin|transferrin|vitamin\s?b12|folate|vitamin\s?d|platelets|hemoglobin|leukocytes).*(?:high|low|normal|level|range|result|test|value|number).*",
    r".*\bwhat.*\b(?:do|does|about|concerning).*\b(?:my|these|those)?.*\b(?:test|result|level|value|number).*",
    r".*\b(?:my|the|latest|recent|previous|past).*\b(?:test|result|level|value|number).*\b(?:high|low|normal|range).*",
    r".*\b(?:test|result|level|value|number).*(?:okay|ok|good|bad|normal|abnormal|concerning|worrying).*",
    r"(?:what|how|why|when|where|which)\s+(?:is|are|do|does|can|could|should|would)?\s+.*?\s+(?:about|concerning|regarding|related\s+to|pertaining\s+to|mean|levels?|values?|numbers?|results?|tests?|readings?|measurements?)\b",
    r".*\b(?:lab|test|result|level|value|number)\b.*(?:from|on|in|at|for|during)\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|\d{1,2}/\d{1,2}/\d{4}|\d{4}-\d{2}-\d{2})",
    r"(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+\d{1,2}(?:st|nd|rd|th)?(?:,?|\s+in)?\s*(?:\d{4}|\d{2})?",
    r"\d{4}-\d{2}-\d{2}",
    r"\d{1,2}/\d{1,2}/\d{2,4}",
]
COMPILED_LAB_RESULT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in LAB_RESULT_PATTERNS_RAW]

ADDITIONAL_LAB_PATTERNS_RAW = [
    r".*(?:lab|labs?|test|tests?)\s+results?.*",
    r".*(?:blood|urine)\s+test.*",
    r".*my\s+(?:recent|latest|last)\s+results.*",
    r".*results?\s+for.*",
    r".*my\s+levels.*"
]
COMPILED_ADDITIONAL_LAB_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in ADDITIONAL_LAB_PATTERNS_RAW]

# --- Capability Patterns ---
CAPABILITY_PATTERNS_RAW = [
    r"(?:what\s+can\s+you\s+do|what\s+are\s+your\s+capabilities|what\s+do\s+you\s+do|help|how\s+can\s+you\s+help\s+me|what\s+are\s+you\s+able\s+to\s+do|show\s+me\s+what\s+you\s+can\s+do|list\s+capabilities|list\s+functions|what\s+features\s+do\s+you\s+have)"
]
COMPILED_CAPABILITY_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CAPABILITY_PATTERNS_RAW]

# --- Explanation Patterns ---
EXPLANATION_PATTERNS_RAW = [
    r"(?:how\s+do\s+you\s+explain|can\s+you\s+explain|what\s+does\s+.*?\s+mean|explain\s+.*?\s+to\s+me|help\s+me\s+understand|what\s+is\s+the\s+meaning\s+of|could\s+you\s+clarify|what\s+are|how\s+do\s+.*?\s+work|explain\s+the\s+difference)"
]
COMPILED_EXPLANATION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in EXPLANATION_PATTERNS_RAW]

# --- Greeting Patterns ---
GREETING_PATTERNS_RAW = [
    r'\b(?:hi|hello|hey|hii|heyy|yo|hiya|greetings?|wassup|what\'s\s*up|sup|good\s+(?:morning|afternoon|evening|day))\b'
]
COMPILED_GREETING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in GREETING_PATTERNS_RAW]

# ============================================
#   Helper Function to Extract Medical Topic
# ============================================
def extract_medical_topic(message: str) -> str:
    """
    Removes common prompt phrases so that the core topic is isolated.
    """
    patterns_to_remove = [
        'what is', 'tell me about', 'explain', 'information about',
        'learn about', 'understand', 'differences? between'
    ]
    cleaned_message = message
    for pattern in patterns_to_remove:
        cleaned_message = re.sub(pattern, '', cleaned_message, flags=re.IGNORECASE).strip()
    return cleaned_message

# ============================================
#   Main Intent Detection Function (Improved)
# ============================================
async def detect_intent(
    user_input: str,
    conversation_context: Optional[dict] = None,
    last_intent: Optional[str] = None
) -> Dict[str, any]:
    """
    Determines the user's intent using a layered approach:
      1. Special-case handling (digit input, email verification, context deletion/reset)
      2. Regex-based matching using precompiled patterns.
      3. Context-aware handling for short or anaphoric queries.
      4. A GPT fallback with few-shot examples and caching.
    """
    logger.info("=== STARTING INTENT DETECTION ===")
    logger.info(f"Input message: {user_input!r}")

    if not user_input or not isinstance(user_input, str):
        logger.error("Invalid user input: either None or not a string.")
        return {
            "intent": Intent.UNKNOWN.value,
            "confidence": 0.1,
            "entities": {},
            "original_text": str(user_input)
        }

    original_message = user_input.lower().strip()
    logger.debug(f"Processed message: {original_message!r}")

    # --- 1. Special Cases ---
    # 1a. Digit input during booking state
    if conversation_context and original_message.isdigit() and conversation_context.get('booking_state'):
        logger.info("Special case: Digit input during booking state detected.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 1.0,
            "entities": {"selection": original_message, "original_text": user_input, "context": "booking_flow"}
        }

    # 1b. Email Verification
    try:
        email_pattern = re.compile(r'[\w\.-]+@[\w\.-]+\.\w+', flags=re.IGNORECASE)
        if '@' in original_message:
            match_result = email_pattern.match(original_message)
            if match_result:
                matched_email = match_result.group(0)
                logger.info("Special case: Email verification match detected.")
                return {
                    "intent": Intent.EMAIL_VERIFICATION.value,
                    "confidence": 1.0,
                    "entities": {"email": matched_email, "original_text": user_input,
                                 "action": "verify", "context_type": "authentication"}
                }
    except Exception as e:
        logger.error(f"Error in email verification block: {e}")

    # 1c. Delete Context
    delete_commands = ["delete context", "clear context", "reset all", "delete contxt", "remove context", "erase context", "forget everything"]
    if any(cmd in original_message for cmd in delete_commands):
        logger.info("Special case: Delete context command recognized.")
        return {
            "intent": Intent.DELETE_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"action": "delete", "topic": "system", "original_text": user_input}
        }

    # 1d. Reset Context
    reset_patterns = [re.compile(p, flags=re.IGNORECASE) for p in [
        r"(?:i\s+)?(?:am\s+)?not\s+talking\s+about",
        r"(?:i\s+)?don'?t\s+mean",
        r"different\s+(?:topic|subject)",
        r"something\s+else",
        r"forget\s+the\s+previous\s+topic"
    ]]
    if any(pattern.search(original_message) for pattern in reset_patterns):
        excluded_topic_match = re.search(r"(?:about|mean)\s+(\w+)", original_message)
        excluded_topic = excluded_topic_match.group(1) if excluded_topic_match else None
        logger.info("Special case: Reset context command recognized.")
        return {
            "intent": Intent.RESET_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"original_text": user_input, "excluded_topic": excluded_topic}
        }

    # --- 2. Regex-Based Detection ---
    # 2.1 Greeting
    if any(pattern.search(original_message) for pattern in COMPILED_GREETING_PATTERNS):
        logger.info("Regex detection: Greeting pattern matched.")
        return {
            "intent": Intent.GREETING.value,
            "confidence": 1.0,
            "entities": {},
            "original_text": user_input
        }

    # 2.2 Appointment Booking
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_PATTERNS):
        logger.info("Regex detection: Appointment booking pattern matched.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 0.95,
            "entities": {"topic": original_message, "original_text": user_input}
        }

    # 2.3 Appointment Viewing
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_VIEW_PATTERNS):
        logger.info("Regex detection: Appointment viewing pattern matched.")
        return {
            "intent": Intent.SHOW_APPOINTMENTS.value,
            "confidence": 0.95,
            "entities": {"action": "view", "original_text": user_input}
        }

    # 2.4 Health Issue Detection (combines the new issue_report intent with traditional symptom reporting)
    # Check for general health issue indicators first 
    health_terms = [
        r'\b(?:symptom|feeling|suffering|experiencing|having)\b',
        r'\b(?:pain|ache|sore|hurt|discomfort)\b',
        r'\b(?:sick|ill|unwell|not well)\b',
        r'(?:problem with|issue with|trouble with)',
        r'\b(?:diagnosed|condition)\b',
        r'(?:can\'t sleep|insomnia|tired|fatigue)',
        r'\b(?:cough|fever|rash|dizziness|swelling)\b'
    ]
    
    is_general_health_issue = False
    for pattern in health_terms:
        if re.search(pattern, original_message, re.IGNORECASE):
            is_general_health_issue = True
            logger.info(f"Detected general health issue pattern: {pattern}")
            break
    
    # If it's a general health issue but not matching specific symptom categories,
    # use the new issue_report intent
    if is_general_health_issue:
        # Extract a symptom keyphrase if possible (this will be None if no service exists yet)
        symptom_keyphrase = None
        # We can't directly call the medical_advice_service here since it's not available
        # The actual keyphrase extraction will happen in the handler
        
        logger.info(f"Regex detection: General health issue detected, using issue_report intent.")
        return {
            "intent": Intent.ISSUE_REPORT.value,
            "confidence": 0.95,
            "entities": {
                "symptom_description": original_message, 
                "original_text": user_input,
                "symptom_keyphrase": symptom_keyphrase  # Will be None here, extracted later in handler
            }
        }
    
    # Fall back to traditional symptom category detection for specific symptoms
    for category, patterns in COMPILED_SYMPTOM_PATTERNS.items():
        if any(pattern.search(original_message) for pattern in patterns):
            logger.info(f"Regex detection: Symptom report pattern matched for category {category}.")
            return {
                "intent": Intent.SYMPTOM_REPORT.value,
                "confidence": 0.95,
                "entities": {"symptom_category": category, "symptom_description": original_message, "original_text": user_input}
            }

    # 2.5 Anaphora / Short Query Handling
    anaphora_patterns = {
        'it': re.compile(r'\b(it|this|that|these|those)\b', flags=re.IGNORECASE),
        'levels': re.compile(r'\b(levels|values|numbers|results)\b', flags=re.IGNORECASE),
        'change': re.compile(r'\b(increase|decrease|improve|change|modify)\b', flags=re.IGNORECASE)
    }
    
    # Debug logging for follow-up detection
    logger.debug(f"Checking for anaphora in: {original_message}")
    if conversation_context:
        current_topic_info = conversation_context.get('current_topic', {})
        logger.debug(f"With context: {current_topic_info}")
        logger.debug(f"Context type: {type(current_topic_info)}")
        logger.debug(f"Full conversation context: {conversation_context}")
    else:
        logger.debug("No conversation context provided")
        
    # Track which pattern matched for better debugging
    matched_pattern = None
    for pattern_name, pattern in anaphora_patterns.items():
        if pattern.search(original_message):
            matched_pattern = pattern_name
            logger.debug(f"Matched anaphora pattern: {pattern_name}")
            break
    
    if any(pattern.search(original_message) for pattern in anaphora_patterns.values()) and conversation_context and conversation_context.get('current_topic'):
        current_topic = conversation_context['current_topic']
        logger.debug(f"Current topic: {current_topic}")
        logger.debug(f"Current topic type: {type(current_topic)}")
        if isinstance(current_topic, dict):
            logger.debug(f"Topic name: {current_topic.get('name')}")
            logger.debug(f"Topic type: {current_topic.get('type')}")
        
        # Map the current topic type to the appropriate intent
        topic_type = current_topic.get('type', '')
        logger.debug(f"Topic type: {topic_type}")
        
        # Handle different types of follow-up questions based on the current topic
        if topic_type == 'lab_result' or topic_type == 'lab_results' or topic_type == 'lab_results_query':
            logger.info("Anaphora resolution: Lab result context detected in conversation context.")
            logger.debug("Identified as lab result follow-up")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "reference_range": current_topic.get('reference_range'),
                             "last_value": current_topic.get('last_value'), "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'symptom_report' or topic_type == 'symptoms':
            logger.info("Anaphora resolution: Symptom context detected in conversation context.")
            logger.debug("Identified as symptom follow-up")
            return {
                "intent": Intent.SYMPTOM_REPORT.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'medication' or topic_type == 'medications':
            logger.info("Anaphora resolution: Medication context detected in conversation context.")
            print("DEBUG-INTENT-FOLLOWUP-8: Identified as medication follow-up")
            return {
                "intent": Intent.MEDICAL_INFO_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'appointment' or topic_type == 'scheduling':
            logger.info("Anaphora resolution: Appointment context detected in conversation context.")
            print("DEBUG-INTENT-FOLLOWUP-9: Identified as appointment follow-up")
            return {
                "intent": Intent.SHOW_APPOINTMENTS.value, 
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }
        elif topic_type == 'explanation':
            logger.info(f"Anaphora resolution: Educational explanation context detected for topic: {current_topic.get('name')}")
            logger.debug(f"Identified as explanation follow-up for {current_topic.get('name')}")
            return {
                "intent": Intent.EXPLANATION_QUERY.value,
                "confidence": 0.95,
                "entities": {
                    "action": "followup", 
                    "topic": current_topic.get('name'),
                    "original_text": user_input, 
                    "context_type": "anaphora_resolution"
                }
            }
        else:
            # General follow-up for other topics
            logger.info(f"Anaphora resolution: General follow-up to topic {topic_type}")
            logger.debug(f"General follow-up to topic {topic_type}")
            # Default to medical info query for general follow-ups
            return {
                "intent": Intent.MEDICAL_INFO_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name', 'general'),
                             "original_text": user_input, "context_type": "anaphora_resolution"}
            }

    # 2.6 Additional AI-based short query check for very short messages (<= 5 words)
    if len(original_message.split()) <= 5:
        logger.debug(f"Detected short query: {original_message}")
        # If we have a current topic, this is likely a follow-up
        if conversation_context and conversation_context.get('current_topic'):
            current_topic = conversation_context.get('current_topic', {})
            logger.debug(f"Short query with current topic: {current_topic}")
            
            # If the message is really short (1-2 words) and doesn't contain a question mark,
            # it's very likely a follow-up to the current topic
            if len(original_message.split()) <= 2 and '?' not in original_message:
                topic_type = current_topic.get('type', '')
                topic_name = current_topic.get('name', '')
                print(f"DEBUG-SHORT-QUERY-3: Very short query detected, treating as direct follow-up to {topic_type}")
                
                # Map to appropriate intent based on current topic
                if topic_type in ['lab_result', 'lab_results', 'lab_results_query']:
                    return {
                        "intent": Intent.LAB_RESULTS_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['symptom_report', 'symptoms']:
                    return {
                        "intent": Intent.SYMPTOM_REPORT.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['medication', 'medications']:
                    return {
                        "intent": Intent.MEDICAL_INFO_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
                elif topic_type in ['explanation', 'screening', 'prevention']:
                    return {
                        "intent": Intent.EXPLANATION_QUERY.value,
                        "confidence": 0.95,
                        "entities": {"action": "followup", "topic": topic_name, "original_text": user_input, 
                                    "context_type": "short_query"}
                    }
        
        context_prompt = f"\nPrevious topic: {conversation_context['current_topic'].get('name')}" if conversation_context and conversation_context.get('current_topic') else ""
        cache_key = f"short_query::{original_message}{context_prompt}"
        if cache_key in FALLBACK_CACHE:
            logger.info("Using cached GPT fallback for short query.")
            return FALLBACK_CACHE[cache_key]
        try:
            response = await openai_manager.chat_completion(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": (
                        "You are analyzing if this short user message is a follow-up to a previous topic or "
                        "a standalone query. Return a JSON object:\n"
                        "{\n"
                        '  "is_followup": boolean,\n'
                        '  "confidence": float,\n'
                        '  "related_intent": "lab_results_query" or "show_appointments" or "explanation_query" or ...,\n'
                        '  "reasoning": "string"\n'
                        "}"
                        "\n\nIMPORTANT: If the previous topic is about a medical procedure, screening, or health information, "
                        "use 'explanation_query' as the related_intent. Examples of explanation topics include colonoscopy, "
                        "mammogram, blood pressure, or any medical test or procedure."
                    )},
                    {"role": "user", "content": f"Message: {user_input}{context_prompt}"}
                ],
                temperature=0.1
            )
            if isinstance(response, Coroutine):
                logger.debug("GPT response is a coroutine, forcing await.")
                response = await response
            analysis = json.loads(response.choices[0].message.content)
            if analysis.get('is_followup') is True and analysis.get('confidence', 0) > 0.7:
                related_intent = analysis.get('related_intent')
                if related_intent == 'lab_results_query':
                    result = {
                        "intent": Intent.LAB_RESULTS_QUERY.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "followup", "topic": conversation_context.get('current_topic', {}).get('name', 'unknown'),
                                     "original_text": user_input, "context_type": "semantic_analysis"}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
                elif related_intent == 'show_appointments':
                    result = {
                        "intent": Intent.SHOW_APPOINTMENTS.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "view", "original_text": user_input}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
                elif related_intent == 'explanation_query':
                    # Handle follow-up questions about medical explanation topics
                    topic_name = conversation_context.get('current_topic', {}).get('name', 'unknown')
                    result = {
                        "intent": Intent.EXPLANATION_QUERY.value,
                        "confidence": analysis['confidence'],
                        "entities": {
                            "action": "followup",
                            "topic": topic_name,
                            "original_text": user_input,
                            "context_type": "semantic_analysis"
                        }
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
        except Exception as e:
            logger.error(f"Error in AI-enhanced short query analysis: {e}")

    # 2.7 Lab Result Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_LAB_RESULT_PATTERNS):
        logger.info("Regex detection: Lab result pattern matched.")
        return {
            "intent": Intent.LAB_RESULTS_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": original_message, "original_text": user_input}
        }
    if any(pattern.search(original_message) for pattern in COMPILED_ADDITIONAL_LAB_PATTERNS):
        if re.search(r"(?:show|get|view|see)\s+.*results.*", original_message):
            logger.info("Regex detection: Additional lab pattern matched for viewing results.")
            return {
                "intent": Intent.LAB_RESULTS.value,
                "confidence": 0.9,
                "entities": {"action": "view", "original_text": user_input}
            }
        else:
            logger.info("Regex detection: Additional lab pattern matched for querying results.")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "query", "topic": original_message, "original_text": user_input}
            }

    # 2.8 Screening Patterns - check for sleep questions first and redirect them
    # Check if message is about sleep (redirect to medical_info_query instead)
    sleep_pattern = re.compile(r'sleep|rest|tired|insomnia|how\s+much\s+sleep|hours\s+of\s+sleep', re.IGNORECASE)
    if sleep_pattern.search(original_message):
        logger.info("Sleep question detected, routing to medical_info_query.")
        return {
            "intent": Intent.MEDICAL_INFO_QUERY.value, 
            "confidence": 0.95,
            "entities": {"topic": "sleep health", "original_text": user_input}
        }
        
    # Only match screening patterns if they're truly about screening reminders
    if any(pattern.search(original_message) for pattern in COMPILED_SCREENING_PATTERNS):
        logger.info("Regex detection: Screening pattern matched.")
        return {
            "intent": Intent.SCREENING.value,
            "confidence": 0.9,
            "entities": {"action": "respond", "original_text": user_input}
        }

    # 2.9 Medical Record Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_RECORD_PATTERNS):
        logger.info("Regex detection: Medical record pattern matched.")
        return {
            "intent": Intent.MEDICAL_RECORD_QUERY.value,
            "confidence": 0.9,
            "entities": {"record_type": "full", "original_text": user_input}
        }

    # 2.10 Medical Info Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_INFO_PATTERNS):
        topic_cleaned = extract_medical_topic(original_message)
        logger.info("Regex detection: Medical info pattern matched.")
        return {
            "intent": Intent.MEDICAL_INFO_QUERY.value,
            "confidence": 0.85,
            "entities": {"topic": topic_cleaned, "original_text": user_input}
        }

    # 2.11 Mental Health Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MENTAL_HEALTH_PATTERNS):
        logger.info("Regex detection: Mental health pattern matched.")
        return {
            "intent": Intent.MENTAL_HEALTH_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "mental_health", "original_text": user_input}
        }

    # 2.12 Condition Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CONDITION_PATTERNS):
        logger.info("Regex detection: Condition pattern matched.")
        return {
            "intent": Intent.CONDITION_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "conditions", "original_text": user_input}
        }

    # 2.13 Capability Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CAPABILITY_PATTERNS):
        logger.info("Regex detection: Capability pattern matched.")
        return {
            "intent": Intent.CAPABILITIES.value,
            "confidence": 1.0,
            "entities": {"topic": "capabilities", "original_text": user_input}
        }

    # 2.14 Explanation Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_EXPLANATION_PATTERNS):
        logger.info("Regex detection: Explanation pattern matched.")
        return {
            "intent": Intent.EXPLANATION_QUERY.value,
            "confidence": 1.0,
            "entities": {"topic": user_input, "original_text": user_input}
        }

    # --- 3. GPT Fallback ---
    # Add examples to the system prompt instead of as separate messages
    fallback_prompt = """
You are a powerful medical chatbot assistant. Classify the user's intent from this list:
- set_appointment
- show_appointments
- medical_record_query
- medical_info_query
- symptom_report
- issue_report
- lab_results
- lab_results_query
- capabilities
- explanation_query
- email_verification
- reset_context
- delete_context
- greeting
- condition_query
- mental_health_query
- screening
- unknown

IMPORTANT: Use 'issue_report' for any health issue query that describes a symptom, problem or condition the user is experiencing, especially when they're looking for advice on what to do.

Examples:
- "I've been having trouble sleeping" → issue_report
- "My back has been hurting for days" → issue_report
- "I have a persistent cough that won't go away" → issue_report
- "I'm experiencing ringing in my ears" → issue_report
- "My vision has been blurry" → issue_report

Here are more examples with their expected classifications:

User: "i want to set an appointment"
Expected response: {"intent": "set_appointment", "confidence": 0.95, "entities": {}}

User: "I need to schedule a check-up"
Expected response: {"intent": "set_appointment", "confidence": 0.95, "entities": {}}

User: "What are my upcoming appointments?"
Expected response: {"intent": "show_appointments", "confidence": 0.9, "entities": {}}

User: "What was my potassium level on my last lab test?"
Expected response: {"intent": "lab_results_query", "confidence": 0.85, "entities": {"test_name": "potassium"}}

User: "Can you show me my allergies?"
Expected response: {"intent": "medical_record_query", "confidence": 0.9, "entities": {"record_type": "allergies"}}

User: "hello"
Expected response: {"intent": "greeting", "confidence": 1.0, "entities": {}}

User: "I feel depressed and can't sleep"
Expected response: {"intent": "mental_health_query", "confidence": 0.9, "entities": {"topic": "mental_health"}}

User: "I want to see my lab results from last month"
Expected response: {"intent": "lab_results_query", "confidence": 0.9, "entities": {"action": "query"}}

User: "Let's delete context now"
Expected response: {"intent": "delete_context", "confidence": 1.0, "entities": {"action": "delete"}}

User: "I have a headache and a fever"
Expected response: {"intent": "symptom_report", "confidence": 0.95, "entities": {"symptom_category": "general"}}

User: "What screenings should I get?"
Expected response: {"intent": "screening", "confidence": 0.9, "entities": {"action": "recommend"}}

User: "I've been having trouble sleeping for a few weeks now"
Expected response: {"intent": "issue_report", "confidence": 0.95, "entities": {"symptom_description": "I've been having trouble sleeping for a few weeks now"}}

User: "My back has been hurting for days"
Expected response: {"intent": "issue_report", "confidence": 0.95, "entities": {"symptom_description": "My back has been hurting for days"}}

User: "Why do I need a colonoscopy?"
Expected response: {"intent": "explanation_query", "confidence": 0.95, "entities": {"topic": "colonoscopy"}}

User: "What can you help me with?"
Expected response: {"intent": "capabilities", "confidence": 1.0, "entities": {}}

Return strict JSON:
{
  "intent": "<one of the above>",
  "confidence": 0.95,
  "entities": { ... }
}
"""
    context_info = conversation_context if conversation_context else {}
    gpt_messages = [
        {"role": "system", "content": fallback_prompt},
        {"role": "user", "content": f"Utterance: {user_input}\nContext: {json.dumps(context_info)}\nLast Intent: {last_intent}"}
    ]
    cache_key = f"gpt_fallback::{original_message}::{json.dumps(context_info)}::{last_intent}"
    if cache_key in FALLBACK_CACHE:
        logger.info("Using cached GPT fallback response.")
        return FALLBACK_CACHE[cache_key]

    try:
        response = await openai_manager.chat_completion(
            model=OPENAI_MODEL,
            messages=gpt_messages,
            temperature=0.2,
            max_tokens=150
        )
        if isinstance(response, Coroutine):
            logger.debug("GPT response is a coroutine, forcing await.")
            response = await response
        if not response or not response.choices:
            logger.error("Empty response from OpenAI fallback.")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        response_content = response.choices[0].message.content
        logger.debug(f"GPT Fallback raw response: {response_content}")
        try:
            intent_data = json.loads(response_content)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse GPT fallback response as JSON: {e}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        if not isinstance(intent_data, dict) or not all(k in intent_data for k in ["intent", "confidence"]):
            logger.error(f"GPT fallback response is invalid: {intent_data}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        try:
            recognized_intent = Intent(intent_data["intent"]).value
        except (ValueError, KeyError):
            logger.warning(f"Invalid intent in GPT fallback response: {intent_data.get('intent')}")
            recognized_intent = Intent.UNKNOWN.value
        result = {
            "intent": recognized_intent,
            "confidence": float(intent_data.get("confidence", 0.1)),
            "entities": intent_data.get("entities", {}),
            "original_text": user_input
        }
        FALLBACK_CACHE[cache_key] = result
        return result
    except Exception as e:
        logger.error(f"Unexpected error in GPT fallback: {e}", exc_info=True)
        return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}

# ============================================
#   Symptom & Condition Analysis (async)
# ============================================
async def analyze_symptom_and_conditions_with_ai(
    patient_id: str,
    user_message: str,
    conversation_history: Optional[list] = None,
    current_topic: Optional[dict] = None
) -> str:
    """
    Analyze symptoms and conditions with advanced AI using FHIR data.
    Detects language, retrieves the patient resource, and returns a triage response.
    """
    try:
        fhir_client =  get_async_fhir_client()
        detected_lang = await language_service.detect_language(user_message)
        emergency_text = language_service.get_localized_message('emergency_text', detected_lang)
        disclaimer = language_service.get_localized_message('disclaimer', detected_lang)
        patient = await fhir_client.server.perform_request('GET', f"Patient/{patient_id}")

        SEVERITY_LEVELS = {
            'EMERGENCY': {
                'prefix': '🚨 EMERGENCY MEDICAL ATTENTION NEEDED',
                'action': 'Please call emergency services (e.g. 112) immediately or go to the nearest ER.',
                'followup': 'Do not delay seeking help.'
            },
            'URGENT': {
                'prefix': '⚠️ URGENT MEDICAL ATTENTION ADVISED',
                'action': 'Please seek urgent medical care or contact your healthcare provider right away.',
                'followup': 'If symptoms worsen, call emergency services.'
            },
            'MODERATE': {
                'prefix': '⚕️ MEDICAL ATTENTION RECOMMENDED',
                'action': 'Schedule an appointment with your provider soon.',
                'followup': 'Monitor symptoms and seek urgent care if they worsen.'
            },
            'LOW': {
                'prefix': 'ℹ️ GENERAL HEALTH ADVICE',
                'action': 'Monitor your symptoms and practice self-care at home.',
                'followup': 'Schedule a routine appointment if symptoms persist.'
            }
        }

        response = await openai_manager.chat_completion(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": (
                    "You are a medical triage assistant focusing on patient safety. Always err on the side of caution. "
                    "Return structured JSON with severity and recommended steps."
                )},
                {"role": "user", "content": f"""
Analyze this health concern with severity:

Patient Message: {user_message}

Return JSON with:
{{
    "severity_level": "EMERGENCY|URGENT|MODERATE|LOW",
    "primary_symptoms": [list of main symptoms],
    "related_conditions": [possible related conditions],
    "immediate_actions": [actions to take],
    "reasoning": "brief explanation",
    "requires_emergency": boolean,
    "followup_recommendation": "specific followup advice"
}}
"""}
            ],
            temperature=0.3,
            max_tokens=500
        )
        analysis = json.loads(response.choices[0].message.content)
        severity = analysis.get('severity_level', 'MODERATE')
        severity_info = SEVERITY_LEVELS.get(severity, SEVERITY_LEVELS['MODERATE'])
        primary_symptoms = analysis.get('primary_symptoms', [])
        symptom_list = ", ".join(primary_symptoms) if primary_symptoms else "None"
        response_text = [
            f"{severity_info['prefix']}",
            "",
            f"Symptoms identified: {symptom_list}",
            "",
            f"RECOMMENDATION: {severity_info['action']}",
            "",
            f"Important: {severity_info['followup']}"
        ]
        if analysis.get('requires_emergency', False):
            response_text.append("\n🚨 EMERGENCY NUMBERS:")
            response_text.append("General Emergency: 112 (Europe), 911 (US), or local equivalent.")
            response_text.append("If in doubt, call emergency services immediately.")
        if disclaimer:
            response_text.append(f"\n{disclaimer}")
        else:
            response_text.append("\nPlease note this does not replace professional medical advice.")
        return "\n".join(response_text)
    except Exception as e:
        logger.error(f"Error in symptom analysis: {str(e)}", exc_info=True)
        return (
            "For your safety, please seek medical attention or contact emergency services "
            "if you're concerned about any symptoms."
        )
logger.debug("Intent service initialization complete")

================
File: language_service.py
================
# chatbot/views/services/language_service.py
import logging
import json
from langdetect import detect, DetectorFactory
from django.conf import settings
from django.core.cache import cache  # Redis cache backend
from ...utils.openai_manager import openai_manager
import re
from ..utils.constants import OPENAI_MODEL
import hashlib

logger = logging.getLogger('chatbot')
logger.debug("Language service initialized")

class LanguageService:
    def __init__(self):
        DetectorFactory.seed = 0
        self.supported_languages = {
            'en': {'name': 'English', 'code': 'en'},
            'es': {'name': 'Spanish', 'code': 'es'}
        }
        # Use centralized OpenAI manager
    
    async def detect_language(self, text):
        """Detect the language of the input text"""
        try:
            response = await openai_manager.chat_completion(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a language detector. Return JSON with language and translation if not English."},
                    {"role": "user", "content": f"Analyze: {text}\nReturn: " + '{"language": "en|es", "translated": "English translation if not English"}'}
                ]
            )
            try:
                result = json.loads(response.choices[0].message.content)
                return result.get('language', 'en').split('|')[0]
            except json.JSONDecodeError:
                logger.error("Failed to parse language detection response")
                return 'en'
        except Exception as e:
            logger.error(f"Error detecting language: {str(e)}")
            return 'en'
    
    def get_localized_message(self, message_key, lang_code='en'):
        """Get localized version of a message"""
        messages = {
            'emergency_text': {
                'en': '🚨 EMERGENCY: Seek immediate medical attention',
                'es': '🚨 EMERGENCIA: Busque atención médica inmediata'
            },
            'disclaimer': {
                'en': 'This is an automated assessment. Always consult a healthcare professional.',
                'es': 'Esta es una evaluación automatizada. Siempre consulte a un profesional de la salud.'
            }
        }
        return messages.get(message_key, {}).get(lang_code, messages[message_key]['en'])
    
    async def translate_text(self, text, target_lang='en'):
        """
        Translate text using OpenAI with Redis caching
        
        Uses a hash of the text and target language as the cache key.
        Caches translations for 90 days to reduce API costs.
        """
        if not text or target_lang == 'en':
            return text
            
        # Generate a cache key based on the text and target language
        text_hash = hashlib.md5(text.encode('utf-8')).hexdigest()
        cache_key = f"trans:{target_lang}:{text_hash}"
        
        # Check cache first
        cached_translation = cache.get(cache_key)
        if cached_translation:
            logger.info(f"Using cached translation for {target_lang} (key: {cache_key[:10]}...)")
            return cached_translation

        try:
            # No cache hit, call the OpenAI API
            logger.info(f"Translation cache miss - calling API for {target_lang} text (key: {cache_key[:10]}...)")
            response = await openai_manager.chat_completion(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": f"You are a translator. Translate the following text to {self.supported_languages[target_lang]['name']}, maintaining the same tone and meaning:"},
                    {"role": "user", "content": text}
                ],
                temperature=0.3
            )
            translation = response.choices[0].message.content.strip()
            
            # Cache the result for 90 days (60*60*24*90 = 7,776,000 seconds)
            cache.set(cache_key, translation, 60*60*24*90)
            
            # Audit the translation (but not the content for privacy)
            from audit.utils import log_event
            log_event(
                actor="system", 
                action="translation.new",
                resource=f"language.{target_lang}",
                meta={"chars": len(text), "cache_key": cache_key}
            )
            
            return translation
        except Exception as e:
            logger.error(f"Translation error: {str(e)}")
            return text
            
    async def _gpt_translate(self, text, target_lang):
        """
        Internal method to perform the actual OpenAI translation
        Used by the cached translate_text method
        """
        try:
            response = await openai_manager.chat_completion(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": f"You are a translator. Translate the following text to {self.supported_languages[target_lang]['name']}, maintaining the same tone and meaning:"},
                    {"role": "user", "content": text}
                ],
                temperature=0.3
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"GPT translation error: {str(e)}")
            return text

class LanguageHandler:
    def __init__(self):
        self.language_service = LanguageService()
    
    async def process_multilingual(self, text):
        try:
            detected_lang = await self.language_service.detect_language(text)
            needs_translation = detected_lang != 'en'
            
            if needs_translation:
                english_text = await self.language_service.translate_text(text, 'en')
            else:
                english_text = text
                
            return english_text, needs_translation
        except Exception as e:
            logger.error(f"Error in process_multilingual: {str(e)}")
            return text, False
            
    async def translate_response(self, response, needs_translation, target_lang):
        """Translate the response if needed"""
        try:
            if not needs_translation or target_lang == 'en':
                return response

            if isinstance(response, str):
                return await self.language_service.translate_text(response, target_lang)
                
            if isinstance(response, dict) and 'messages' in response:
                translated_messages = []
                for message in response['messages']:
                    try:
                        translated_text = await self.language_service.translate_text(
                            message, 
                            target_lang
                        )
                        translated_messages.append(translated_text)
                    except Exception as e:
                        logger.error(f"Error translating message: {str(e)}")
                        translated_messages.append(message)
                    
                response['messages'] = translated_messages
                
            return response
            
        except Exception as e:
            logger.error(f"Error in translate_response: {str(e)}")
            return response
    async def translate_to_english(self, text):
      """Translate text to English"""
      if not text:
          return text

      try:
          _, needs_translation = await self.process_multilingual(text)
          if needs_translation:
              return await self.language_service.translate_text(text, 'en')
          return text
      except Exception as e:
          logger.error(f"Error translating to English: {str(e)}")
          return text
            
logger.debug("Language service initialization complete")

================
File: medication_service.py
================
#!/usr/bin/env python
"""
medication_adherence_reminder_service.py

A production-ready implementation for the Medication Adherence and Refill Reminder Service for Anna.
This module:
  - Retrieves active MedicationRequest resources from a FHIR server.
  - Parses complex dosage instructions (ignoring PRN instructions) to calculate the next due dose time.
  - Checks for refill needs by examining the latest MedicationDispense's daysSupply.
  - Sends SMS reminders via an integrated notification service.
  - Checks for patient confirmations via a persistent store (stubbed here).
  - Respects patient opt-out preferences.
  
IMPORTANT:
  - Replace FHIR endpoint settings and codes with your production values.
  - Integrate send_sms() with your actual SMS provider (e.g., Twilio).
  - Implement has_confirmed_intake() with real confirmation tracking.
  - In production, run this service on a scheduled basis (via Celery, cron, etc.) to avoid duplicate reminders.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.medicationrequest as fhir_medreq
import fhirclient.models.medicationdispense as fhir_meddisp
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("MedicationAdherenceReminders")
logger.setLevel(logging.INFO)
print ("27")
# ----------------------------------------------------------------------
# Production FHIR client and SMS integration
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient instance.
    Replace the api_base and add OAuth credentials if needed.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your FHIR endpoint
        # Add additional OAuth settings if required.
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS using your SMS provider.
    Replace this stub with your actual SMS provider integration.
    """
    try:
        # Example using Twilio (replace with real implementation):
        # from twilio.rest import Client as TwilioClient
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(body=message, from_=settings.TWILIO_PHONE_NUMBER, to=to_number)
        logger.info(f"Sending SMS to {to_number}: {message}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS: {e}")
        return False

# Stub for confirmation tracking.
# In production, replace this with a database query or message queue check.
def has_confirmed_intake(patient_id, med_req_id, dose_due_time):
    """
    Check if the patient has confirmed taking their dose.
    This function should query a persistent store keyed by (patient_id, med_req_id, dose_due_time).
    For demonstration, returns False.
    """
    # TODO: Integrate with your confirmation tracking database.
    return False

# ----------------------------------------------------------------------
# Medication Adherence and Refill Reminder Service
# ----------------------------------------------------------------------
class MedicationAdherenceReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        self.refill_threshold_days = 3  # Send refill reminder if <= 3 days remain
    


    def get_due_reminders(self, current_time):
        """
        Returns a list of due medication reminders for the current time.
        Each reminder is a dictionary with patient_id, medication_name, phone_number.
        """
        due_reminders = []
        med_requests = self._get_all_active_medication_requests()

        for med_req in med_requests:
            patient_id = self._extract_patient_id(med_req)
            if not patient_id:
                continue

            phone_number = self._get_patient_phone_number(patient_id)
            if not phone_number:
                logger.warning(f"No phone number for patient {patient_id}; skipping reminder.")
                continue

            medication_name = self._get_medication_name(med_req) or "your medication"

            # Determine next due dose time
            next_due_time = self._get_next_due_dose_time(med_req)

            if next_due_time and current_time >= next_due_time:
                due_reminders.append({
                    "patient_id": patient_id,
                    "medication_name": medication_name,
                    "phone_number": phone_number,
                    "due_time": next_due_time.isoformat()
                })

        return due_reminders

    def process_medication_reminders(self):
        """
        Main function: retrieves due reminders and sends SMS messages.
        """
        current_time = datetime.now()
        due_reminders = self.get_due_reminders(current_time)

        for reminder in due_reminders:
            self.send_reminder(reminder)

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for the given medication.
        """
        message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
        success = self.notification_service(reminder["phone_number"], message)

        if success:
            logger.info(f"Reminder sent to patient {reminder['patient_id']} for {reminder['medication_name']}")
        else:
            logger.error(f"Failed to send reminder to patient {reminder['patient_id']}")


    # ------------------------------------------------------------------
    # FHIR Data Retrieval Methods
    # ------------------------------------------------------------------
    def _get_all_active_medication_requests(self):
        med_reqs = []
        try:
            search = fhir_medreq.MedicationRequest.where({'status': 'active'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for req in bundle:
                    if isinstance(req, fhir_medreq.MedicationRequest):
                        med_reqs.append(req)
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving active MedicationRequests: {e}")
        return med_reqs

    def _extract_patient_id(self, med_req):
        if not med_req.subject or not med_req.subject.reference:
            return None
        return med_req.subject.reference.split('/')[-1]

    def _get_patient_phone_number(self, patient_id):
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient and patient.telecom:
                for telecom in patient.telecom:
                    if telecom.system == 'phone' and telecom.value:
                        return telecom.value
        except Exception as e:
            logger.error(f"Error retrieving phone number for patient {patient_id}: {e}")
        return None

    def _get_patient_preferred_language(self, patient_id):
        """
        Retrieves the preferred language from the Patient resource.
        For demonstration, returns 'en'.
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.communication and len(patient.communication) > 0:
                comm = patient.communication[0]
                if hasattr(comm, 'language') and comm.language and comm.language.text:
                    return comm.language.text.lower()
        except Exception as e:
            logger.error(f"Error retrieving preferred language for patient {patient_id}: {e}")
        return 'en'

    def _get_medication_name(self, med_req):
        if med_req.medicationCodeableConcept:
            if med_req.medicationCodeableConcept.text:
                return med_req.medicationCodeableConcept.text
            if med_req.medicationCodeableConcept.coding:
                return med_req.medicationCodeableConcept.coding[0].display
        return None

    def _patient_has_opted_out(self, patient_id):
        """
        Checks the Patient resource for an opt-out flag.
        Assumes an extension at "http://example.org/fhir/StructureDefinition/optOut".
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.extension:
                for ext in patient.extension:
                    if ext.url == "http://example.org/fhir/StructureDefinition/optOut" and getattr(ext, 'valueBoolean', False):
                        return True
        except Exception as e:
            logger.error(f"Error checking opt-out for patient {patient_id}: {e}")
        return False

    # ------------------------------------------------------------------
    # Dosage Instruction Parsing & Dose Reminder Logic
    # ------------------------------------------------------------------
    def _get_next_due_dose_time(self, med_req):
        """
        Iterates over all dosageInstruction entries (ignoring those marked as "as needed")
        and computes the next due dose time based on dosing frequency.
        Returns the earliest next due datetime among the instructions, or None.
        """
        next_due_times = []
        now = datetime.now()

        if not med_req.dosageInstruction:
            return None

        for dose_inst in med_req.dosageInstruction:
            # Skip PRN instructions (if asNeeded is True or specified via asNeededCodeableConcept)
            if hasattr(dose_inst, 'asNeededBoolean') and dose_inst.asNeededBoolean:
                continue
            if hasattr(dose_inst, 'asNeededCodeableConcept') and dose_inst.asNeededCodeableConcept:
                continue

            frequency, period_hours = self._extract_frequency_and_period(dose_inst)
            if frequency is None or period_hours is None:
                continue

            # Compute the dose interval (in hours)
            interval_hours = period_hours / frequency

            # Retrieve the last dose time from MedicationDispense
            last_dispense = self._get_last_dispense_date(med_req)
            if last_dispense:
                next_due = last_dispense + timedelta(hours=interval_hours)
            else:
                # If no dispense record, assume the dose is due immediately
                next_due = now

            next_due_times.append(next_due)

        if next_due_times:
            return min(next_due_times)
        return None

    def _extract_frequency_and_period(self, dose_inst):
        """
        Extracts frequency and period (in hours) from dose_inst.timing.repeat.
        Returns (frequency, period_hours) or (None, None) if extraction fails.
        """
        try:
            repeat = dose_inst.timing.repeat
            frequency = getattr(repeat, 'frequency', None)
            period = getattr(repeat, 'period', None)
            period_unit = getattr(repeat, 'periodUnit', None)
            if not (frequency and period and period_unit):
                return (None, None)
            hours_map = {
                's': 1/3600,
                'min': 1/60,
                'h': 1,
                'd': 24,
                'wk': 24*7,
                'mo': 24*30,
                'a': 24*365,
            }
            if period_unit not in hours_map:
                return (None, None)
            period_hours = period * hours_map[period_unit]
            return (frequency, period_hours)
        except Exception as e:
            logger.error(f"Error extracting frequency/period: {e}")
            return (None, None)

    def _get_last_dispense_date(self, med_req):
        """
        Retrieves the most recent dispense datetime from MedicationDispense resources
        referencing this MedicationRequest.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        last_date = None
        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    if disp_dt and (not last_date or disp_dt > last_date):
                        last_date = disp_dt
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving MedicationDispense for MedicationRequest/{med_req_id}: {e}")
        return last_date

    def _extract_dispense_datetime(self, disp):
        """
        Extracts a datetime from MedicationDispense.whenHandedOver or whenPrepared.
        """
        for attr in ['whenHandedOver', 'whenPrepared']:
            dt_str = getattr(disp, attr, None)
            if dt_str:
                dt = self._parse_date_str(dt_str)
                if dt:
                    return dt
        return None

    def _parse_date_str(self, date_str):
        """
        Parses an ISO8601 date string into a datetime object.
        """
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except Exception as e:
            logger.warning(f"Error parsing date string '{date_str}': {e}")
            return None

    # ------------------------------------------------------------------
    # Refill Reminder Logic
    # ------------------------------------------------------------------
    def _is_refill_due(self, med_req, now):
        """
        Determines if a refill reminder should be sent based on the latest MedicationDispense's
        daysSupply and the elapsed days since that dispense.
        """
        dispense_info = self._get_latest_dispense_info(med_req)
        if not dispense_info:
            return False

        dispense_date = dispense_info.get('dispense_date')
        days_supply = dispense_info.get('days_supply')
        if not dispense_date or days_supply is None:
            return False

        elapsed_days = (now.date() - dispense_date.date()).days
        remaining_days = days_supply - elapsed_days
        return remaining_days <= self.refill_threshold_days

    def _get_latest_dispense_info(self, med_req):
        """
        Retrieves the most recent MedicationDispense info for this MedicationRequest,
        returning a dict with keys 'dispense_date' and 'days_supply'.
        Note: For complex scenarios (partial refills, overlapping prescriptions), you may need to
        sum or aggregate multiple dispenses.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        latest_date = None
        latest_supply = None

        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    supply = self._extract_days_supply(disp)
                    if disp_dt and supply is not None and (not latest_date or disp_dt > latest_date):
                        latest_date = disp_dt
                        latest_supply = supply
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving dispense info for MedicationRequest/{med_req_id}: {e}")
            return None

        if latest_date:
            return {'dispense_date': latest_date, 'days_supply': latest_supply}
        return None

    def _extract_days_supply(self, disp):
        """
        Extracts the daysSupply value from a MedicationDispense.
        """
        if hasattr(disp, 'daysSupply') and disp.daysSupply and disp.daysSupply.value is not None:
            try:
                return float(disp.daysSupply.value)
            except Exception as e:
                logger.error(f"Error extracting daysSupply: {e}")
        return None

    # ------------------------------------------------------------------
    # End of Service Class
    # ------------------------------------------------------------------

# ----------------------------------------------------------------------
# Script Entry Point (for scheduled execution)
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        reminder_service = MedicationAdherenceReminderService(fhir_client, send_sms)
        reminder_service.process_medication_reminders()
    except Exception as e:
        logger.error(f"Critical error processing medication reminders: {e}")
print ("28")

================
File: notification_service.py
================
"""
Notification Service for ANNA
Handles SMS notifications via Twilio
"""

import logging
from typing import Optional
from django.conf import settings
from asgiref.sync import sync_to_async

logger = logging.getLogger(__name__)

class NotificationService:
    """Service for sending notifications via SMS"""
    
    def __init__(self):
        self.twilio_client = None
        self._initialize_twilio()
    
    def _initialize_twilio(self):
        """Initialize Twilio client"""
        try:
            twilio_sid = getattr(settings, 'TWILIO_ACCOUNT_SID', None)
            twilio_token = getattr(settings, 'TWILIO_AUTH_TOKEN', None)
            
            if twilio_sid and twilio_token:
                from twilio.rest import Client
                self.twilio_client = Client(twilio_sid, twilio_token)
                logger.info("Twilio client initialized successfully")
            else:
                logger.warning("Twilio credentials not configured - SMS notifications disabled")
        except Exception as e:
            logger.error(f"Failed to initialize Twilio client: {e}")
            self.twilio_client = None
    
    async def send_sms(self, to_number: str, message: str) -> bool:
        """Send SMS message asynchronously"""
        if not self.twilio_client:
            logger.warning("Twilio not configured - cannot send SMS")
            return False
        
        try:
            # Use sync_to_async to make Twilio call async
            result = await sync_to_async(self._send_sms_sync)(to_number, message)
            return result
        except Exception as e:
            logger.error(f"Async SMS send error: {e}")
            return False
    
    def _send_sms_sync(self, to_number: str, message: str) -> bool:
        """Synchronous SMS sending"""
        try:
            twilio_phone = getattr(settings, 'TWILIO_PHONE_NUMBER', None)
            if not twilio_phone:
                logger.error("TWILIO_PHONE_NUMBER not configured")
                return False
            
            message_obj = self.twilio_client.messages.create(
                body=message,
                from_=twilio_phone,
                to=to_number
            )
            logger.info(f"SMS sent successfully: {message_obj.sid}")
            return True
        except Exception as e:
            logger.error(f"Twilio error: {e}")
            return False
    
    async def send_appointment_reminder(
        self, 
        to_number: str, 
        appointment_datetime: str,
        provider_name: str = "your healthcare provider"
    ) -> bool:
        """Send appointment reminder SMS"""
        message = (
            f"📅 Appointment Reminder: You have an appointment with {provider_name} "
            f"on {appointment_datetime}. Reply 'CONFIRM' to confirm or 'RESCHEDULE' if you need to reschedule."
        )
        return await self.send_sms(to_number, message)
    
    async def send_medication_reminder(
        self,
        to_number: str,
        medication_name: str,
        dosage: Optional[str] = None
    ) -> bool:
        """Send medication reminder SMS"""
        message = f"💊 Medication Reminder: Time to take your {medication_name}"
        if dosage:
            message += f" ({dosage})"
        message += ". Reply 'TAKEN' when done."
        
        return await self.send_sms(to_number, message)
    
    async def send_lab_results_notification(
        self,
        to_number: str,
        test_name: str = "lab results"
    ) -> bool:
        """Send lab results available notification"""
        message = (
            f"🔬 Lab Results Available: Your {test_name} results are now available. "
            "Contact ANNA to review them or log into your patient portal."
        )
        return await self.send_sms(to_number, message)
    
    async def send_emergency_alert(
        self,
        to_number: str,
        patient_name: str = "Patient"
    ) -> bool:
        """Send emergency alert SMS"""
        message = (
            f"🚨 EMERGENCY ALERT: {patient_name} has indicated they need emergency medical attention. "
            "Please contact them immediately or call emergency services if you cannot reach them."
        )
        return await self.send_sms(to_number, message)

# Global instance
notification_service = NotificationService()

# Convenience functions
async def send_sms(to_number: str, message: str) -> bool:
    return await notification_service.send_sms(to_number, message)

async def send_appointment_reminder(to_number: str, appointment_datetime: str, provider_name: str = "your healthcare provider") -> bool:
    return await notification_service.send_appointment_reminder(to_number, appointment_datetime, provider_name)

async def send_medication_reminder(to_number: str, medication_name: str, dosage: Optional[str] = None) -> bool:
    return await notification_service.send_medication_reminder(to_number, medication_name, dosage)

async def send_lab_results_notification(to_number: str, test_name: str = "lab results") -> bool:
    return await notification_service.send_lab_results_notification(to_number, test_name)

async def send_emergency_alert(to_number: str, patient_name: str = "Patient") -> bool:
    return await notification_service.send_emergency_alert(to_number, patient_name)

================
File: personalized_medical_advice_service.py
================
#!/usr/bin/env python
"""
personalized_medical_advice_service.py

A production-ready, asynchronous module for generating personalized medical advice.
This service combines:
  - Patient-specific data from your FHIR server (via FHIRService from your codebase)
  - Recent conversation context (via your session/conversation manager)
  - Evidence-based guidelines from MedlinePlus Connect (queried via HTTP)
into a comprehensive prompt for GPT-4. The final advice always includes a prominent disclaimer.

Before deploying:
  - Ensure that your FHIR server (settings.FHIR_SERVER_URL) and credentials (from .env) are correct.
  - Verify that the MedlinePlus Connect query parameters match your requirements.
  - Confirm that your conversation manager functions are correctly integrated.
"""

import logging
import asyncio
from datetime import datetime
from typing import List, Dict, Any
import json
from django.conf import settings
from chatbot.views.services.fhir_service import FHIRService
from ...utils.openai_manager import openai_manager

# Configure logging
logger = logging.getLogger("PersonalizedMedicalAdvice")
logger.setLevel(logging.INFO)

# ------------------------------------------------------------------------------
# Evidence-Based Guidelines via MedlinePlus Connect
# ------------------------------------------------------------------------------
import logging
logger = logging.getLogger(__name__)
logger.debug("Personalized medical advice service module loaded")
# Mapping from condition names to MedlinePlus Connect codes.
CONDITION_CODE_MAPPING = {
    # Standard conditions
    "diabetes": "44054006",      # SNOMED code for Type 2 diabetes
    "hypertension": "38341003",  # SNOMED code for hypertension
    "insomnia": "248288008",     # SNOMED code for insomnia
    
    # Pain conditions with SNOMED codes
    "back_pain": "161891005",    # SNOMED code for back pain
    "headache": "25064002",      # SNOMED code for headache
    "leg_pain": "90834002",      # SNOMED code for leg pain
    "chest_pain": "29857009",    # SNOMED code for chest pain
    "abdominal_pain": "21522001", # SNOMED code for abdominal pain
    "knee_pain": "30989003",     # SNOMED code for knee pain
    "arm_pain": "45326000",      # SNOMED code for arm pain
    "foot_pain": "47933007",     # SNOMED code for foot pain
    "hand_pain": "53057004",     # SNOMED code for hand pain
    "ankle_pain": "16114001"     # SNOMED code for ankle pain
}

async def get_medlineplus_guidelines(condition: str) -> str:
    """
    Query MedlinePlus Connect for guideline text for the given condition.
    Returns guideline text or None.
    """
    # Find the condition in our mapping
    code = CONDITION_CODE_MAPPING.get(condition.lower())
    if not code:
        logger.warning(f"No mapping found for condition: {condition}")
        return None

    # Construct the MedlinePlus Connect API URL and parameters
    base_url = "https://connect.medlineplus.gov/service"
    params = {
        "mainSearchCriteria.v.c": code,
        "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
        "mainSearchCriteria.v.dn": condition.replace('_', ' '),
        "informationRecipient.language": "en",
        "knowledgeResponseType": "application/json"
    }
    
    logger.info(f"Making MedlinePlus API request for condition: {condition} with code: {code}")
    logger.info(f"Request URL: {base_url}")
    logger.info(f"Request parameters: {params}")
    
    try:
        # Use httpx for async HTTP requests
        import httpx
        
        async with httpx.AsyncClient() as client:
            # Make the API request with proper error handling
            response = await client.get(base_url, params=params, timeout=10)
            logger.info(f"MedlinePlus API response status: {response.status_code}")
            
            if response.status_code == 200:
                try:
                    # Parse the JSON response
                    logger.debug(f"MedlinePlus response content: {response.text[:500]}...")
                    
                    import json
                    response_data = json.loads(response.text)
                    guideline_text = None
                    
                    # Extract information from the JSON structure
                    # MedlinePlus Connect uses an Atom feed structure
                    if 'feed' in response_data and 'entry' in response_data['feed']:
                        entries = response_data['feed']['entry']
                        if entries and len(entries) > 0:
                            # Try to get the summary content first
                            if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                guideline_text = entries[0]['summary']['_value'].strip()
                                logger.info(f"Found summary element with text: {guideline_text[:100]}...")
                            
                            # If no summary, look for content or title
                            elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                guideline_text = entries[0]['content']['_value'].strip()
                                logger.info(f"Found content element with text: {guideline_text[:100]}...")
                            
                            # Try title as last resort
                            elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                guideline_text = entries[0]['title']['_value'].strip()
                                logger.info(f"Found title element with text: {guideline_text[:100]}...")
                    
                    if guideline_text:
                        logger.info(f"Successfully retrieved guideline for {condition}")
                        return guideline_text
                    else:
                        logger.warning(f"No useful information found for {condition} in JSON response")
                        return None
                except json.JSONDecodeError as json_error:
                    logger.error(f"JSON parsing error for MedlinePlus response: {json_error}")
                    logger.debug(f"Problematic JSON content: {response.text[:300]}...")
                    return None
            else:
                logger.error(f"MedlinePlus API error {response.status_code} for condition {condition}")
                logger.error(f"Error response: {response.text[:300]}...")
                return None
    except Exception as e:
        logger.error(f"Error querying MedlinePlus for {condition}: {e}")
        return None

def get_evidence_based_guidelines(conditions: List[str]) -> Dict[str, str]:
    """
    For each condition in the list, query MedlinePlus Connect and return a mapping.
    """
    guidelines = {}
    for cond in conditions:
        text = get_medlineplus_guidelines(cond)
        if text:
            guidelines[cond] = text
    return guidelines

# ------------------------------------------------------------------------------
# Asynchronous Summarization of Conversation Context
# ------------------------------------------------------------------------------
def redact_sensitive_info(text: str) -> str:
    """
    Stub for redacting sensitive information. Replace with real redaction as needed.
    """
    return text

async def summarize_messages(messages: List[str], openai_client: "AsyncGPT4Client") -> str:
    """
    Uses GPT-4-turbo to generate a concise bullet-point summary of conversation context.
    Redacts sensitive data before summarization.
    """
    if not messages:
        return ""
    joined_messages = "\n".join(f"User: {redact_sensitive_info(m)}" for m in messages)
    system_prompt = (
        "You are an assistant that summarizes conversation context. "
        "Return a concise bullet list (max ~100 tokens) capturing key user info "
        "(symptoms, conditions, preferences) without including any sensitive data."
    )
    prompt_messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Conversation so far:\n{joined_messages}"}
    ]
    try:
        response = await openai_client.chat_completions_create(
            model="gpt-4-turbo",
            messages=prompt_messages,
            temperature=0.7,
            max_tokens=150
        )
        summary_text = response.choices[0].message.content.strip()
        return summary_text
    except Exception as e:
        logger.error(f"Error summarizing messages: {e}", exc_info=True)
        return ""

# ------------------------------------------------------------------------------
# Asynchronous GPT-4 Client Using OpenAI's Async API
# ------------------------------------------------------------------------------
class AsyncGPT4Client:
    def __init__(self, api_key: str = None):
        # Use centralized OpenAI manager instead
        pass

    async def chat_completions_create(self, model: str, messages: List[dict],
                                     temperature: float = 0.7,
                                     max_tokens: int = 300) -> dict:
        """
        Calls the OpenAI async ChatCompletion API via centralized manager.
        """
        try:
            response = await openai_manager.chat_completion(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            return response
        except Exception as e:
            logger.error(f"Error generating GPT-4 response: {e}")
            raise

    async def generate_advice(self, prompt: str) -> str:
        messages = [{"role": "user", "content": prompt}]
        response = await self.chat_completions_create(
            model="gpt-4o-mini",
            messages=messages,
            temperature=0.7,
            max_tokens=300
        )
        return response.choices[0].message.content.strip()

# ------------------------------------------------------------------------------
# Conversation Context Retrieval (Replace with your real conversation/session management)
# ------------------------------------------------------------------------------
def get_conversation_context(patient_id: str) -> Dict[str, any]:
    """
    Retrieve recent conversation context for a patient.
    Replace this with your actual session/conversation manager call.
    """
    return {
        "recent_messages": [
            "I have been worried about my blood sugar levels.",
            "Last week I asked how to control my diabetes."
        ],
        "user_facts": {"diabetes": True}
    }

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Symptom Analysis & Risk Assessment - Enhanced for ANNA Chatbot
# ------------------------------------------------------------------------------
class SymptomAnalyzer:
    """
    Handles all aspects of symptom analysis and risk assessment with
    properly implemented async methods.
    """
    def __init__(self, openai_client=None):
        """Initialize with optional OpenAI client"""
        self.openai_client = openai_client
        self.fhir_service = FHIRService()
        
        # Define red flag symptoms
        self.RED_FLAGS = {
            'chest_pain': [
                'chest pain', 'chest tightness', 'crushing pain',
                'heart attack', 'cardiac', 'heart pain'
            ],
            'breathing': [
                'cannot breathe', 'difficulty breathing', 'shortness of breath',
                'struggling to breathe', 'gasping', 'choking'
            ],
            'stroke': [
                'face drooping', 'arm weakness', 'speech difficulty',
                'numbness one side', 'sudden confusion', 'sudden dizziness'
            ],
            'consciousness': [
                'unconscious', 'passed out', 'fainting',
                'not responding', 'lost consciousness'
            ],
            'bleeding': [
                'severe bleeding', 'heavy bleeding', 'uncontrolled bleeding',
                'bleeding heavily', 'blood loss'
            ],
            'allergic': [
                'anaphylaxis', 'allergic reaction', 'throat swelling',
                'cannot swallow', 'severe allergy'
            ]
        }
        
        # Risk levels with their descriptions
        self.RISK_LEVELS = {
            'EMERGENCY': {
                'level': 4,
                'action': 'CALL EMERGENCY SERVICES IMMEDIATELY (112 or 999)',
                'urgency': 'Immediate emergency attention required'
            },
            'HIGH': {
                'level': 3,
                'action': 'Seek immediate medical attention or go to the nearest urgent care center',
                'urgency': 'Urgent medical attention recommended'
            },
            'MEDIUM': {
                'level': 2,
                'action': 'Consider visiting urgent care or booking an urgent appointment',
                'urgency': 'Prompt medical attention advised'
            },
            'LOW': {
                'level': 1,
                'action': 'Schedule a routine appointment with your healthcare provider',
                'urgency': 'Non-urgent medical attention'
            }
        }

    async def red_flag_checker(self, symptom_description):
        """
        Check for red flag symptoms that require immediate emergency attention
        Returns: tuple (bool, list of matched red flags)
        """
        try:
            symptom_description = symptom_description.lower()
            matched_flags = []

            for category, phrases in self.RED_FLAGS.items():
                if any(phrase in symptom_description for phrase in phrases):
                    matched_flags.append(category)
                    logging.warning(f"Red flag detected: {category} in symptom: {symptom_description}")

            return bool(matched_flags), matched_flags

        except Exception as e:
            logging.error(f"Error in red flag checking: {str(e)}")
            return True, ['error_defaulting_to_emergency']  # Err on side of caution

    async def symptom_analyzer(self, symptom_description, patient_data=None):
        """
        Analyze symptoms using OpenAI for severity assessment
        Returns: dict with analysis results
        """
        try:
            prompt = self._build_analysis_prompt(symptom_description, patient_data)
            
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You are a medical triage assistant. Always respond with a valid JSON object."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}  # Force JSON response format
            )

            analysis = response.choices[0].message.content
            try:
                import json
                analysis = json.loads(analysis)
                logging.info(f"Symptom analysis completed: {analysis}")
            except json.JSONDecodeError as e:
                logging.error(f"Error parsing JSON response: {e}, content: {analysis}")
                # If the response can't be parsed as JSON, extract "severity" if possible
                if '"severity"' in analysis:
                    severity = "HIGH"  # Default
                    if '"severity":"MILD"' in analysis.replace(" ", ""):
                        severity = "MILD"
                    elif '"severity":"MODERATE"' in analysis.replace(" ", ""):
                        severity = "MODERATE"
                    elif '"severity":"SEVERE"' in analysis.replace(" ", ""):
                        severity = "SEVERE"
                    elif '"severity":"CRITICAL"' in analysis.replace(" ", ""):
                        severity = "CRITICAL"
                        
                    analysis = {
                        'severity': severity,
                        'confidence': 0.7,
                        'recommendation': 'Extracted from malformed JSON response',
                        'possible_causes': ['Unknown - JSON parsing error'],
                        'next_steps': ['Consult a healthcare professional']
                    }
                else:
                    # Default cautious response
                    analysis = {
                        'severity': 'HIGH',
                        'confidence': 0.5,
                        'recommendation': 'See a healthcare professional soon',
                        'possible_causes': ['Unable to analyze symptoms'],
                        'next_steps': ['Consult a healthcare professional']
                    }
                
            return analysis

        except Exception as e:
            logging.error(f"Error in symptom analysis: {str(e)}")
            return {
                'severity': 'HIGH',
                'confidence': 0.0,
                'recommendation': 'Due to analysis error, recommending careful evaluation',
                'error': str(e)
            }

    def _build_analysis_prompt(self, symptom_description, patient_data=None):
        """
        Build a prompt for the OpenAI API to analyze symptoms.
        """
        # Base prompt elements
        prompt_parts = [
            "MEDICAL SYMPTOM ASSESSMENT: Analyze the following symptoms in JSON format.\n",
            f"USER SYMPTOMS: {symptom_description}\n",
        ]
        
        # Add patient context if available
        if patient_data:
            age = None
            gender = None
            conditions = []
            
            if isinstance(patient_data, dict):
                # Extract age if birthDate is available
                if 'birthDate' in patient_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.strptime(patient_data['birthDate'], "%Y-%m-%d")
                        today = datetime.today()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except:
                        pass
                
                # Extract gender
                gender = patient_data.get('gender')
                
                # Try to extract conditions if they exist in the data
                if 'condition' in patient_data:
                    for condition in patient_data['condition']:
                        if isinstance(condition, dict) and 'code' in condition and 'text' in condition['code']:
                            conditions.append(condition['code']['text'])
            
            if age or gender or conditions:
                prompt_parts.append("PATIENT CONTEXT:")
                if age:
                    prompt_parts.append(f"- Age: {age}")
                if gender:
                    prompt_parts.append(f"- Gender: {gender}")
                if conditions:
                    prompt_parts.append(f"- Existing conditions: {', '.join(conditions)}")
                prompt_parts.append("\n")
        
        # Add response format instructions
        prompt_parts.append("""
RESPONSE FORMAT: Return a JSON object with the following keys:
{
    "severity": "MILD|MODERATE|SEVERE|CRITICAL",
    "confidence": <float between 0 and 1>,
    "recommendation": "<action recommendation>",
    "possible_causes": ["<cause1>", "<cause2>"],
    "next_steps": ["<step1>", "<step2>"]
}
        """)
        
        return "\n".join(prompt_parts)

    async def risk_level_determiner(self, symptom_analysis, red_flags=None):
        """
        Determine risk level based on symptom analysis and red flags
        Returns: dict with risk assessment
        """
        try:
            if red_flags:
                return {
                    'level': 'EMERGENCY',
                    'action': self.RISK_LEVELS['EMERGENCY']['action'],
                    'urgency': self.RISK_LEVELS['EMERGENCY']['urgency'],
                    'red_flags': red_flags,
                    'timestamp': datetime.utcnow().isoformat()
                }

            # Map severity to risk level
            severity_mapping = {
                'MILD': 'LOW',
                'MODERATE': 'MEDIUM',
                'SEVERE': 'HIGH',
                'CRITICAL': 'EMERGENCY'
            }

            assessed_level = severity_mapping.get(
                symptom_analysis.get('severity', 'SEVERE'),  # Default to SEVERE if unclear
                'HIGH'  # Default to HIGH if mapping fails
            )

            return {
                'level': assessed_level,
                'action': self.RISK_LEVELS[assessed_level]['action'],
                'urgency': self.RISK_LEVELS[assessed_level]['urgency'],
                'confidence': symptom_analysis.get('confidence', 0.0),
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            logging.error(f"Error in risk level determination: {str(e)}")
            return {
                'level': 'HIGH',  # Default to HIGH on error
                'action': self.RISK_LEVELS['HIGH']['action'],
                'urgency': self.RISK_LEVELS['HIGH']['urgency'],
                'error': str(e)
            }

    def response_formatter(self, risk_assessment, patient_data=None):
        """
        Format risk assessment into user-friendly messages
        Returns: dict with formatted messages
        """
        # Define disclaimer
        disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice. Always consult a healthcare professional."
        
        try:
            # Format messages based on risk level
            if risk_assessment['level'] == 'EMERGENCY':
                messages = [
                    "🚨 EMERGENCY: SEEK IMMEDIATE MEDICAL ATTENTION",
                    f"Urgency: {risk_assessment['urgency']}",
                    f"Action: {risk_assessment['action']}",
                    "",
                    disclaimer
                ]
            
            # High risk message template
            elif risk_assessment['level'] == 'HIGH':
                messages = [
                    "⚠️ URGENT MEDICAL ATTENTION RECOMMENDED",
                    f"Recommendation: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Get medical attention today",
                    "- If symptoms worsen, call emergency services",
                    "- Keep someone informed of your condition",
                    "",
                    disclaimer
                ]

            # Medium risk message template
            elif risk_assessment['level'] == 'MEDIUM':
                messages = [
                    "🏥 MEDICAL ATTENTION RECOMMENDED",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Options:",
                    "- Visit an urgent care center",
                    "- Book an urgent appointment with your doctor",
                    "- Monitor your symptoms closely",
                    "",
                    disclaimer
                ]

            # Low risk message template
            else:
                messages = [
                    "ℹ️ MEDICAL GUIDANCE",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Book a routine appointment",
                    "- Monitor your symptoms",
                    "- If condition worsens, seek urgent care",
                    "",
                    disclaimer
                ]

            # Add local emergency numbers if available
            resource_data = None
            
            if patient_data and isinstance(patient_data, dict):
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                    
            if resource_data and isinstance(resource_data, dict) and 'address' in resource_data:
                country = resource_data['address'][0].get('country', 'Unknown')
                messages.append(f"\nLocal emergency numbers for {country}:")
                if country == "Italy":
                    messages.append("Emergency: 112")
                    messages.append("Medical Emergency: 118")
                elif country == "United Kingdom":
                    messages.append("Emergency: 999")
                    messages.append("Non-emergency medical help: 111")
                elif country == "United States":
                    messages.append("Emergency: 911")
                else:
                    messages.append("Common Emergency Number: 112")
            
            return {"messages": messages}
            
        except Exception as e:
            logging.error(f"Error formatting response: {str(e)}")
            return {
                "messages": [
                    "⚠️ MEDICAL ATTENTION RECOMMENDED",
                    "I encountered an error analyzing your symptoms. Please consult a healthcare professional.",
                    disclaimer
                ]
            }

    # Personalized Medical Advice Service (Hybrid Approach, Async)
# ------------------------------------------------------------------------------
class PersonalizedMedicalAdviceService:
    def __init__(self, gpt_client=None, openai_client=None):
        """Initialize with optional GPT client and/or OpenAI client"""
        from django.conf import settings
        from openai import AsyncOpenAI
        
        # Set up GPT client
        if gpt_client:
            self.gpt_client = gpt_client
        else:
            self.gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
        
        # Set up OpenAI client directly
        self.openai_client = openai_client or AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
            
        # Use your actual FHIRService from your codebase
        self.fhir_service = FHIRService()
        
        # Create symptom analyzer and pass the OpenAI client
        self.symptom_analyzer = SymptomAnalyzer(openai_client=self.openai_client)
        
        # Screening guidelines by age
        self.screening_guidelines = {
            "colonoscopy": {
                "min_age": 45,
                "high_risk_factors": [
                    "colorectal cancer", "colon cancer", "rectal cancer", "polyp", 
                    "inflammatory bowel disease", "crohn", "ulcerative colitis",
                    "lynch syndrome", "familial adenomatous polyposis"
                ],
                "frequency": "every 10 years if normal"
            },
            "mammogram": {
                "min_age": 40,
                "high_risk_factors": ["breast cancer", "brca", "dense breasts"],
                "frequency": "annually"
            },
            "psa_screening": {
                "min_age": 55,
                "high_risk_factors": ["prostate cancer"],
                "frequency": "discuss with doctor"
            }
        }

    async def get_personalized_advice(self, patient_id: str, user_query: str) -> str:
        """
        Combines patient data, conversation context, and evidence-based guidelines
        into a prompt for GPT-4, and returns personalized medical advice.
        """
        # Retrieve patient data via your FHIRService (using your real FHIR query)
        patient_resource = await asyncio.to_thread(self.fhir_service.get_patient, patient_id)
        if not patient_resource:
            return "Error: Patient data not found."

        patient_data = self._extract_patient_data(patient_resource)
        context = get_conversation_context(patient_id)
        recent_msgs = context.get("recent_messages", [])
        context_summary = await summarize_messages(recent_msgs, self.gpt_client)

        conditions = patient_data.get("conditions", [])
        guidelines = get_evidence_based_guidelines(conditions)

        prompt = self._build_prompt(user_query, patient_data, context_summary, guidelines)
        logger.info("Constructed prompt for GPT-4:")
        logger.info(prompt)

        advice = await self.gpt_client.generate_advice(prompt)
        advice = self._ensure_disclaimer(advice)
        return advice
        
    def _extract_medical_topic(self, message):
        """
        Extract the main medical topic from a user message.
        """
        # List of common medical topics to check for
        medical_topics = {
            "diabetes": ["diabetes", "blood sugar", "glucose", "insulin"],
            "high blood pressure": ["high blood pressure", "hypertension", "blood pressure"],
            "cold vs flu": ["cold", "flu", "influenza", "difference between cold and flu"],
            "chest pain": ["chest pain", "heart attack", "angina"],
            "sprained ankle": ["sprain", "ankle", "sprained ankle", "twisted ankle"],
            "cholesterol": ["cholesterol", "ldl", "hdl", "lipids", "triglycerides"]
        }
        
        # Convert message to lowercase for case-insensitive matching
        message_lower = message.lower()
        
        # Check for topic matches
        for topic, keywords in medical_topics.items():
            if any(keyword in message_lower for keyword in keywords):
                return topic
                
        # No specific topic found
        return None

    async def get_screening_recommendation(self, patient_data=None, screening_type=None, user_age=None):
        """
        Provides personalized recommendations for medical screenings based on 
        patient age, risk factors, and evidence-based guidelines.
        
        Args:
            patient_data: Patient data dictionary (optional)
            screening_type: Type of screening to provide recommendation for (e.g., "colonoscopy")
            user_age: Patient's age if known (optional, will extract from patient data if not provided)
            
        Returns:
            Dict with personalized recommendation messages
        """
        try:
            # Include the standard medical disclaimer
            disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
            
            # Default responses for unknown screenings
            if not screening_type or screening_type.lower() not in self.screening_guidelines:
                return {
                    "messages": [
                        "I don't have specific screening guidelines for that procedure.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Normalize screening type
            screening_type = screening_type.lower()
            for key in self.screening_guidelines:
                if key in screening_type or screening_type in key:
                    screening_type = key
                    break
            
            # Get guidelines for this screening type
            guidelines = self.screening_guidelines.get(screening_type)
            if not guidelines:
                return {
                    "messages": [
                        f"I don't have specific guidelines for {screening_type}.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Extract patient age if not provided
            age = user_age
            if not age and patient_data and isinstance(patient_data, dict):
                # Check if patient_data is a wrapped resource
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                
                if 'birthDate' in resource_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.fromisoformat(resource_data['birthDate'].replace('Z', '+00:00'))
                        today = datetime.now()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except (ValueError, TypeError):
                        pass
            
            # Check for risk factors
            has_risk_factors = False
            risk_factors_found = []
            
            if patient_data and isinstance(patient_data, dict):
                # Check conditions in patient data
                conditions = []
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                    if 'conditions' in resource_data:
                        conditions = resource_data['conditions']
                
                # Look for risk factors in conditions
                for condition in conditions:
                    condition_name = condition.get('name', '').lower() if isinstance(condition, dict) else str(condition).lower()
                    for risk_factor in guidelines['high_risk_factors']:
                        if risk_factor.lower() in condition_name:
                            has_risk_factors = True
                            risk_factors_found.append(risk_factor)
            
            # Personalized recommendation based on age and risk factors
            min_age = guidelines['min_age']
            frequency = guidelines['frequency']
            
            if age is None:
                # No age information available
                return {
                    "messages": [
                        f"General guideline: {screening_type.title()} screening typically begins at age {min_age} for most people, {frequency}.",
                        "I don't have your age information, so I can't provide a personalized recommendation.",
                        "Please consult with your healthcare provider to determine if this screening is appropriate for you.",
                        disclaimer
                    ]
                }
            elif age < min_age and not has_risk_factors:
                # Under recommended age with no risk factors
                return {
                    "messages": [
                        f"Based on current guidelines, routine {screening_type} screening is recommended starting at age {min_age} for average-risk individuals.",
                        f"Since you are {age} years old and have no documented high-risk factors, routine screening is not yet recommended.",
                        "However, if you have a family history or other risk factors not in your medical record, discuss earlier screening with your doctor.",
                        disclaimer
                    ]
                }
            elif age < min_age and has_risk_factors:
                # Under recommended age but has risk factors
                return {
                    "messages": [
                        f"While routine {screening_type} screening typically starts at age {min_age}, you have risk factors that may warrant earlier screening.",
                        f"Based on your medical record, you have: {', '.join(risk_factors_found)}",
                        f"At age {age} with these risk factors, you should discuss with your doctor about getting screened now.",
                        disclaimer
                    ]
                }
            else:
                # At or above recommended age
                return {
                    "messages": [
                        f"Based on current guidelines, you should have a {screening_type} screening now.",
                        f"At age {age}, routine {screening_type} screening is recommended {frequency}.",
                        "You can schedule this procedure through your healthcare provider's office or patient portal.",
                        disclaimer
                    ]
                }
                
        except Exception as e:
            logger.error(f"Error generating screening recommendation: {str(e)}")
            return {
                "messages": [
                    "I'm sorry, I couldn't generate a specific recommendation.",
                    "Please consult with your healthcare provider about appropriate screening tests for you.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }
            
    async def handle_symptom_query(self, message, patient_data=None, topic=None, additional_data=None, conversation_context=None):
        """
        Main method to handle symptom queries - providing personalized medical advice
        using structured templates for common conditions and GPT for others
        
        Args:
            message: The user's symptom description
            patient_data: Patient data from FHIR (optional)
            topic: Specific medical topic to focus on (optional)
            additional_data: Any additional data like lab results, conditions etc. (optional)
            conversation_context: Context from previous conversations (optional)
            
        Returns:
            Dict with personalized advice messages
        """
        try:
            # Import our new modules (only import on demand to avoid circular imports)
            from chatbot.views.utils.response_formatter import format_symptom_response, format_medical_response
            from chatbot.views.utils.medical_info_templates import get_template_for_topic
            
            # Extract relevant patient info if available
            name = "there"
            age = None
            gender = None
            
            if patient_data:
                if isinstance(patient_data, dict):
                    # Try to get name
                    if 'name' in patient_data and isinstance(patient_data['name'], list) and patient_data['name']:
                        given_name = patient_data['name'][0].get('given', [''])[0] if patient_data['name'][0].get('given') else ''
                        name = given_name or "there"
                        
                    # Try to get age
                    if 'birthDate' in patient_data:
                        from datetime import datetime
                        try:
                            birth_date = datetime.strptime(patient_data['birthDate'], "%Y-%m-%d")
                            today = datetime.today()
                            age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                        except:
                            pass  # Keep age as None if can't calculate
                            
                    # Get gender
                    if 'gender' in patient_data:
                        gender = patient_data['gender']
            
            # Check if we have additional data (FHIR resources like Condition or MedicationStatement)
            patient_conditions = []
            patient_allergies = []
            patient_medications = []
            relevant_history = []
            
            # Extract conditions, medications, and allergies from additional_data if available
            if additional_data:
                if isinstance(additional_data, dict):
                    # Check if it's a FHIR Bundle with entries
                    if 'resourceType' in additional_data and additional_data['resourceType'] == 'Bundle' and 'entry' in additional_data:
                        for entry in additional_data['entry']:
                            resource = entry.get('resource', {})
                            resource_type = resource.get('resourceType')
                            
                            # Extract conditions
                            if resource_type == 'Condition' and resource.get('clinicalStatus', {}).get('coding', [{}])[0].get('code') == 'active':
                                condition_name = resource.get('code', {}).get('text', 'Unknown condition')
                                patient_conditions.append(condition_name)
                                
                            # Extract medications
                            elif resource_type == 'MedicationStatement' and resource.get('status') == 'active':
                                med_name = resource.get('medicationCodeableConcept', {}).get('text', 'Unknown medication')
                                patient_medications.append(med_name)
                                
                            # Extract allergies
                            elif resource_type == 'AllergyIntolerance':
                                allergy_name = resource.get('code', {}).get('text', 'Unknown allergy')
                                patient_allergies.append(allergy_name)
            
            # Use provided topic or attempt to identify it from the message
            identified_topic = topic or await self._extract_symptom_keyphrase(message)
            template = get_template_for_topic(identified_topic) if identified_topic else None
            
            # Check for follow-up questions using context
            is_follow_up = False
            current_topic = None
            if conversation_context and conversation_context.get('user_facts'):
                # Check if we have a current_topic stored in user_facts
                current_topic = conversation_context.get('user_facts', {}).get('current_topic')
                
                # Check if this is a short message that might be a follow-up
                if len(message.split()) <= 8 and current_topic:
                    follow_up_indicators = [
                        "what", "why", "how", "should", "could", "when", "is it", "are there", 
                        "causes", "treated", "serious", "normal", "treatment", "cure", "heal",
                        "help", "manage", "deal with", "handle", "ease", "relieve", "mean"
                    ]
                    # Check if message contains follow-up indicators
                    if any(indicator in message.lower() for indicator in follow_up_indicators):
                        is_follow_up = True
                        # If we don't have a topic from the current message, use the current_topic
                        if not identified_topic and current_topic:
                            identified_topic = current_topic
                            template = get_template_for_topic(identified_topic) if identified_topic else None
                            logging.info(f"Follow-up detected, using previous topic: {current_topic}")
            
            # Check if this is an issue report - should be specifically routed to the new pathway
            is_issue_report = conversation_context and conversation_context.get('intent') == 'issue_report'
            
            # If we have a matching template, use it for a high-quality response
            if template and not is_issue_report:  # Skip template for issue reports to use our new pathway
                logging.info(f"Using template for topic: {identified_topic}")
                
                # Store the current topic in the response for context tracking
                # This will be helpful for follow-up questions
                if identified_topic:
                    if conversation_context and 'user_facts' in conversation_context:
                        conversation_context['user_facts']['current_topic'] = identified_topic
                        logging.info(f"Updated current_topic in user_facts: {identified_topic}")
                
                # Format using our new structured formatter
                if "variants" in template:
                    # This is a condition with variants (like cold vs flu)
                    from chatbot.views.utils.response_formatter import format_condition_variants
                    messages = format_condition_variants(
                        identified_topic, 
                        template["variants"]
                    )
                else:
                    # Standard medical info or symptom template
                    messages = format_medical_response(
                        question=message,
                        response_data=template,
                        include_brief_answer=True
                    )
                
                # For templates, also check if we need to add personalized warnings based on patient history
                if patient_conditions or patient_medications or patient_allergies:
                    # Try to determine if any conditions/meds/allergies are relevant to the current topic
                    relevant_history = await self._find_relevant_medical_history(
                        topic=identified_topic,
                        conditions=patient_conditions,
                        medications=patient_medications,
                        allergies=patient_allergies
                    )
                    
                    # If we found relevant history, include it at the top of the response
                    if relevant_history:
                        relevant_info = "⚠️ Note: "
                        if len(relevant_history) == 1:
                            relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {identified_topic}."
                        else:
                            conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                            relevant_info += f"You have a history of {conditions_list}, which may affect management of {identified_topic}."
                        
                        # Insert at the beginning of the messages
                        messages.insert(0, relevant_info)
                
                return {"messages": messages}
            
            # For issue reports or if no template, try to get MedlinePlus info or generate a response
            if is_issue_report or identified_topic:
                logging.info(f"Processing issue report for: {identified_topic or message}")
                
                # Extract the symptom keyphrase if we don't already have it
                if not identified_topic:
                    identified_topic = await self._extract_symptom_keyphrase(message)
                
                # If we have a keyphrase, try to get guidelines
                medlineplus_results = None
                if identified_topic:
                    try:
                        # First check if we can resolve a SNOMED code for the keyphrase
                        condition_code = await self.resolve_condition_code(identified_topic)
                        
                        if condition_code:
                            # Try to get MedlinePlus guidelines
                            medlineplus_results = await self._get_direct_medlineplus_info(identified_topic, condition_code)
                    except Exception as e:
                        logging.error(f"Error getting MedlinePlus info for {identified_topic}: {str(e)}")
                
                # Generate personalized response
                messages = []
                
                # Start with personalized warnings based on patient history if available
                if patient_conditions or patient_medications or patient_allergies:
                    relevant_history = await self._find_relevant_medical_history(
                        topic=identified_topic,
                        conditions=patient_conditions,
                        medications=patient_medications,
                        allergies=patient_allergies
                    )
                    
                    if relevant_history:
                        relevant_info = "⚠️ Note: "
                        if len(relevant_history) == 1:
                            relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {identified_topic}."
                        else:
                            conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                            relevant_info += f"You have a history of {conditions_list}, which may affect management of {identified_topic}."
                        
                        messages.append(relevant_info)
                        messages.append("")  # Add a blank line
                
                # Use MedlinePlus guidelines if available
                if medlineplus_results and 'messages' in medlineplus_results:
                    # Add the main MedlinePlus info
                    messages.extend(medlineplus_results['messages'])
                else:
                    # Use fallback generic guidance
                    messages.extend([
                        f"For {identified_topic or 'your symptoms'}:",
                        "- Rest and avoid exacerbating activities",
                        "- Apply ice or heat as appropriate",
                        "- Consider over-the-counter analgesics",
                        "- Consult your healthcare provider if symptoms persist beyond 3 days"
                    ])
                
                # Ensure we have the standard disclaimer at the end
                from chatbot.views.utils.response_formatter import STANDARD_DISCLAIMER
                if not any(STANDARD_DISCLAIMER.lower() in msg.lower() for msg in messages):
                    messages.append("")  # Add a blank line
                    messages.append(STANDARD_DISCLAIMER)
                
                # Update the session with the current topic
                if identified_topic and conversation_context and 'user_facts' in conversation_context:
                    conversation_context['user_facts']['current_topic'] = identified_topic
                
                return {"messages": messages, "extracted_topic": identified_topic}
            
            # Try the existing MedlinePlus info retrieval for backward compatibility
            try:
                logging.info(f"Attempting to retrieve specific MedlinePlus info for: {message}")
                
                # For follow-up questions, use the current topic if available
                lookup_message = message
                if is_follow_up and current_topic:
                    lookup_message = f"{current_topic} {message}"
                    logging.info(f"Enhanced lookup message for follow-up: {lookup_message}")
                
                specific_info = await self.provide_specific_info(lookup_message)
                if specific_info and specific_info.get("messages") and len(specific_info["messages"]) > 0:
                    # We have specific MedlinePlus info available, use it
                    logging.info(f"Successfully retrieved and using MedlinePlus info for: {lookup_message}")
                    
                    # Store the topic if it was extracted from provide_specific_info
                    if specific_info.get("extracted_topic") and conversation_context and 'user_facts' in conversation_context:
                        conversation_context['user_facts']['current_topic'] = specific_info["extracted_topic"]
                        logging.info(f"Updated current_topic from MedlinePlus: {specific_info['extracted_topic']}")
                    
                    # Add personalized warnings based on patient history if available
                    if patient_conditions or patient_medications or patient_allergies:
                        extracted_topic = specific_info.get("extracted_topic")
                        if extracted_topic:
                            relevant_history = await self._find_relevant_medical_history(
                                topic=extracted_topic,
                                conditions=patient_conditions,
                                medications=patient_medications,
                                allergies=patient_allergies
                            )
                            
                            if relevant_history:
                                relevant_info = "⚠️ Note: "
                                if len(relevant_history) == 1:
                                    relevant_info += f"You have a history of {relevant_history[0]}, which may affect management of {extracted_topic}."
                                else:
                                    conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                                    relevant_info += f"You have a history of {conditions_list}, which may affect management of {extracted_topic}."
                                
                                # Insert at the beginning of the messages
                                specific_info["messages"].insert(0, relevant_info)
                    
                    return specific_info
                else:
                    logging.info(f"No specific MedlinePlus info found for: {lookup_message}")
            except Exception as e:
                logging.error(f"Error retrieving MedlinePlus info: {str(e)}")
                # Continue to fallback if MedlinePlus retrieval fails
                
            # Fallback to symptom analyzer for general symptom queries
            try:
                symptoms = message
                severity = "MEDIUM"  # Default severity
                analysis = None  # Initialize analysis variable
                
                # Check for emergency keywords
                emergency_keywords = [
                    "chest pain", "can't breathe", "difficulty breathing", "stroke", 
                    "heart attack", "severe bleeding", "unconscious", "passed out"
                ]
                if any(keyword in message.lower() for keyword in emergency_keywords):
                    severity = "EMERGENCY"
                
                # For non-emergency cases, get a more detailed assessment from symptom analyzer
                else:
                    # Use the symptom analyzer if available
                    if hasattr(self, 'symptom_analyzer'):
                        # Check for red flags first
                        red_flag_result, red_flags = await self.symptom_analyzer.red_flag_checker(message)
                        if red_flag_result:
                            severity = "EMERGENCY"
                        else:
                            analysis = await self.symptom_analyzer.symptom_analyzer(message, patient_data)
                            if analysis:
                                symptom_severity = analysis.get('severity', 'MODERATE').upper()
                                # Map to our severity levels
                                if symptom_severity in ['SEVERE', 'CRITICAL']:
                                    severity = "HIGH"
                                elif symptom_severity in ['MODERATE']:
                                    severity = "MEDIUM"
                                elif symptom_severity in ['MILD']:
                                    severity = "LOW"
                
                # Use our new structured symptom response formatter
                recommendations = [
                    "Rest and monitor your symptoms",
                    "Stay hydrated with plenty of fluids",
                    "Consider over-the-counter medications for symptom relief"
                ]
                
                when_to_seek_help = [
                    "Symptoms worsen or don't improve within a few days",
                    "You develop a high fever (over 102°F/39°C)",
                    "You experience severe pain or discomfort",
                    "You have difficulty breathing, chest pain, or severe headache",
                    "You feel dizzy, confused, or disoriented"
                ]
                
                # Add specific recommendations based on keywords in the query
                if "headache" in message.lower():
                    recommendations.append("Rest in a quiet, darkened room")
                    recommendations.append("Apply a cold or warm compress to your head")
                    
                if "sore throat" in message.lower():
                    recommendations.append("Gargle with warm salt water (1/4 tsp salt in 8 oz water)")
                    recommendations.append("Use throat lozenges or throat sprays for temporary relief")
                
                # Add personalized warnings based on patient history if available
                personalized_note = None
                if patient_conditions or patient_medications or patient_allergies:
                    # Extract symptom keyphrase for relevance check
                    keyphrase = await self._extract_symptom_keyphrase(message)
                    if keyphrase:
                        relevant_history = await self._find_relevant_medical_history(
                            topic=keyphrase,
                            conditions=patient_conditions,
                            medications=patient_medications,
                            allergies=patient_allergies
                        )
                        
                        if relevant_history:
                            if len(relevant_history) == 1:
                                personalized_note = f"⚠️ Note: You have a history of {relevant_history[0]}, which may affect management of your symptoms."
                            else:
                                conditions_list = ", ".join(relevant_history[:-1]) + " and " + relevant_history[-1]
                                personalized_note = f"⚠️ Note: You have a history of {conditions_list}, which may affect management of your symptoms."
                
                from chatbot.views.utils.response_formatter import format_symptom_response
                messages = format_symptom_response(
                    symptoms=symptoms,
                    severity=severity,
                    recommendations=recommendations,
                    when_to_seek_help=when_to_seek_help,
                    personalized_note=personalized_note  # Add the personalized note if available
                )
                
                return {"messages": messages}
                
            except Exception as symptom_error:
                logging.error(f"Error in symptom analysis: {str(symptom_error)}")
                
                # Fall back to GPT for personalization if symptom analysis fails
                # Format patient information string for prompt
                patient_info = []
                if name != "there":
                    patient_info.append(f"Name: {name}")
                if age:
                    patient_info.append(f"Age: {age}")
                if gender:
                    patient_info.append(f"Gender: {gender}")
                
                # Add conditions, medications, and allergies to patient info
                if patient_conditions:
                    patient_info.append(f"Conditions: {', '.join(patient_conditions)}")
                if patient_medications:
                    patient_info.append(f"Medications: {', '.join(patient_medications)}")
                if patient_allergies:
                    patient_info.append(f"Allergies: {', '.join(patient_allergies)}")
                
                # Format patient info string or use generic greeting if no data available
                patient_line = f"Patient: {', '.join(patient_info)}" if patient_info else "Patient"
                    
                # Build a prompt for personalized medical advice
                prompt = f"""As a helpful medical advisor, provide personalized advice for this person:

{patient_line}
Symptom query: "{message}"
"""
                # Add conversation context if provided
                if conversation_context:
                    if conversation_context.get('summary'):
                        prompt += f"\nConversation context: {conversation_context['summary']}\n"
                    
                    if conversation_context.get('user_facts') and len(conversation_context['user_facts']) > 0:
                        prompt += f"\nRelevant user facts: {json.dumps(conversation_context['user_facts'])}\n"
                    
                    # Include a few recent messages for context if available
                    recent_messages = conversation_context.get('recent_messages', [])
                    if recent_messages and len(recent_messages) > 0:
                        prompt += "\nRecent conversation:\n"
                        # Get up to 3 most recent messages
                        for msg in recent_messages[-3:]:
                            speaker = "User" if msg.get('is_user', True) else "Assistant"
                            content = msg.get('message', '').strip()
                            if content:
                                prompt += f"{speaker}: {content}\n"
                
                # Add topic information if provided
                if topic:
                    prompt += f"\nSpecific topic focus: {topic}\n"
                elif is_follow_up and current_topic:
                    prompt += f"\nThis is a follow-up question about: {current_topic}\n"
                
                # Add additional data if provided
                if additional_data:
                    prompt += f"\nAdditional patient data: {additional_data}\n"
                
                prompt += """
Please provide:
1. A brief, factual explanation of what might be happening
2. 3-5 practical steps they can take right now to address their symptoms
3. When they should see a doctor

Keep your advice concise and direct, focusing on clear guidance.
IMPORTANT: End with a disclaimer about this being educational not professional medical advice.
"""

                # Get personalized advice from GPT
                from openai import AsyncOpenAI
                from django.conf import settings
                
                # Use symptom_analyzer's client if available, or create a new one
                if hasattr(self, 'symptom_analyzer') and hasattr(self.symptom_analyzer, 'openai_client'):
                    client = self.symptom_analyzer.openai_client
                elif hasattr(self, 'gpt_client'):
                    client = self.gpt_client
                elif hasattr(self, 'openai_client'):
                    client = self.openai_client
                else:
                    # Create a new client as fallback
                    client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
                
                # Debug log for message processing
                print("USER TEXT:", message)
                
                # Create the GPT payload
                gpt_payload = {
                    "model": "gpt-4o-mini",
                    "messages": [
                        {"role": "system", "content": "You are a helpful medical advisor providing accurate, concise advice."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.3  # Lower temperature for more factual responses
                }
                
                # Debug log for the GPT payload
                print("GPT INPUT:", gpt_payload)
                
                response = await client.chat.completions.create(**gpt_payload)
                
                advice = response.choices[0].message.content.strip()
                
                # Split into paragraphs for better message formatting
                advice_paragraphs = [p.strip() for p in advice.split('\n') if p.strip()]
                
                # Add disclaimer if not already present
                from chatbot.views.utils.response_formatter import STANDARD_DISCLAIMER
                if not any(STANDARD_DISCLAIMER.lower() in p.lower() for p in advice_paragraphs):
                    advice_paragraphs.append(STANDARD_DISCLAIMER)
                
                return {"messages": advice_paragraphs}
            
        except Exception as e:
            logging.error(f"Error generating personalized advice: {str(e)}")
            return {
                "messages": [
                    "I apologize, but I encountered an error processing your symptoms.",
                    "For any concerning symptoms, it's best to consult with a healthcare professional.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }
    
    async def _find_relevant_medical_history(self, topic, conditions=None, medications=None, allergies=None):
        """
        Find relevant medical history (conditions, medications, allergies) related to the given topic.
        
        Args:
            topic: The health issue/symptom topic
            conditions: List of patient conditions
            medications: List of patient medications
            allergies: List of patient allergies
            
        Returns:
            List of relevant medical history items
        """
        if not conditions and not medications and not allergies:
            return []
        
        try:
            # Build lists for the API call
            conditions_list = conditions or []
            medications_list = medications or []
            allergies_list = allergies or []
            
            # Use GPT to identify relevant medical history
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": """You are a medical expert that identifies relevant medical history.
                    A person is asking about a health issue, and you need to determine which aspects of their medical history
                    are relevant to this issue. Return a JSON object with relevant items:
                    {
                        "relevant_history": ["item1", "item2", ...]
                    }
                    """},
                    {"role": "user", "content": f"""Health issue/symptom: {topic}
                    
                    Patient medical history:
                    Conditions: {", ".join(conditions_list) if conditions_list else "None"}
                    Medications: {", ".join(medications_list) if medications_list else "None"}
                    Allergies: {", ".join(allergies_list) if allergies_list else "None"}
                    
                    Return only the JSON with relevant history items that could impact management of this health issue."""}
                ],
                response_format={"type": "json_object"},
                temperature=0.1
            )
            
            # Parse the response
            result = json.loads(response.choices[0].message.content)
            relevant_items = result.get("relevant_history", [])
            
            return relevant_items
            
        except Exception as e:
            logging.error(f"Error finding relevant medical history: {str(e)}")
            return []
    
    async def _get_direct_medlineplus_info(self, keyphrase, condition_code):
        """
        Directly query MedlinePlus Connect with a keyphrase and SNOMED code.
        
        Args:
            keyphrase: The health issue/symptom keyphrase
            condition_code: The SNOMED CT code
            
        Returns:
            Dict with formatted messages or None if no info found
        """
        try:
            # Construct the MedlinePlus Connect API URL and parameters
            base_url = "https://connect.medlineplus.gov/service"
            params = {
                "mainSearchCriteria.v.c": condition_code,
                "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
                "mainSearchCriteria.v.dn": keyphrase.replace('_', ' '),
                "informationRecipient.language": "en",
                "knowledgeResponseType": "application/json"
            }
            
            # Make the API request
            import httpx
            async with httpx.AsyncClient() as client:
                response = await client.get(base_url, params=params, timeout=10)
                
                if response.status_code == 200:
                    response_data = json.loads(response.text)
                    guideline_text = None
                    
                    # Extract information from the JSON structure
                    if 'feed' in response_data and 'entry' in response_data['feed']:
                        entries = response_data['feed']['entry']
                        if entries and len(entries) > 0:
                            # Try to get the summary content first
                            if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                guideline_text = entries[0]['summary']['_value'].strip()
                            
                            # If no summary, look for content or title
                            elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                guideline_text = entries[0]['content']['_value'].strip()
                            
                            # Try title as last resort
                            elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                guideline_text = entries[0]['title']['_value'].strip()
                
                    if guideline_text:
                        # We got guidelines, format the response
                        from chatbot.views.utils.response_formatter import format_medical_info_response
                        
                        formatted_messages = format_medical_info_response(
                            topic=keyphrase.replace('_', ' '),
                            summary=f"Here's information about {keyphrase.replace('_', ' ')} from MedlinePlus, a trusted medical resource:",
                            details={
                                "MEDICAL INFORMATION": guideline_text,
                                "RECOMMENDATIONS": [
                                    "Consult with a healthcare provider for a proper diagnosis",
                                    "Follow treatment plans as prescribed by your healthcare provider",
                                    "Keep track of your symptoms and what makes them better or worse"
                                ]
                            }
                        )
                        
                        # Make sure formatted_messages is a list of strings
                        if not all(isinstance(msg, str) for msg in formatted_messages):
                            formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
                        
                        return {"messages": formatted_messages, "extracted_topic": keyphrase}
        
        except Exception as e:
            logging.error(f"Error in _get_direct_medlineplus_info: {str(e)}")
        
        return None

    def _extract_patient_data(self, patient_resource: dict) -> dict:
        """
        Extracts relevant patient data from the FHIR Patient resource.
        Adjust extraction logic according to your actual FHIR resource structure.
        """
        data = {}
        birth_date_str = getattr(patient_resource, "birthDate", None)
        data["age"] = self._calculate_age(birth_date_str) if birth_date_str else "Unknown"
        # Replace these with your actual extraction calls, e.g., using self.fhir_service.get_patient_conditions
        data["conditions"] = ["diabetes", "hypertension"]
        data["medications"] = ["Metformin", "Lisinopril"]
        return data

    def _calculate_age(self, birth_date_str: str) -> int:
        try:
            birth_date = datetime.strptime(birth_date_str, "%Y-%m-%d").date()
            today = datetime.today().date()
            return today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
        except Exception as e:
            logger.error(f"Error calculating age from {birth_date_str}: {e}")
            return 0

    def _build_prompt(self, user_query: str, patient_data: dict,
                      context_summary: str, guidelines: dict) -> str:
        system_message = (
            "You are a clinically accurate medical assistant providing personalized advice based on evidence-based guidelines. "
            "Always include this disclaimer at the end: 'This information is for educational purposes only and is not a substitute for professional medical advice.'"
        )
        prompt_lines = [system_message, "\nPatient Data:"]
        for key, value in patient_data.items():
            prompt_lines.append(f"- {key}: {value}")
        prompt_lines.append("\nEvidence-Based Guidelines:")
        if guidelines:
            for condition, rec in guidelines.items():
                prompt_lines.append(f"- {condition}: {rec}")
        else:
            prompt_lines.append("- None available")
        prompt_lines.append("\nConversation Context Summary:")
        prompt_lines.append(context_summary if context_summary else "No significant context.")
        prompt_lines.append("\nUser Query:")
        prompt_lines.append(user_query)
        return "\n".join(prompt_lines)

    def _ensure_disclaimer(self, advice_text: str) -> str:
        disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
        if disclaimer.lower() not in advice_text.lower():
            advice_text += "\n\n" + disclaimer
        return advice_text
        
    async def resolve_condition_code(self, keyphrase: str) -> str:
        """
        Dynamically resolves a symptom/condition keyphrase to a SNOMED CT code for MedlinePlus queries.
        
        Args:
            keyphrase: The noun or phrase representing the health issue
            
        Returns:
            The SNOMED code if found, or None if not resolvable
        """
        logger.info(f"Attempting to resolve condition code for: {keyphrase}")
        
        # 1. First check our existing mapping
        if keyphrase.lower() in CONDITION_CODE_MAPPING:
            code = CONDITION_CODE_MAPPING[keyphrase.lower()]
            logger.info(f"Found existing code mapping for {keyphrase}: {code}")
            return code
            
        # 2. For compound phrases, try some normalization
        normalized_keyphrase = keyphrase.lower().replace(' ', '_')
        if normalized_keyphrase in CONDITION_CODE_MAPPING:
            code = CONDITION_CODE_MAPPING[normalized_keyphrase]
            logger.info(f"Found normalized code mapping for {keyphrase} -> {normalized_keyphrase}: {code}")
            return code
            
        # 3. Try checking for partial matches (e.g. if "knee pain" is in mapping but keyphrase is "severe knee pain")
        for existing_condition in CONDITION_CODE_MAPPING:
            if existing_condition in keyphrase.lower() or keyphrase.lower() in existing_condition:
                code = CONDITION_CODE_MAPPING[existing_condition]
                logger.info(f"Found partial match mapping for {keyphrase} -> {existing_condition}: {code}")
                return code
                
        # 4. If not found, use GPT to suggest a SNOMED code
        try:
            logger.info(f"No direct mapping found for {keyphrase}, querying GPT for SNOMED code")
            
            # Use OpenAI to map to a standard condition code
            response = await self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": """You are a medical coding expert that maps symptoms to SNOMED CT codes.
                    Return a JSON object with the following structure:
                    {
                        "snomed_code": "string", 
                        "condition_name": "string",
                        "confidence": float,
                        "explanation": "string"
                    }
                    If unable to map with confidence, set snomed_code to null."""},
                    {"role": "user", "content": f"""Map this health issue description to a SNOMED CT code: "{keyphrase}"
                    
                    Some examples of known mappings:
                    - "back pain" -> "161891005"
                    - "headache" -> "25064002"
                    - "high blood pressure" -> "38341003"
                    - "diabetes" -> "44054006"
                    
                    Please return only the JSON object with the mapping."""}
                ],
                response_format={"type": "json_object"},
                temperature=0.1
            )
            
            # Parse the response
            mapping_result = json.loads(response.choices[0].message.content)
            
            # Check if we got a valid code with good confidence
            if (mapping_result.get("snomed_code") and 
                mapping_result.get("confidence", 0) > 0.7 and
                mapping_result.get("condition_name")):
                
                code = mapping_result["snomed_code"]
                condition_name = mapping_result["condition_name"].lower().replace(' ', '_')
                
                # Add to our local mapping for future use
                CONDITION_CODE_MAPPING[condition_name] = code
                logger.info(f"Added new mapping from GPT: {condition_name} -> {code}")
                
                return code
            else:
                logger.info(f"GPT could not map with confidence: {mapping_result}")
                return None
                
        except Exception as e:
            logger.error(f"Error querying GPT for SNOMED code: {str(e)}")
            return None

    async def provide_specific_info(self, symptom_description):
        """
        Provide specific information for the symptom using MedlinePlus guidelines
        when available, and fallback to predefined guidance when not.
        """
        # Extract keyphrase from symptom description
        keyphrase = await self._extract_symptom_keyphrase(symptom_description)
        
        if not keyphrase:
            # If we couldn't extract a keyphrase, try the older location-based approach
            return await self._legacy_provide_specific_info(symptom_description)
            
        logger.info(f"Extracted keyphrase: {keyphrase} from symptom: {symptom_description}")
        
        # Try to resolve the SNOMED code for the keyphrase
        condition_code = await self.resolve_condition_code(keyphrase)
        
        if condition_code:
            # We have a code, try to get MedlinePlus info
            try:
                # Use a direct call to get_medlineplus_guidelines with the keyphrase and code
                # This is more flexible than the previous approach that required entries in CONDITION_CODE_MAPPING
                base_url = "https://connect.medlineplus.gov/service"
                params = {
                    "mainSearchCriteria.v.c": condition_code,
                    "mainSearchCriteria.v.cs": "2.16.840.1.113883.6.96",  # SNOMED CT
                    "mainSearchCriteria.v.dn": keyphrase.replace('_', ' '),
                    "informationRecipient.language": "en",
                    "knowledgeResponseType": "application/json"
                }
                
                # Make the API request
                import httpx
                async with httpx.AsyncClient() as client:
                    # Make the API request with proper error handling
                    response = await client.get(base_url, params=params, timeout=10)
                    
                    if response.status_code == 200:
                        try:
                            # Parse the JSON response
                            response_data = json.loads(response.text)
                            guideline_text = None
                            
                            # Extract information from the JSON structure
                            # MedlinePlus Connect uses an Atom feed structure
                            if 'feed' in response_data and 'entry' in response_data['feed']:
                                entries = response_data['feed']['entry']
                                if entries and len(entries) > 0:
                                    # Try to get the summary content first
                                    if 'summary' in entries[0] and '_value' in entries[0]['summary']:
                                        guideline_text = entries[0]['summary']['_value'].strip()
                                    
                                    # If no summary, look for content or title
                                    elif 'content' in entries[0] and '_value' in entries[0]['content']:
                                        guideline_text = entries[0]['content']['_value'].strip()
                                    
                                    # Try title as last resort
                                    elif 'title' in entries[0] and '_value' in entries[0]['title']:
                                        guideline_text = entries[0]['title']['_value'].strip()
                        
                            if guideline_text:
                                # We got guidelines, format the response
                                from chatbot.views.utils.response_formatter import format_medical_info_response
                                
                                formatted_messages = format_medical_info_response(
                                    topic=keyphrase.replace('_', ' '),
                                    summary=f"Here's information about {keyphrase.replace('_', ' ')} from MedlinePlus, a trusted medical resource:",
                                    details={
                                        "MEDICAL INFORMATION": guideline_text,
                                        "RECOMMENDATIONS": [
                                            "Consult with a healthcare provider for a proper diagnosis",
                                            "Follow treatment plans as prescribed by your healthcare provider",
                                            "Keep track of your symptoms and what makes them better or worse"
                                        ]
                                    }
                                )
                                
                                # Make sure formatted_messages is a list of strings
                                if not all(isinstance(msg, str) for msg in formatted_messages):
                                    formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
                                
                                return {"messages": formatted_messages, "extracted_topic": keyphrase}
                            
                        except json.JSONDecodeError as json_error:
                            logger.error(f"JSON parsing error for MedlinePlus response: {json_error}")
                    
            except Exception as e:
                logger.error(f"Error getting MedlinePlus info for {keyphrase}: {str(e)}")
        
        # Generate a generic fallback response if we couldn't get MedlinePlus info
        messages = [
            f"For {keyphrase.replace('_', ' ')}:",
            "- Rest and avoid exacerbating activities",
            "- Apply ice or heat as appropriate",
            "- Consider over-the-counter analgesics",
            "- Consult your healthcare provider if symptoms persist beyond 3 days"
        ]
        
        return {"messages": messages, "extracted_topic": keyphrase}
    
    async def _extract_symptom_keyphrase(self, symptom_description):
        """
        Extract the key noun phrase representing the health issue from the user's description.
        Uses GPT for high-quality entity extraction.
        """
        try:
            # Debug log for symptom extraction
            print("USER TEXT:", symptom_description)
            
            # Create the GPT payload
            gpt_payload = {
                "model": "gpt-4o-mini",
                "messages": [
                    {"role": "system", "content": """You are a medical NLP expert that extracts key medical terms.
                    Extract the main health issue/symptom from the user's message as a simple noun phrase.
                    Return a JSON object with the following structure:
                    {
                        "keyphrase": "string", 
                        "normalized_term": "string"
                    }
                    For example, if user says "I've been having trouble sleeping for weeks",
                    you would return {"keyphrase": "trouble sleeping", "normalized_term": "insomnia"}"""},
                    {"role": "user", "content": f"""Extract the main health issue from this text: "{symptom_description}"
                    
                    Return only the JSON object with the keyphrase and normalized term."""}
                ],
                "response_format": {"type": "json_object"},
                "temperature": 0.1
            }
            
            # Debug log for the GPT payload
            print("GPT INPUT:", gpt_payload)
            
            response = await self.openai_client.chat.completions.create(**gpt_payload)
            
            # Parse the response
            result = json.loads(response.choices[0].message.content)
            
            # Return normalized term if available, otherwise the keyphrase
            keyphrase = result.get("normalized_term") or result.get("keyphrase")
            
            if keyphrase:
                return keyphrase.lower().strip()
            return None
            
        except Exception as e:
            logger.error(f"Error extracting keyphrase from symptom description: {str(e)}")
            return None
    
    # Keep the legacy method for backward compatibility and as a fallback
    async def _legacy_provide_specific_info(self, symptom_description):
        """
        Legacy implementation of provide_specific_info using location-based approach.
        """
        # Extract location and type of pain
        location = None
        pain_words = ['ache', 'pain', 'hurt', 'sore', 'discomfort']
        
        # Simple location extraction
        body_parts = ['head', 'back', 'chest', 'stomach', 'leg', 'arm', 'foot', 'hand', 'knee', 'ankle']
        for part in body_parts:
            if part in symptom_description.lower():
                location = part
                break
        
        # Generic response
        if not location:
            return {"messages": []}
            
        # Map location to medical condition for MedlinePlus
        condition_mapping = {
            'back': 'back_pain',
            'head': 'headache',
            'leg': 'leg_pain',
            'chest': 'chest_pain',
            'stomach': 'abdominal_pain',
            'arm': 'arm_pain',
            'knee': 'knee_pain',
            'foot': 'foot_pain',
            'hand': 'hand_pain',
            'ankle': 'ankle_pain'
        }
        
        # Try to get MedlinePlus information if available
        medline_info = None
        condition_name = None
        
        if location in condition_mapping:
            # Add to CONDITION_CODE_MAPPING if not already there
            condition_name = condition_mapping[location]
            if condition_name in CONDITION_CODE_MAPPING:
                try:
                    medline_info = await get_medlineplus_guidelines(condition_name)
                    logging.info(f"Retrieved MedlinePlus info for {condition_name}: {medline_info}")
                except Exception as e:
                    logging.error(f"Error getting MedlinePlus info for {condition_name}: {str(e)}")
        
        # If we got MedlinePlus info, use it with better formatting
        if medline_info and medline_info.strip():
            logging.info(f"Found MedlinePlus info for {location} pain")
            
            # Import the response formatter for consistent formatting
            from chatbot.views.utils.response_formatter import format_medical_info_response
            
            # Format the response with proper structure
            formatted_messages = format_medical_info_response(
                topic=f"{location} pain",
                summary=f"Here's information about {location} pain from MedlinePlus, a trusted medical resource:",
                details={
                    "MEDICAL INFORMATION": medline_info,
                    "RECOMMENDATIONS": [
                        "Consult with a healthcare provider for a proper diagnosis",
                        "Follow treatment plans as prescribed by your healthcare provider",
                        "Keep track of your symptoms and what makes them better or worse"
                    ]
                }
            )
            
            # Make sure formatted_messages is a list of strings
            if not all(isinstance(msg, str) for msg in formatted_messages):
                # Convert any non-string elements to strings
                formatted_messages = [str(msg) if not isinstance(msg, str) else msg for msg in formatted_messages]
            
            return {"messages": formatted_messages, "extracted_topic": condition_name}
        
        # If no MedlinePlus info, use the more general AI-driven symptom analysis
        # by falling through to the general handler
        
        # Try to trigger a more personalized AI-based analysis instead
        try:
            analysis_response = await self.handle_symptom_query(
                f"{location} pain {symptom_description}", 
                None,  # No patient data needed for general response
                topic=condition_name  # Pass the identified condition as the topic
            )
            
            if analysis_response and "messages" in analysis_response and analysis_response["messages"]:
                # If we got a good AI-generated response, use it
                analysis_response["extracted_topic"] = condition_name
                return analysis_response
        except Exception as ai_error:
            logging.error(f"Error getting AI-based analysis: {str(ai_error)}")
        
        # As a last resort, fall back to predefined guidance
        messages = []
        
        if location == 'back':
            messages = [
                "For back pain:",
                "- Apply ice for the first 48-72 hours, then heat",
                "- Gentle stretching may help, but avoid strenuous activity",
                "- Over-the-counter pain relievers like ibuprofen may help reduce inflammation"
            ]
            condition_name = "back_pain"
        elif location == 'head':
            messages = [
                "For headaches:",
                "- Rest in a quiet, dark room",
                "- Stay hydrated",
                "- Try a cold compress on your forehead",
                "- Track your headaches to identify patterns and triggers"
            ]
            condition_name = "headache"
        elif location == 'leg':
            messages = [
                "For leg pain:",
                "- Rest and elevate the leg when possible",
                "- Apply ice to reduce swelling",
                "- Gentle stretching may help with muscle discomfort",
                "- Avoid prolonged standing if it worsens the pain"
            ]
            condition_name = "leg_pain"
        else:
            messages = [
                f"For {location} pain:",
                "- Rest the affected area when possible",
                "- Apply ice to reduce swelling and inflammation",
                "- Over-the-counter pain relievers may help with discomfort",
                "- Consult your healthcare provider if pain persists or worsens"
            ]
            condition_name = f"{location}_pain"
            
        return {"messages": messages, "extracted_topic": condition_name}

    async def get_screening_recommendation(self, patient_data=None, screening_type=None, user_age=None):
        """
        Provides personalized recommendations for medical screenings based on 
        patient age, risk factors, and evidence-based guidelines.
        
        Args:
            patient_data: Patient data dictionary (optional)
            screening_type: Type of screening to provide recommendation for (e.g., "colonoscopy")
            user_age: Patient's age if known (optional, will extract from patient data if not provided)
            
        Returns:
            Dict with personalized recommendation messages
        """
        try:
            # Include the standard medical disclaimer
            disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
            
            # Default responses for unknown screenings
            if not screening_type or screening_type.lower() not in self.screening_guidelines:
                return {
                    "messages": [
                        "I don't have specific screening guidelines for that procedure.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Normalize screening type
            screening_type = screening_type.lower()
            for key in self.screening_guidelines:
                if key in screening_type or screening_type in key:
                    screening_type = key
                    break
            
            # Get guidelines for this screening type
            guidelines = self.screening_guidelines.get(screening_type)
            if not guidelines:
                return {
                    "messages": [
                        f"I don't have specific guidelines for {screening_type}.",
                        "Please consult with your healthcare provider for personalized recommendations.",
                        disclaimer
                    ]
                }
            
            # Extract patient age if not provided
            age = user_age
            if not age and patient_data and isinstance(patient_data, dict):
                # Check if patient_data is a wrapped resource
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                else:
                    resource_data = patient_data
                
                if 'birthDate' in resource_data:
                    from datetime import datetime
                    try:
                        birth_date = datetime.fromisoformat(resource_data['birthDate'].replace('Z', '+00:00'))
                        today = datetime.now()
                        age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                    except (ValueError, TypeError):
                        pass
            
            # Check for risk factors
            has_risk_factors = False
            risk_factors_found = []
            
            if patient_data and isinstance(patient_data, dict):
                # Check conditions in patient data
                conditions = []
                resource_data = None
                if 'resource' in patient_data and isinstance(patient_data['resource'], dict):
                    resource_data = patient_data['resource']
                    if 'conditions' in resource_data:
                        conditions = resource_data['conditions']
                
                # Look for risk factors in conditions
                for condition in conditions:
                    condition_name = condition.get('name', '').lower() if isinstance(condition, dict) else str(condition).lower()
                    for risk_factor in guidelines['high_risk_factors']:
                        if risk_factor.lower() in condition_name:
                            has_risk_factors = True
                            risk_factors_found.append(risk_factor)
            
            # Personalized recommendation based on age and risk factors
            min_age = guidelines['min_age']
            frequency = guidelines['frequency']
            
            if age is None:
                # No age information available
                return {
                    "messages": [
                        f"General guideline: {screening_type.title()} screening typically begins at age {min_age} for most people, {frequency}.",
                        "I don't have your age information, so I can't provide a personalized recommendation.",
                        "Please consult with your healthcare provider to determine if this screening is appropriate for you.",
                        disclaimer
                    ]
                }
            elif age < min_age and not has_risk_factors:
                # Under recommended age with no risk factors
                return {
                    "messages": [
                        f"Based on current guidelines, routine {screening_type} screening is recommended starting at age {min_age} for average-risk individuals.",
                        f"Since you are {age} years old and have no documented high-risk factors, routine screening is not yet recommended.",
                        "However, if you have a family history or other risk factors not in your medical record, discuss earlier screening with your doctor.",
                        disclaimer
                    ]
                }
            elif age < min_age and has_risk_factors:
                # Under recommended age but has risk factors
                return {
                    "messages": [
                        f"While routine {screening_type} screening typically starts at age {min_age}, you have risk factors that may warrant earlier screening.",
                        f"Based on your medical record, you have: {', '.join(risk_factors_found)}",
                        f"At age {age} with these risk factors, you should discuss with your doctor about getting screened now.",
                        disclaimer
                    ]
                }
            else:
                # At or above recommended age
                return {
                    "messages": [
                        f"Based on current guidelines, you should have a {screening_type} screening now.",
                        f"At age {age}, routine {screening_type} screening is recommended {frequency}.",
                        "You can schedule this procedure through your healthcare provider's office or patient portal.",
                        disclaimer
                    ]
                }
                
        except Exception as e:
            logger.error(f"Error generating screening recommendation: {str(e)}")
            return {
                "messages": [
                    "I'm sorry, I couldn't generate a specific recommendation.",
                    "Please consult with your healthcare provider about appropriate screening tests for you.",
                    "This information is for educational purposes only and is not a substitute for professional medical advice."
                ]
            }

    async def handle_issue_report(self, issue_data: Dict[str, Any], openai_client: AsyncGPT4Client) -> Dict[str, Any]:
        """Handle issue report and generate appropriate response."""
        try:
            # Extract condition and symptoms
            condition = issue_data.get('condition', '').lower()
            symptoms = issue_data.get('symptoms', [])
            
            # Get evidence-based guidelines
            guidelines = get_evidence_based_guidelines([condition])
            
            # Generate personalized advice
            advice = await self.get_personalized_advice(condition, symptoms, guidelines, openai_client)
            
            # Create history note with proper format
            history_note = {
                'type': 'issue_report',
                'condition': condition,
                'condition_code': CONDITION_CODE_MAPPING.get(condition, ''),
                'confidence_level': 'high',
                'symptoms': symptoms,
                'advice': advice
            }
            
            return {
                'status': 'success',
                'advice': advice,
                'history_note': history_note
            }
            
        except Exception as e:
            logger.error(f"Error handling issue report: {str(e)}")
            return {
                'status': 'error',
                'message': 'Failed to process issue report'
            }

# ------------------------------------------------------------------------------
# Stand-Alone Async Script Entry Point for Testing
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)

    async def main():
        gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
        advice_service = PersonalizedMedicalAdviceService(gpt_client)
        example_patient_id = "12345"  # Replace with a valid patient ID from your FHIR server
        user_query = "How should I manage my diabetes effectively?"
        advice = await advice_service.get_personalized_advice(example_patient_id, user_query)
        print("Personalized Medical Advice:")
        print(advice)

    asyncio.run(main())
logger.debug("Personalized medical advice service initialization complete")

================
File: post_appointment_checkin_service.py
================
#!/usr/bin/env python
"""
post_appointment_checkin_service.py

A production-ready example of the Post-Appointment Check-In Service for Anna.
This script retrieves recently completed Appointments from a FHIR server (e.g., those
that ended ~24 hours ago), checks patient details, composes a follow-up SMS message,
and sends the message via an SMS provider (e.g., Twilio). It also contains stubs for
handling patient responses and escalating concerns.

FEATURES:
  1. Appointment Retrieval: Fetches Appointment resources with status='finished' (or 'completed')
     and filters them by end time to approximate a 24-hour post-appointment window.
  2. Patient Data Lookup: Retrieves the Patient resource for each appointment, pulling phone number,
     name, and preferred language.
  3. Personalized Follow-Up Message: Composes a message referencing the patient's appointment details
     and prompts them to respond if they have questions or concerns.
  4. SMS Sending: Integrates with your notification service (send_sms); in production, connect this
     to Twilio or another SMS provider.
  5. Logging & Tracking: Logs all sent messages. Includes a stub for storing these logs in a database
     if desired.
  6. Response Handling: Provides methods for processing inbound patient responses and escalating care
     team follow-up when certain keywords (e.g., "pain", "confused") appear.
  7. Internationalization (Optional): Illustrates a `_translate_message` stub, letting you integrate
     a translation API for patients whose preferred language is not English.

USAGE:
  - Schedule this script (e.g., via Celery or a cron job) to run periodically (daily or hourly),
    ensuring it checks which appointments ended ~24 hours ago.
  - Adjust the follow-up window, codes, and search parameters for your organization's needs.
  - Replace the placeholders in get_fhir_client() and send_sms() with real credentials
    and integration code.
  - Fully implement the response handling in a persistent store or inbound message queue.

IMPORTANT:
  - Thoroughly test in your staging environment before deploying to production.
  - Secure any PHI in logs, databases, and transmissions as required by HIPAA or relevant regulations.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.appointment as fhir_appointment
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("PostAppointmentCheckInService")
logger.setLevel(logging.INFO)

# ---------------------------------------------------------------------------------
# Production FHIR client and SMS notification integration
# ---------------------------------------------------------------------------------
print ("31")
def get_fhir_client():
    """
    Configure and return a FHIRClient instance pointed at your FHIR server.
    Update 'api_base' and any OAuth settings as required for production.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your actual endpoint
        # Uncomment/modify if OAuth is required:
        # 'client_id': 'YOUR_CLIENT_ID',
        # 'client_secret': 'YOUR_CLIENT_SECRET',
        # 'authorize_uri': 'https://fhirserver.example.com/auth',
        # 'redirect_uri': 'https://yourapp.example.com/redirect',
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS message via your SMS provider.
    Replace the contents of this function with your actual integration code (e.g., Twilio).
    """
    try:
        logger.info(f"Sending SMS to {to_number}: {message}")
        # Example Twilio usage (pseudo-code):
        # from twilio.rest import Client as TwilioClient
        # import settings  # or use environment variables
        #
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(
        #     body=message,
        #     from_=settings.TWILIO_PHONE_NUMBER,
        #     to=to_number
        # )
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {e}")
        return False

# ---------------------------------------------------------------------------------
# Post-Appointment Check-In Service
# ---------------------------------------------------------------------------------
class PostAppointmentCheckInService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        
        # How long after an appointment ends before sending a check-in (24h is typical)
        self.followup_delay = timedelta(hours=24)
        # A small tolerance window (in hours) around the exact follow-up time to decide
        # if it's "due now." This helps manage slight scheduling offsets.
        self.followup_tolerance = timedelta(hours=2)

    def process_checkins(self):
        """
        Main entry point:
          1. Retrieves 'finished' Appointments that ended ~24 hours ago.
          2. For each Appointment, fetches the associated Patient, composes an SMS,
             and sends the check-in message.
          3. Logs each successful check-in or any failures.
        """
        now = datetime.now()
        appointments = self._get_appointments_due_for_checkin(now)
        logger.info(f"Found {len(appointments)} appointments due for check-in at {now.isoformat()}")

        for appt in appointments:
            patient_id = self._extract_patient_id_from_appointment(appt)
            if not patient_id:
                logger.warning(f"No patient ID found in Appointment/{appt.id}, skipping check-in.")
                continue

            patient = self._get_patient_resource(patient_id)
            if not patient:
                logger.warning(f"Could not retrieve Patient/{patient_id}, skipping check-in.")
                continue

            phone = self._get_patient_phone_number(patient)
            if not phone:
                logger.warning(f"Patient {patient_id} has no phone number; skipping check-in.")
                continue

            patient_name = self._get_patient_name(patient)
            preferred_lang = self._get_patient_preferred_language(patient)

            message = self._compose_checkin_message(appt, patient_name)
            message = self._translate_message(message, preferred_lang)

            # Send the SMS check-in
            if self.notification_service(phone, message):
                logger.info(
                    f"Sent post-appointment check-in to patient {patient_id} for Appointment/{appt.id}"
                )
                self._log_checkin_sent(patient_id, appt.id, message)
            else:
                logger.error(f"Failed to send post-appointment check-in for Patient/{patient_id}")

    # ------------------------------------------------------------------
    # Appointment Retrieval & Filtering
    # ------------------------------------------------------------------
    def _get_appointments_due_for_checkin(self, now):
        """
        Retrieves Appointment resources whose status is 'finished' (or 'completed'),
        and whose 'end' time is about 'followup_delay' hours ago, within a tolerance window.
        
        For example, if followup_delay = 24h, we look for appointments that ended between
        (now - 24h - tolerance) and (now - 24h + tolerance).
        """
        # Calculate the time window in which appointments must have ended
        lower_bound = (now - self.followup_delay - self.followup_tolerance)
        upper_bound = (now - self.followup_delay + self.followup_tolerance)

        # We'll build a date filter that your FHIR server might accept. For instance,
        # some servers allow searching by 'date=lt' or 'end=lt'. Check your FHIR server's
        # documentation. Here we assume 'date' can refer to Appointment.start or end time,
        # or we might try a custom param:
        #
        #   'date=ge{lower_bound.isoformat()},le{upper_bound.isoformat()}'
        # 
        # but many servers differ. We'll keep it simple, then manually filter below.
        appointments = []
        try:
            search = fhir_appointment.Appointment.where({'status': 'finished'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for appt in bundle:
                    if not isinstance(appt, fhir_appointment.Appointment):
                        continue
                    end_time = self._get_appointment_end_time(appt)
                    if end_time and lower_bound <= end_time <= upper_bound:
                        appointments.append(appt)

                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving finished Appointments from FHIR: {e}")

        return appointments

    def _get_appointment_end_time(self, appt):
        """
        Extracts the 'end' time from the Appointment resource. 
        Appointment.end is an ISO8601 string. e.g. '2023-07-05T14:30:00Z'.
        """
        if hasattr(appt, 'end') and appt.end:
            try:
                return datetime.fromisoformat(appt.end.replace('Z', '+00:00'))
            except Exception as e:
                logger.warning(f"Error parsing appointment end time for Appointment/{appt.id}: {e}")
        return None

    # ------------------------------------------------------------------
    # Patient Data Retrieval
    # ------------------------------------------------------------------
    def _extract_patient_id_from_appointment(self, appt):
        """
        Extracts the Patient ID from Appointment.subject.reference (e.g. 'Patient/123').
        """
        if not appt.subject or not appt.subject.reference:
            return None
        parts = appt.subject.reference.split('/')
        return parts[-1] if len(parts) > 1 else None

    def _get_patient_resource(self, patient_id):
        """
        Retrieves a FHIR Patient resource by ID.
        """
        try:
            return fhir_patient.Patient.read(patient_id, self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient/{patient_id}: {e}")
            return None

    def _get_patient_phone_number(self, patient):
        """
        Searches Patient.telecom for a phone number to send SMS messages.
        """
        if patient.telecom:
            for telecom in patient.telecom:
                if telecom.system == 'phone' and telecom.value:
                    return telecom.value
        return None

    def _get_patient_name(self, patient):
        """
        Returns a readable patient name from patient.name.
        """
        if patient.name and len(patient.name) > 0:
            name = patient.name[0]
            given = " ".join(name.given) if name.given else ""
            family = name.family if name.family else ""
            full_name = f"{given} {family}".strip()
            return full_name if full_name else "Patient"
        return "Patient"

    def _get_patient_preferred_language(self, patient):
        """
        Tries to retrieve the patient's preferred language code from patient.communication.
        Returns 'en' if not found.
        """
        if patient.communication and len(patient.communication) > 0:
            comm = patient.communication[0]
            if hasattr(comm, 'language') and comm.language and comm.language.text:
                return comm.language.text.lower()  # e.g. 'en', 'es', etc.
        return 'en'

    # ------------------------------------------------------------------
    # Composing & Translating the Check-In Message
    # ------------------------------------------------------------------
    def _compose_checkin_message(self, appt, patient_name):
        """
        Builds a personalized message for the patient referencing their appointment.
        You can extract appointment date/time, provider name, or other relevant details.
        """
        provider_name = self._get_appointment_provider(appt) or "your provider"
        appt_start_str = self._format_appointment_time(appt)
        message = (
            f"Hello {patient_name},\n\n"
            f"We hope your appointment with {provider_name} on {appt_start_str} went well. "
            "Please reply with any questions you have or type 'OK' if everything is clear. "
            "If you are experiencing any issues (e.g., pain, confusion about instructions), reply 'HELP'."
        )
        return message

    def _get_appointment_provider(self, appt):
        """
        Example method to extract the provider's name (or org name) from the Appointment participants.
        In real usage, you'd look for the participant with role='primary performer' or similar,
        then read their display name or reference (e.g., Practitioner/123).
        """
        if not appt.participant:
            return None
        for participant in appt.participant:
            # Check if participant is a Practitioner or Organization with a display
            if participant.actor and participant.actor.display:
                return participant.actor.display
        return None

    def _format_appointment_time(self, appt):
        """
        Formats the appointment start time as a human-readable string.
        """
        if hasattr(appt, 'start') and appt.start:
            try:
                start_dt = datetime.fromisoformat(appt.start.replace('Z', '+00:00'))
                # Format as, e.g., 'July 5 at 2:30 PM'
                return start_dt.strftime("%B %d at %I:%M %p")
            except Exception as e:
                logger.warning(f"Error parsing appointment start time for Appointment/{appt.id}: {e}")
        return "your recent appointment"

    def _translate_message(self, message, target_language):
        """
        Stub for translating a message into another language.
        Integrate a real translation API (e.g., Google Cloud Translate) in production.
        """
        if target_language.lower() == 'en':
            return message
        # Example: prefix with language code for demonstration
        # In production, call your actual translation service here
        return f"[{target_language.upper()} Translation Placeholder] {message}"

    # ------------------------------------------------------------------
    # Logging & Response Handling
    # ------------------------------------------------------------------
    def _log_checkin_sent(self, patient_id, appointment_id, message):
        """
        Logs that we sent a check-in. In production, consider storing in a database
        for historical tracking.
        """
        logger.info(
            f"Check-in message recorded for Patient/{patient_id} Appointment/{appointment_id}: {message}"
        )

    def process_response(self, patient_id, appointment_id, response_text):
        """
        Example method to handle inbound responses from patients.
        In production, you'd call this from an SMS webhook or a queue.
        Checks for concerning keywords to decide if escalation is necessary.
        """
        self._log_patient_response(patient_id, appointment_id, response_text)
        if self._detect_concerning_keywords(response_text):
            self._escalate_issue(patient_id, appointment_id, response_text)

    def _log_patient_response(self, patient_id, appointment_id, response_text):
        """
        Logs the patient response. Again, store in a database if you want
        persistent records of inbound messages.
        """
        logger.info(
            f"Received response from Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )

    def _detect_concerning_keywords(self, response_text):
        """
        Very simple check for words that indicate patient distress or confusion.
        Expand with your own synonyms or logic as needed.
        """
        keywords = ['confused', 'side effect', 'pain', 'problem', 'worry', 'help']
        lower_text = response_text.lower()
        return any(keyword in lower_text for keyword in keywords)

    def _escalate_issue(self, patient_id, appointment_id, response_text):
        """
        Example of escalating a concerning response. In production, you might:
          - Notify a care coordinator via email or SMS
          - Generate a task in your EHR or ticket system
          - Prompt a telehealth nurse to call the patient
        """
        logger.warning(
            f"Escalation triggered for Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )
        # Implement your actual escalation workflow (alerts, tasks, etc.)

# ---------------------------------------------------------------------------------
# Script Entry Point (Scheduling / Cron / Celery)
# ---------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        checkin_service = PostAppointmentCheckInService(fhir_client, send_sms)
        checkin_service.process_checkins()
    except Exception as e:
        logger.error(f"Critical error in processing post-appointment check-ins: {e}")
print ("32")

================
File: post_discharge_service.py
================
# chatbot/views/services/post_discharge_service.py
from celery import shared_task
from django.conf import settings
from twilio.rest import Client
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import logging
from chatbot.views.services.fhir_service import FHIRService  # Adjust import as per your project structure
print ("33")
logger = logging.getLogger('chatbot')
 
@shared_task
async def send_post_discharge_reminders():
    """
    Identifies patients discharged 72 hours ago and sends reminders.
    """
    try:
        fhir_service = FHIRService()
        current_time = datetime.now(ZoneInfo("UTC"))
        reminder_time = current_time - timedelta(hours=72)
        reminder_time_iso = reminder_time.isoformat()
 
        # Search for Encounters that have ended 72 hours ago
        encounters = await fhir_service.search(
            resource_type='Encounter',
            params={
                'status': 'finished',
                'end': f"eq{reminder_time_iso}",
                '_sort': '-end'
            }
        )
 
        if not encounters or 'entry' not in encounters:
            logger.info("No discharged patients found for reminder.")
            return
 
        for entry in encounters['entry']:
            encounter = entry['resource']
            patient_ref = encounter.get('subject', {}).get('reference', '')
            patient_id = patient_ref.split('/')[-1] if '/' in patient_ref else None
 
            if not patient_id:
                logger.warning("Encounter without patient reference.")
                continue
 
            # Retrieve patient details
            patient = await fhir_service.read('Patient', patient_id)
            if not patient:
                logger.warning(f"Patient {patient_id} not found.")
                continue
 
            patient_phone = fhir_service.get_patient_phone(patient)
            if not patient_phone:
                logger.warning(f"No phone number for patient {patient_id}.")
                continue
 
            patient_name = fhir_service.get_patient_name(patient)
 
            # Send SMS reminder
            success = await send_sms_reminder(patient_phone, patient_name)
            if success:
                logger.info(f"Reminder sent to patient {patient_id} for encounter {encounter['id']}.")
            else:
                logger.error(f"Failed to send reminder to patient {patient_id} for encounter {encounter['id']}.")
 
    except Exception as e:
        logger.error(f"Error in send_post_discharge_reminders: {str(e)}", exc_info=True)
        
async def send_sms_reminder(to_number, patient_name):
    """
    Sends an SMS reminder via Twilio.
    """
    try:
        client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        message_body = (
            f"Hello {patient_name},\n\n"
            "We hope you're recovering well after your recent discharge. "
            "Please reply with how you're feeling today, or type 'help' if you have any concerns.\n\n"
            "Your Healthcare Team"
        )
        message = client.messages.create(
            body=message_body,
            from_=settings.TWILIO_PHONE_NUMBER,
            to=to_number
        )
        logger.info(f"Sent SMS to {to_number}: {message.sid}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {str(e)}", exc_info=True)
        return False
print ("34")

================
File: preventive_care_reminder_service.py
================
#!/usr/bin/env python
"""
preventive_care_reminder_service.py

A fully implemented example for the Preventive Care Reminder Service in Anna,
using the fhirclient library for querying a FHIR server. This script checks
patients' ages, risk factors (via Condition/Observation), and their latest
screening/Procedure dates to determine if they need various preventive services.
It then sends SMS reminders (via a Twilio-like function).

NOTES:
1. You must install fhirclient (e.g., `pip install fhirclient`) and have a valid
   FHIR endpoint (OAuth or basic auth, as configured in get_fhir_client()).
2. Replace the codes, URLs, and logic to suit your environment. This script
   demonstrates a typical approach but won't work out of the box without
   your actual codes and FHIR server configuration.
3. For real production usage, you may need pagination, concurrency, more refined
   search parameters, and handling of incomplete data or multiple payers.

Preventive Services Covered:
  - Colonoscopy (every 10 years starting at 45)
  - Mammogram (every 18 months starting at 50, or annually if high risk)
  - Diabetes Screening (every 3 years if at risk)
  - Hypertension Check (annually if borderline, every 2 years if normal)
  - Lipid Panel (every 5 years if at risk)
  - Osteoporosis Screening (every 2 years for postmenopausal women)
  - Vision & Hearing Screening (every 2 years)
  - Cervical Cancer Screening (Pap every 3 years from age 21+)
  - Prostate Cancer Screening (not automatically scheduled; discussion-based)
  - Lung Cancer Screening (annual for 55–80 with smoking history)
  - Shingles Vaccine (once at age 50+ if not previously immunized)

If a patient had ANY preventive service in the last 18 months, you may skip sending
some reminders. This logic is handled by `_had_recent_preventive_care()`.

Risk Factor Determination is done by:
  - Checking Conditions or Observations for relevant codes (e.g., obesity, hypertension).
  - Checking the last BP Observation to decide if it’s borderline/elevated.

Robust Error Handling:
  - Each FHIR query is wrapped in try/except blocks to log and handle errors gracefully.
  - If a query fails, we skip that check and continue with other patients.

(c) Example only. Not guaranteed for production.
"""

import logging
from datetime import datetime, timedelta, date

# fhirclient library
from fhirclient import client
import fhirclient.models.patient as fhir_patient
import fhirclient.models.condition as fhir_condition
import fhirclient.models.observation as fhir_observation
import fhirclient.models.procedure as fhir_procedure
import fhirclient.models.immunization as fhir_immunization

# Logging setup
import logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.debug("Preventive care reminder service module loaded")
# ----------------------------------------------------------------------
# REPLACE THESE WITH REAL CREDENTIALS / ENDPOINTS / OAUTH CONFIG
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient pointed at your FHIR server.
    This example uses a public test server. Replace with your details.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://server.fire.ly/r4',  # Example test server - change to your endpoint
        # If you have OAuth, you'll need 'authorize_uri', 'redirect_uri', 'client_id', etc.
    }
    return client.FHIRClient(settings=settings)

def send_sms(to_number, message):
    """
    Example of an SMS sending function (Twilio-like).
    Replace with actual integration in production.
    """
    logger.info(f"Sending SMS to {to_number}: {message}")
    # e.g.:
    # twilio_client.messages.create(to=to_number, from_="YourShortCode", body=message)
    return True

# ----------------------------------------------------------------------
# Preventive Care Service Implementation
# ----------------------------------------------------------------------
class PreventiveCareReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service

        # Intervals in days
        self.interval_18_months = 18 * 30  # 540 days
        self.colonoscopy_interval = 10 * 365
        self.mammogram_interval = 18 * 30
        self.mammogram_interval_highrisk = 365  # 1 year if high risk
        self.diabetes_interval = 3 * 365
        self.hypertension_interval_normal = 2 * 365
        self.hypertension_interval_elevated = 365
        self.lipid_interval = 5 * 365
        self.osteoporosis_interval = 2 * 365
        self.vision_hearing_interval = 2 * 365
        self.cervical_interval_pap = 3 * 365
        # For co-testing every 5 years, you could define self.cervical_interval_cotesting
        self.lung_interval = 365
        # Prostate screening is discussion-based
        # Shingles vaccine once after 50

    def process_reminders(self):
        """
        Main entry point: gets due reminders and sends them.
        """
        reminders = self.get_due_reminders()
        for reminder in reminders:
            self.send_reminder(reminder)

    def get_due_reminders(self):
        """
        Retrieves all Patients, checks each for needed services, returns a list of reminders.
        """
        reminders = []
        patients = self._get_all_patients()
        now = datetime.now()

        for patient in patients:
            if not patient.id:
                continue

            # Check opt-out
            if self._patient_has_opted_out(patient):
                continue

            phone_number = self._get_patient_phone_number(patient)
            if not phone_number:
                continue

            birth_date = self._get_birth_date(patient)
            if not birth_date:
                continue

            age = self._calculate_age(birth_date, now)

            # We'll collect potential reminders in a local list, then check if we skip some
            patient_reminders = []

            # Check each preventive service
            # 1. Colonoscopy
            if age >= 45:
                if self._needs_colonoscopy(patient.id, now):
                    patient_reminders.append(("Colonoscopy", now.isoformat()))

            # 2. Mammogram for women age >= 50, or high-risk 40+
            if self._is_female(patient):
                if age >= 50:
                    if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval):
                        patient_reminders.append(("Mammogram", now.isoformat()))
                else:
                    # If <50 but high-risk (BRCA, family history, etc.)
                    if age >= 40 and self._is_high_risk_breast_cancer(patient):
                        if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval_highrisk):
                            patient_reminders.append(("Mammogram (High-Risk)", now.isoformat()))

            # 3. Diabetes screening if at risk, every 3 years
            if self._is_at_risk_for_diabetes(patient):
                if self._needs_diabetes_screening(patient.id, now):
                    patient_reminders.append(("Diabetes Screening", now.isoformat()))

            # 4. Hypertension check
            if age >= 18:
                bp_interval = self.hypertension_interval_elevated if self._has_borderline_bp(patient) else self.hypertension_interval_normal
                if self._needs_blood_pressure_check(patient.id, now, bp_interval):
                    patient_reminders.append(("Hypertension Check", now.isoformat()))

            # 5. Lipid panel if at risk
            if self._is_at_risk_for_cardio(patient):
                if self._needs_lipid_panel(patient.id, now):
                    patient_reminders.append(("Cholesterol/Lipid Panel", now.isoformat()))

            # 6. Osteoporosis screening for postmenopausal women
            if self._is_female(patient) and self._is_postmenopausal(age, patient):
                if self._needs_osteoporosis_screening(patient.id, now):
                    patient_reminders.append(("Osteoporosis Screening", now.isoformat()))

            # 7. Vision & Hearing
            if self._needs_vision_hearing_screening(patient.id, now):
                patient_reminders.append(("Vision and Hearing Screening", now.isoformat()))

            # 8. Cervical screening for women 21+
            if self._is_female(patient) and age >= 21:
                if self._needs_cervical_screening(patient.id, now, age):
                    patient_reminders.append(("Cervical Cancer Screening", now.isoformat()))

            # 9. Lung cancer screening for 55–80 with smoking history
            if 55 <= age <= 80 and self._is_eligible_for_lung_screening(patient):
                if self._needs_lung_screening(patient.id, now):
                    patient_reminders.append(("Lung Cancer Screening", now.isoformat()))

            # 10. Shingles vaccine at 50+
            if age >= 50:
                if self._needs_shingles_vaccine(patient.id):
                    patient_reminders.append(("Shingles Vaccine", now.isoformat()))

            # Skip sending if patient had any preventive care in last 18 months
            if patient_reminders and not self._had_recent_preventive_care(patient.id, now, self.interval_18_months):
                for service_name, due_date in patient_reminders:
                    reminders.append({
                        "patient_id": patient.id,
                        "service": service_name,
                        "due_date": due_date,
                        "phone_number": phone_number
                    })

        return reminders

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for a particular service.
        """
        message = (
            f"Hello! You are due for {reminder['service']}. "
            "Please call or visit us online to schedule your appointment."
        )
        try:
            self.notification_service(reminder['phone_number'], message)
            logger.info(f"Sent {reminder['service']} reminder to patient {reminder['patient_id']}")
        except Exception as e:
            logger.error(f"Error sending reminder to patient {reminder['patient_id']}: {e}")

    # -------------------------------------------------------------
    # PATIENT / DEMOGRAPHIC QUERIES
    # -------------------------------------------------------------
    def _get_all_patients(self):
        """
        Retrieves all Patient records from FHIR. Includes basic
        pagination handling for demonstration. Adjust as needed.
        """
        results = []
        search = fhir_patient.Patient.where({})
        try:
            bundle = search.perform_resources(self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient resources: {e}")
            return results  # Return empty list on error

        while bundle:
            for resource in bundle:
                if isinstance(resource, fhir_patient.Patient):
                    results.append(resource)
            # Attempt next page
            next_bundle = None
            try:
                next_bundle = bundle.next_bundle()
            except Exception:
                pass
            bundle = next_bundle

        return results

    def _get_patient_phone_number(self, patient):
        """
        Extracts phone number from the Patient.telecom array.
        """
        if not patient.telecom:
            return None
        for telecom in patient.telecom:
            if telecom.system == 'phone' and telecom.value:
                return telecom.value
        return None

    def _get_birth_date(self, patient):
        """
        Returns birth date as a date object, or None.
        """
        if not patient.birthDate:
            return None
        try:
            return datetime.strptime(patient.birthDate, '%Y-%m-%d').date()
        except ValueError:
            return None

    def _calculate_age(self, birth_date, now):
        """
        Returns integer age in years.
        """
        if not birth_date:
            return 0
        return now.year - birth_date.year - ((now.month, now.day) < (birth_date.month, birth_date.day))

    def _patient_has_opted_out(self, patient):
        """
        Example: checks a custom extension for an opt-out flag.
        Replace with how your system stores opt-out data.
        """
        # Suppose there's an extension with url "http://example.org/fhir/StructureDefinition/optOut"
        if not patient.extension:
            return False
        for ext in patient.extension:
            if ext.url == "http://example.org/fhir/StructureDefinition/optOut":
                if hasattr(ext, 'valueBoolean') and ext.valueBoolean is True:
                    return True
        return False

    def _is_female(self, patient):
        return (patient.gender or "").lower() == "female"

    def _is_postmenopausal(self, age, patient):
        """
        A simplistic assumption: age >= 50 -> postmenopausal.
        Replace with logic for actual Observations or Conditions.
        """
        return age >= 50

    # -------------------------------------------------------------
    # RISK FACTOR CHECKS: Real FHIR Queries for Conditions/Obs
    # -------------------------------------------------------------
    def _is_high_risk_breast_cancer(self, patient):
        """
        Example: checks for Conditions indicating a BRCA mutation or strong family history.
        (Using hypothetical SNOMED/ICD codes.)
        """
        high_risk_codes = [
            "195967001",  # SNOMED for BRCA1 mutation
            "254632001",  # Family history of breast cancer
        ]
        return self._has_any_condition(patient.id, high_risk_codes)

    def _is_at_risk_for_diabetes(self, patient):
        """
        Checks if patient has diabetes or is obese (BMI >30), or has a condition indicating
        prediabetes/family history.
        """
        # Condition codes for diabetes/prediabetes
        diabetes_codes = [
            "44054006",   # Diabetes mellitus type 2
            "15777000",   # Diabetes mellitus type 1
            "42954007",   # Prediabetes
            "73211009",   # Family history of diabetes
        ]
        if self._has_any_condition(patient.id, diabetes_codes):
            return True

        # Check Observations for obesity via last BMI
        bmi = self._get_latest_bmi(patient.id)
        if bmi and bmi >= 30.0:
            return True

        return False

    def _is_at_risk_for_cardio(self, patient):
        """
        Example: checks for existing hyperlipidemia condition or smoking status observation.
        """
        hyperlipidemia_codes = [
            "13644009",  # SNOMED: Hyperlipidemia
        ]
        if self._has_any_condition(patient.id, hyperlipidemia_codes):
            return True

        # Check if patient is a current smoker (Observation of tobacco use = 'current')
        if self._is_current_smoker(patient.id):
            return True

        return False

    def _has_borderline_bp(self, patient):
        """
        Check the last BP reading from Observations.
        Consider borderline if systolic 120–129 or diastolic <80, or mild hypertension codes.
        """
        bp = self._get_latest_blood_pressure(patient.id)
        if not bp:
            return False

        systolic = bp.get('systolic')
        diastolic = bp.get('diastolic')

        # Example borderline criteria:
        # Systolic between 120–129, diastolic <80 => borderline
        if systolic is not None and diastolic is not None:
            if 120 <= systolic <= 129 and diastolic < 80:
                return True

        # Alternatively, if they have a Condition for borderline hypertension:
        borderline_codes = ["60423000"]  # SNOMED for borderline hypertension
        if self._has_any_condition(patient.id, borderline_codes):
            return True

        return False

    def _is_eligible_for_lung_screening(self, patient):
        """
        Check if patient has a heavy smoking history (Condition or Observation).
        Example code for 'heavy tobacco smoker' or pack-year data.
        """
        # If patient has Condition "266919005" (Heavy tobacco smoker)
        heavy_smoker_codes = ["266919005"]
        if self._has_any_condition(patient.id, heavy_smoker_codes):
            return True
        # Could also parse Observations for pack-year calculations
        return False

    def _has_any_condition(self, patient_id, code_list):
        """
        Returns True if the patient has ANY Condition with a code in `code_list`.
        """
        for code in code_list:
            # We do partial or exact matches. In real usage, you may want a more robust approach
            found = self._search_condition_by_code(patient_id, code)
            if found:
                return True
        return False

    def _is_current_smoker(self, patient_id):
        """
        Checks Observations for a tobacco use code that indicates current smoker.
        Example SNOMED code for 'Current smoker' = 77176002
        LOINC code for Tobacco smoking status = 72166-2 (which might store a coded value).
        """
        # In real usage, you'd parse the valueCodeableConcept for 'current every day smoker', etc.
        return self._search_observation_value_code(patient_id, "72166-2", ["449868002", "77176002"])

    # -------------------------------------------------------------
    # CONDITION / OBSERVATION QUERIES
    # -------------------------------------------------------------
    def _search_condition_by_code(self, patient_id, code):
        """
        Searches Condition for a given SNOMED or ICD code.
        Returns True if found, False otherwise.
        """
        try:
            search = fhir_condition.Condition.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error searching Condition for code {code}, patient {patient_id}: {e}")
        return False

    def _search_observation_value_code(self, patient_id, loinc_code, answer_codes):
        """
        Example: searches Observations with code=loinc_code and a specific coded value
        in Observation.valueCodeableConcept. If any match an 'answer_code' that indicates
        current smoker, returns True.
        """
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': loinc_code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    valcc = getattr(obs, 'valueCodeableConcept', None)
                    if valcc and valcc.coding:
                        for coding in valcc.coding:
                            if coding.code in answer_codes:
                                return True
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Observations for code {loinc_code}, patient {patient_id}: {e}")
        return False

    def _get_latest_bmi(self, patient_id):
        """
        Returns the latest BMI value from Observations (LOINC 39156-5 or 60832-3).
        """
        bmi_codes = ["39156-5", "60832-3"]  # LOINC for Body Mass Index
        latest_date = None
        latest_bmi = None

        for code in bmi_codes:
            try:
                search = fhir_observation.Observation.where({
                    'subject': f'Patient/{patient_id}',
                    'code': code
                })
                bundle = search.perform_resources(self.fhir_client.server)
                while bundle:
                    for obs in bundle:
                        if isinstance(obs, fhir_observation.Observation):
                            obs_date = self._extract_obs_effective_date(obs)
                            value = self._extract_quantity_value(obs)
                            if obs_date and value is not None:
                                if not latest_date or obs_date > latest_date:
                                    latest_date = obs_date
                                    latest_bmi = value
                    bundle = bundle.next_bundle()
            except Exception as e:
                logger.error(f"Error retrieving BMI Observations for patient {patient_id}: {e}")

        return latest_bmi

    def _get_latest_blood_pressure(self, patient_id):
        """
        Returns a dict with 'systolic' and 'diastolic' from the latest BP observation
        (LOINC code 85354-9: Blood pressure panel).
        """
        code = "85354-9"
        bp_data = {}
        latest_date = None
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    obs_date = self._extract_obs_effective_date(obs)
                    if obs_date and (not latest_date or obs_date > latest_date):
                        # Extract components for systolic (8480-6) & diastolic (8462-4)
                        components = getattr(obs, 'component', [])
                        s_val, d_val = None, None
                        for comp in components:
                            coding_list = getattr(comp.code, 'coding', None)
                            if not coding_list:
                                continue
                            for c in coding_list:
                                if c.code == "8480-6":  # Systolic
                                    s_val = self._extract_quantity_value(comp)
                                elif c.code == "8462-4":  # Diastolic
                                    d_val = self._extract_quantity_value(comp)
                        bp_data = {'systolic': s_val, 'diastolic': d_val}
                        latest_date = obs_date
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error retrieving Blood Pressure for patient {patient_id}: {e}")
        return bp_data

    # -------------------------------------------------------------
    # NEEDS-* CHECKS: LOOK FOR LAST SERVICE DATE OR IMMUNIZATION
    # -------------------------------------------------------------
    def _needs_colonoscopy(self, patient_id, now):
        last_date = self._get_last_procedure_date(patient_id, ["73761001"])  # SNOMED for colonoscopy
        if not last_date:
            return True
        return (now.date() - last_date).days > self.colonoscopy_interval

    def _needs_mammogram(self, patient_id, now, interval):
        codes = ["72313002"]  # SNOMED for screening mammogram
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_diabetes_screening(self, patient_id, now):
        # E.g. LOINC for A1c or Glucose Tolerance
        codes = ["4548-4", "6298-4"]  # Some LOINC placeholders
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.diabetes_interval

    def _needs_blood_pressure_check(self, patient_id, now, interval):
        # If no BP reading coded as a Procedure, or if it's older than interval
        # Some places record BP as Observations only, but let's assume you might have a
        # "vitals check" procedure code. We'll just re-use the "85354-9" LOINC for demonstration.
        last_date = self._get_last_procedure_date(patient_id, ["85354-9"])
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_lipid_panel(self, patient_id, now):
        # LOINC for Lipid panel = "24331-1", etc.
        codes = ["24331-1"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lipid_interval

    def _needs_osteoporosis_screening(self, patient_id, now):
        # SNOMED for DXA = "398181004"
        codes = ["398181004"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.osteoporosis_interval

    def _needs_vision_hearing_screening(self, patient_id, now):
        # SNOMED example code = "424732000"
        codes = ["424732000"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.vision_hearing_interval

    def _needs_cervical_screening(self, patient_id, now, age):
        # Pap test code example: "19762-4" (LOINC) or "Pap" as SNOMED
        # We'll just pick one LOINC for demonstration
        codes = ["19762-4"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.cervical_interval_pap

    def _needs_lung_screening(self, patient_id, now):
        # SNOMED: "168537006" for low-dose CT
        codes = ["168537006"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lung_interval

    def _needs_shingles_vaccine(self, patient_id):
        # Check if we have an Immunization with relevant code
        # Example: SNOMED for zoster vaccination is "212527006"
        immun_code = ["212527006"]
        last_date = self._get_last_immunization_date(patient_id, immun_code)
        return (last_date is None)

    def _had_recent_preventive_care(self, patient_id, now, interval_days):
        """
        Returns True if the patient had ANY preventive procedure in the last `interval_days`.
        We'll define a broad list of codes for all the services we consider "preventive."
        """
        codes = [
            "73761001",   # Colonoscopy
            "72313002",   # Mammogram
            "4548-4", "6298-4",  # Diabetes screening
            "85354-9",    # BP check
            "24331-1",    # Lipid panel
            "398181004",  # DXA
            "424732000",  # Vision/hearing
            "19762-4",    # Pap
            "168537006",  # Lung screening
        ]
        cutoff = now.date() - timedelta(days=interval_days)

        for code in codes:
            recent = self._has_procedure_after(patient_id, code, cutoff)
            if recent:
                return True

        return False

    # -------------------------------------------------------------
    # FHIR Procedure & Immunization queries
    # -------------------------------------------------------------
    def _get_last_procedure_date(self, patient_id, codes):
        """
        Searches Procedure for any of the given codes, returns the latest date.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_procedure_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_procedure_latest(self, patient_id, code):
        """
        Returns the most recent procedure date for `code`.
        """
        latest_date = None
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for proc in bundle:
                    if not isinstance(proc, fhir_procedure.Procedure):
                        continue
                    dt = self._extract_procedure_date(proc)
                    if dt and (not latest_date or dt > latest_date):
                        latest_date = dt
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Procedure for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _extract_procedure_date(self, procedure):
        """
        Extracts a date from procedure.performedDateTime or procedure.performedPeriod.
        Returns a date object or None.
        """
        pdt = getattr(procedure, 'performedDateTime', None)
        pperiod = getattr(procedure, 'performedPeriod', None)

        # performedDateTime is typically an ISO8601 string
        if pdt:
            return self._parse_date_str(pdt)
        if pperiod:
            if pperiod.end:
                return self._parse_date_str(pperiod.end)
            if pperiod.start:
                return self._parse_date_str(pperiod.start)
        return None

    def _get_last_immunization_date(self, patient_id, codes):
        """
        Returns the most recent immunization date for any code in `codes`.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_immunization_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_immunization_latest(self, patient_id, code):
        """
        Returns the most recent Immunization date for a code.
        """
        latest_date = None
        try:
            search = fhir_immunization.Immunization.where({
                'patient': f'Patient/{patient_id}',
                'vaccine-code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for imm in bundle:
                    if not isinstance(imm, fhir_immunization.Immunization):
                        continue
                    dt = getattr(imm, 'occurrenceDateTime', None)
                    if dt:
                        d = self._parse_date_str(dt)
                        if d and (not latest_date or d > latest_date):
                            latest_date = d
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Immunization for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _has_procedure_after(self, patient_id, code, cutoff_date):
        """
        Returns True if there's a Procedure with `code` after `cutoff_date`.
        """
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code,
                'date': f'ge{cutoff_date.isoformat()}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error checking recent Procedure for code {code}, patient {patient_id}: {e}")
        return False

    # -------------------------------------------------------------
    # OBSERVATION UTILS
    # -------------------------------------------------------------
    def _extract_obs_effective_date(self, obs):
        """
        Extracts the date from Observation.effectiveDateTime or Observation.effectivePeriod.
        """
        edt = getattr(obs, 'effectiveDateTime', None)
        epd = getattr(obs, 'effectivePeriod', None)
        if edt:
            return self._parse_date_str(edt)
        if epd:
            if epd.end:
                return self._parse_date_str(epd.end)
            if epd.start:
                return self._parse_date_str(epd.start)
        return None

    def _extract_quantity_value(self, obj):
        """
        If the Observation or component has a valueQuantity, return the .value as a float.
        """
        valQ = getattr(obj, 'valueQuantity', None)
        if valQ and valQ.value is not None:
            return float(valQ.value)
        return None

    # -------------------------------------------------------------
    # DATE PARSING
    # -------------------------------------------------------------
    def _parse_date_str(self, date_str):
        """
        Attempts to parse a date/time string to a datetime.date.
        """
        if not date_str:
            return None
        try:
            dt = datetime.fromisoformat(date_str)
            return dt.date()
        except ValueError:
            # Possibly just YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d").date()
            except ValueError:
                logger.warning(f"Unable to parse date string: {date_str}")
                return None


# ----------------------------------------------------------------------
# SCRIPT ENTRY POINT
# ----------------------------------------------------------------------
if __name__ == "__main__":
    # Configure logging to console
    logging.basicConfig(level=logging.INFO)

    # Initialize FHIR client and the reminder service
    fhir = get_fhir_client()
    reminder_service = PreventiveCareReminderService(fhir, send_sms)

    # Option 1: Generate a list of due reminders
    # reminders = reminder_service.get_due_reminders()
    # for r in reminders:
    #     print(r)

    # Option 2: Directly process (send) all reminders
    reminder_service.process_reminders()
logger.debug("Preventive care reminder service initialization complete")

================
File: scheduler.py
================
from datetime import datetime, time, timedelta, timezone
from zoneinfo import ZoneInfo
from chatbot.views.utils.shared import get_resource_name 
import dateparser
from django.conf import settings
from ..config import config as app_config
import logging
import openai
from celery import shared_task
from celery.schedules import crontab
from .medication_service import MedicationAdherenceReminderService
from ..utils.datetime_utils import get_current_time
openai.api_key = settings.OPENAI_API_KEY

fhir_client = app_config.get_fhir_client()
# Configure logging
logger = logging.getLogger('chatbot')

# Initialize FHIR Client


# Initialize OpenAI client
client = settings.OPENAI_API_KEY

print ("36")

class ScheduleManager:
    def __init__(self, fhir_client, logger=None):
        self.fhir_client = fhir_client
        self.logger = logger or logging.getLogger(__name__)

    def create_unlimited_schedule(self, practitioner_id):
        """Creates a schedule with an extended planning horizon"""
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": "2024-01-01T00:00:00Z",
                "end": "2050-12-31T23:59:59Z"
            }
        }
        return self.fhir_client.create("Schedule", schedule)

    def update_all_schedules(self):
        """Updates all existing schedules with unlimited planning horizon"""
        results = {"success": 0, "failed": 0}
        schedules = self.fhir_client.search("Schedule", {})
        
        if not schedules or 'entry' not in schedules:
            self.logger.warning("No schedules found to update")
            return results

        for entry in schedules.get('entry', []):
            schedule = entry.get('resource', {})
            schedule_id = schedule.get('id')
            try:
                schedule['planningHorizon'] = {
                    "start": "2024-01-01T00:00:00Z",
                    "end": "2050-12-31T23:59:59Z"
                }
                if self.fhir_client.update("Schedule", schedule_id, schedule):
                    results["success"] += 1
                else:
                    results["failed"] += 1
            except Exception as e:
                results["failed"] += 1
                self.logger.error(f"Error updating schedule {schedule_id}: {str(e)}")

        return results

    def create_slots(self, schedule_id, start_date="2024-01-01", end_date="2050-12-31"):
        """Creates slots for a given schedule between start and end dates"""
        try:
            start = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            end = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            current = start
            
            while current < end:
                if 9 <= current.hour < 17:  # Business hours
                    slot = {
                        "resourceType": "Slot",
                        "schedule": {"reference": f"Schedule/{schedule_id}"},
                        "status": "free",
                        "start": current.isoformat() + 'Z',
                        "end": (current + timedelta(minutes=30)).isoformat() + 'Z'
                    }
                    self.fhir_client.create("Slot", slot)
                
                current += timedelta(minutes=30)
                
            return {"status": "success", "message": "Slots created successfully"}
        except Exception as e:
            self.logger.error(f"Error creating slots: {str(e)}")
            return {"status": "error", "message": str(e)}

# Initialize Schedule Manager
def search_available_slots(practitioner_id, datetime_requested):
    """Search for available slots for a practitioner at a specific time"""
    try:
        logger.info(f"Searching for slots for practitioner {practitioner_id} at {datetime_requested}")
        
        fhir_client = app_config.get_fhir_client()
        if not fhir_client:
            logger.error("FHIR client is None")
            return []
            
        # First, get or create the schedule
        schedule_search = fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_search or 'entry' not in schedule_search or not schedule_search['entry']:
            logger.info(f"No schedule found for practitioner {practitioner_id}, creating new schedule")
            schedule = create_practitioner_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return []
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_search['entry'][0]['resource']['id']
        
        # Ensure slots exist for the requested date
        create_slots_if_needed(schedule_id, datetime_requested)
        
        # Search for specific slot
        start_time = datetime_requested
        start_range = start_time - timedelta(minutes=30)
        end_range = start_time + timedelta(minutes=30)
        
        slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_range.isoformat()}&le{end_range.isoformat()}",
            "status": "free"
        })
        
        if not slots or 'entry' not in slots:
            logger.info(f"No slots found for time {start_time}")
            return []
            
        return slots['entry']

    except Exception as e:
        logger.error(f"Error searching for slots: {str(e)}", exc_info=True)
        return []

def create_slots_if_needed(schedule_id, target_datetime):
    """Create slots for a specific date if they don't exist"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        # Convert to start of day
        start_of_day = target_datetime.replace(hour=9, minute=0, second=0, microsecond=0)
        end_of_day = target_datetime.replace(hour=17, minute=0, second=0, microsecond=0)
        
        # Check if slots already exist
        existing_slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}&le{end_of_day.isoformat()}"
        })
        
        if not existing_slots or 'entry' not in existing_slots or not existing_slots['entry']:
            logger.info(f"Creating slots for {start_of_day.date()}")
            current_time = start_of_day
            
            while current_time < end_of_day:
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current_time.isoformat(),
                    "end": (current_time + timedelta(minutes=30)).isoformat()
                }
                
                try:
                    fhir_client.create("Slot", slot)
                    logger.debug(f"Created slot for {current_time.isoformat()}")
                except Exception as e:
                    logger.error(f"Failed to create slot for {current_time.isoformat()}: {str(e)}")
                
                current_time += timedelta(minutes=30)
            
            return True
        
        return True
        
    except Exception as e:
        logger.error(f"Error creating slots: {str(e)}", exc_info=True)
        return False
    

schedule_manager = ScheduleManager(fhir_client, logger)
def get_appointment_schedule(practitioner_id):
    """Retrieve the appointment schedule for a practitioner."""
    return fhir_client.search("Schedule", {"actor": f"Practitioner/{practitioner_id}"})


def create_practitioner_schedule(practitioner_id):
    """Creates a new schedule for a practitioner"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "serviceType": [{"text": "Primary Care Physician"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": datetime.now(ZoneInfo("UTC")).isoformat(),
                "end": (datetime.now(ZoneInfo("UTC")) + timedelta(days=90)).isoformat()
            }
        }
        
        return fhir_client.create("Schedule", schedule)
        
    except Exception as e:
        logger.error(f"Error creating schedule: {str(e)}", exc_info=True)
        return None

def create_slots_for_date(schedule_id, date):
    """
    Creates slots for a specific date only.
    """
    try:
        # Convert to clinic timezone if not already
        clinic_tz = ZoneInfo("America/New_York")
        if isinstance(date, str):
            date = datetime.fromisoformat(date.replace('Z', '+00:00'))
        date = date.astimezone(clinic_tz)
        
        # Start and end times in clinic timezone
        current = datetime.combine(date.date(), time(9, 0), tzinfo=clinic_tz)
        end_time = datetime.combine(date.date(), time(17, 0), tzinfo=clinic_tz)
        
        created_slots = []
        while current < end_time:
            if current.weekday() < 5:  # Weekdays only
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current.isoformat(),
                    "end": (current + timedelta(minutes=30)).isoformat()
                }
                created = fhir_client.create("Slot", slot)
                if created:
                    created_slots.append(created)
            current += timedelta(minutes=30)
            
        logger.info(f"Created {len(created_slots)} slots for date {date.date()}")
        return True
    except Exception as e:
        logger.error(f"Error creating slots: {e}", exc_info=True)
        return False
    
def ensure_extended_schedule(practitioner_id, requested_date):
    """
    Ensures schedule exists and has slots for the requested date.
    Creates schedule and slots if needed.
    """
    try:
        schedule_manager = ScheduleManager(app_config.get_fhir_client(), logger)
        
        # Search for existing schedule
        schedule_results = schedule_manager.fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_results or 'entry' not in schedule_results:
            # Create new schedule
            schedule = schedule_manager.create_unlimited_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return False
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_results['entry'][0]['resource']['id']
        
        # Create slots for the date if they don't exist
        start_of_day = requested_date.replace(hour=9, minute=0, second=0, microsecond=0)
        slots = schedule_manager.fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}"
        })
        
        if not slots or 'entry' not in slots:
            return create_slots_for_date(schedule_id, requested_date)
            
        return True
        
    except Exception as e:
        logger.error(f"Error ensuring schedule: {str(e)}", exc_info=True)
        return False
def find_next_available_slots(practitioner_id, from_datetime, limit=5):
    """
    Finds the next available slots, checking for existing appointments.
    """
    try:
        logger.debug(f"Finding next available slots for practitioner {practitioner_id} from {from_datetime}")
        
        # Convert input datetime
        from_dt = datetime.fromisoformat(from_datetime.replace('Z', '+00:00'))
        end_dt = from_dt + timedelta(days=30)  # Look ahead 30 days
        
        # Get all existing appointments within the date range
        appointment_params = {
            'practitioner': f"Practitioner/{practitioner_id}",
            'date': f"ge{from_dt.isoformat()}&le{end_dt.isoformat()}",
            'status': 'booked,pending'
        }
        existing_appointments = fhir_client.search('Appointment', appointment_params)
        booked_times = set()
        
        if existing_appointments and 'entry' in existing_appointments:
            for appt in existing_appointments['entry']:
                start_time = appt['resource'].get('start')
                if start_time:
                    booked_times.add(start_time)
        
        available_slots = []
        current = from_dt
        
        while current <= end_dt and len(available_slots) < limit:
            # Skip weekends
            if current.weekday() >= 5:
                current += timedelta(days=1)
                continue
                
            # Check each time slot during business hours
            day_start = current.replace(hour=9, minute=0, second=0, microsecond=0)
            day_end = current.replace(hour=17, minute=0, second=0, microsecond=0)
            
            slot_time = day_start
            while slot_time < day_end:
                # Skip if slot is already booked
                if slot_time.isoformat() not in booked_times:
                    available_slots.append(slot_time.strftime("%A, %B %d, %Y at %I:%M %p"))
                    if len(available_slots) >= limit:
                        break
                slot_time += timedelta(minutes=30)
                
            current += timedelta(days=1)
        
        return available_slots
        
    except Exception as e:
        logger.error(f"Error in find_next_available_slots: {str(e)}")
        return []
    
def get_patient_appointments(patient_id):
    """Get all upcoming appointments for a patient"""
    try:
        fhir_client = app_config.get_fhir_client()
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        
        response = fhir_client.search("Appointment", {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "_sort": "date",
            "_count": 10
        })
        
        if not response or 'entry' not in response:
            return []
            
        return response['entry']
        
    except Exception as e:
        logger.error(f"Error getting patient appointments: {str(e)}", exc_info=True)
        return []
    
@shared_task
def process_medication_reminders():
    """Process all due medication reminders."""
    reminder_service = MedicationAdherenceReminderService()
    current_time = get_current_time()
    
    try:
        due_reminders = reminder_service.get_due_reminders(current_time)
        
        for reminder in due_reminders:
            try:
                send_reminder(reminder)
            except Exception as e:
                logger.error(f"Failed to send reminder for patient {reminder['patient_id']}: {str(e)}")
                
    except Exception as e:
        logger.error(f"Failed to process medication reminders: {str(e)}")
        raise

async def send_reminder(reminder):
    """Send individual reminder message."""
    from ..handlers.chat_handler import ChatHandler
    
    chat_handler = ChatHandler(session_data={}, user_message="", user_id=None)
    message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
    
    await chat_handler.send_message(
        to_number=reminder["phone_number"], 
        message=message
    )

# Add to your CELERYBEAT_SCHEDULE in settings or scheduler config
CELERYBEAT_SCHEDULE = {
    # ... your existing scheduled tasks ...
    'morning-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=9, minute=0)
    },
    'afternoon-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=14, minute=0)
    },
    'evening-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=20, minute=0)
    }
}
print ("37")

================
File: screening_guideline_service.py
================
"""
screening_guideline_service.py

Service for determining if a patient should undergo specific screening procedures
based on their age, risk factors, and medical history.
"""

import logging
from datetime import datetime
from typing import Dict, Tuple, Optional, Any, List

logger = logging.getLogger(__name__)

class ScreeningGuidelineService:
    """
    Service that implements evidence-based screening guidelines.
    Determines if a patient should undergo specific screening procedures
    based on their age, risk factors, and medical history.
    """
    
    # Age-based screening guidelines (based on USPSTF recommendations)
    COLONOSCOPY_MIN_AGE = 45
    MAMMOGRAM_MIN_AGE = 40
    PSA_MIN_AGE = 55
    
    def __init__(self):
        # Initialize any needed resources
        pass
        
    def should_get_screening(self, 
                            screening_type: str, 
                            patient_data: Optional[Dict[str, Any]] = None) -> Tuple[bool, str]:
        """
        Determine if a patient should get a specific screening based on guidelines
        
        Args:
            screening_type: Type of screening (colonoscopy, mammogram, etc.)
            patient_data: Patient FHIR data dictionary
            
        Returns:
            Tuple of (recommendation boolean, explanation string)
        """
        screening_type = screening_type.lower()
        
        if not patient_data:
            return False, "Unable to provide a personalized recommendation without patient information."
        
        # Calculate patient age
        patient_age = self._calculate_age(patient_data)
        if patient_age is None:
            return False, "Unable to determine your age from record. Please consult your healthcare provider."
        
        # Check for specific screening types
        if "colonoscopy" in screening_type:
            return self._evaluate_colonoscopy_need(patient_age, patient_data)
        elif "mammogram" in screening_type:
            return self._evaluate_mammogram_need(patient_age, patient_data)
        elif any(term in screening_type for term in ["psa", "prostate"]):
            return self._evaluate_prostate_screening_need(patient_age, patient_data)
        else:
            return False, f"Specific guidelines for {screening_type} screening are not available. Please consult your healthcare provider."
    
    def _calculate_age(self, patient_data: Dict[str, Any]) -> Optional[int]:
        """Calculate patient age from birth date in FHIR data"""
        try:
            if "birthDate" in patient_data:
                birth_date = datetime.fromisoformat(patient_data["birthDate"].replace('Z', '+00:00'))
                today = datetime.now()
                age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                return age
            return None
        except (ValueError, TypeError):
            logger.error("Unable to parse birthDate from patient data")
            return None
    
    def _has_risk_factors(self, patient_data: Dict[str, Any], condition_list: List[str]) -> bool:
        """Check if patient has specific risk factors based on conditions"""
        try:
            # Check if there are conditions in the patient data
            if "conditions" in patient_data and isinstance(patient_data["conditions"], list):
                conditions = patient_data["conditions"]
                for condition in conditions:
                    if "code" in condition and "text" in condition["code"]:
                        condition_text = condition["code"]["text"].lower()
                        if any(risk.lower() in condition_text for risk in condition_list):
                            return True
            return False
        except Exception as e:
            logger.error(f"Error checking risk factors: {str(e)}")
            return False
    
    def _evaluate_colonoscopy_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs a colonoscopy based on age and risk factors"""
        # List of risk factors that might necessitate earlier or more frequent screening
        colon_risk_factors = [
            "colorectal cancer", "colon cancer", "rectal cancer", "polyp", 
            "inflammatory bowel disease", "crohn", "ulcerative colitis",
            "lynch syndrome", "familial adenomatous polyposis"
        ]
        
        # Check for family history
        has_family_history = False
        if "family_history" in patient_data and isinstance(patient_data["family_history"], list):
            for history in patient_data["family_history"]:
                if any(risk in str(history).lower() for risk in colon_risk_factors):
                    has_family_history = True
                    break
        
        # Check for personal risk factors
        has_risk_factors = self._has_risk_factors(patient_data, colon_risk_factors)
        
        # Make recommendation based on guidelines
        if age >= self.COLONOSCOPY_MIN_AGE:
            return True, f"Based on your age ({age}), the US Preventive Services Task Force recommends colorectal cancer screening starting at age {self.COLONOSCOPY_MIN_AGE}."
        elif has_risk_factors or has_family_history:
            return True, "Based on your medical or family history, you may need earlier colorectal cancer screening. Please consult with your healthcare provider."
        else:
            return False, f"Current guidelines don't recommend routine colonoscopy screening before age {self.COLONOSCOPY_MIN_AGE} unless you have specific risk factors."

    def _evaluate_mammogram_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs a mammogram based on age and risk factors"""
        # Implementation similar to colonoscopy evaluation
        gender = patient_data.get("gender", "").lower()
        
        if gender == "male":
            return False, "Routine mammogram screening is not typically recommended for men, but please consult your provider if you have specific concerns."
        
        # Check age and risk factors
        if age >= self.MAMMOGRAM_MIN_AGE:
            return True, f"Based on your age ({age}), mammogram screening is recommended starting at age {self.MAMMOGRAM_MIN_AGE}."
        else:
            return False, f"Current guidelines don't recommend routine mammogram screening before age {self.MAMMOGRAM_MIN_AGE} unless you have specific risk factors."
    
    def _evaluate_prostate_screening_need(self, age: int, patient_data: Dict[str, Any]) -> Tuple[bool, str]:
        """Evaluate if patient needs prostate screening"""
        gender = patient_data.get("gender", "").lower()
        
        if gender != "male":
            return False, "Prostate cancer screening is only applicable to men."
            
        if age >= self.PSA_MIN_AGE:
            return True, f"For men aged {self.PSA_MIN_AGE} and older, discussing prostate cancer screening with your doctor is recommended to make an informed decision."
        else:
            return False, f"Current guidelines don't routinely recommend prostate cancer screening for men under age {self.PSA_MIN_AGE} unless you have specific risk factors."

# Singleton instance
screening_guideline_service = ScreeningGuidelineService()

================
File: session.py
================
import logging
import json
from datetime import datetime, timezone, timedelta
import asyncio
import time
from redis import asyncio as aioredis
from contextlib import asynccontextmanager
from django.conf import settings
from .fhir_service import FHIRService
from typing import Optional, Dict, Any, List

logger = logging.getLogger(__name__)

class SessionManager:
    # In-memory session fallback storage with timestamps
    _memory_sessions: Dict[str, Dict] = {}
    
    def __init__(self):
        self._redis_client = None
        self._lock = None  # Initialize in async context
        self.session_timeout = timedelta(seconds=settings.SESSION_TTL_SECONDS)
        self.fhir_service = FHIRService()  # Using existing FHIRService
        self.redis_url = getattr(settings, 'REDIS_URL', 'redis://localhost:6379/0')

    def _get_session_key(self, session_id: str) -> str:
        """Get consistent session key format"""
        return f"chat_session:{session_id}"
        
    def cleanup_expired_memory_sessions(self):
        """
        Remove in-memory sessions that have expired according to TTL
        This prevents memory leaks from abandoned sessions
        """
        now = time.time()
        expired_keys = []
        
        for session_id, session_data in SessionManager._memory_sessions.items():
            # Extract timestamp from session data
            last_interaction = session_data.get('last_interaction')
            if not last_interaction:
                # No timestamp, consider expired
                expired_keys.append(session_id)
                continue
                
            try:
                # Convert ISO timestamp to Unix time
                if isinstance(last_interaction, str):
                    last_time = datetime.fromisoformat(last_interaction.replace('Z', '+00:00'))
                    last_unix_time = last_time.timestamp()
                    
                    # Check if expired based on TTL
                    if now - last_unix_time > settings.SESSION_TTL_SECONDS:
                        expired_keys.append(session_id)
            except (ValueError, TypeError):
                # Invalid timestamp format, consider expired
                expired_keys.append(session_id)
        
        # Remove expired sessions
        for key in expired_keys:
            SessionManager._memory_sessions.pop(key, None)
            
        if expired_keys:
            logger.info(f"Cleaned up {len(expired_keys)} expired memory sessions")

    async def initialize(self):
        """Initialize session manager for ASGI application"""
        self._lock = asyncio.Lock()
        await self._initialize_redis()

    async def _initialize_redis(self):
        """Initialize Redis connection"""
        try:
            if self._redis_client is None:
                self._redis_client = await aioredis.from_url(
                    self.redis_url,
                    encoding='utf-8',
                    decode_responses=True
                )
        except Exception as e:
            logger.error(f"Redis initialization failed: {e}")
            self._redis_client = None

    async def cleanup(self):
        """Cleanup session manager resources"""
        if self._redis_client:
            await self._redis_client.close()
            self._redis_client = None

    @asynccontextmanager
    async def get_redis(self):
        """Get Redis connection with proper error handling"""
        if self._redis_client is None:
            try:
                if self._lock is None:
                    self._lock = asyncio.Lock()
                    
                async with self._lock:
                    if self._redis_client is None:
                        await self._initialize_redis()
            except Exception as e:
                logger.error(f"Redis connection failed: {e}")
                self._redis_client = None
        
        if self._redis_client is not None:
            try:
                yield self._redis_client
            except Exception as e:
                logger.error(f"Redis operation failed: {e}")
                self._redis_client = None
                raise  # Re-raise to ensure proper error handling
        else:
            logger.warning("Redis connection not available, using in-memory storage")
            yield None

    async def get_session(self, session_id: str) -> Dict[str, Any]:
        """Get existing session or create new one"""
        try:
            # Clean up expired memory sessions first
            self.cleanup_expired_memory_sessions()
            
            # Check in-memory sessions
            if session_id in SessionManager._memory_sessions:
                logger.info(f"Using in-memory session for {session_id}")
                return SessionManager._memory_sessions[session_id]
        
            async with self.get_redis() as redis:
                if redis is None:
                    logger.warning("Redis connection not available, using in-memory fallback")
                    # Check again for memory sessions
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    # No session found, create default
                    new_session = await self._create_or_verify_session(session_id)
                    SessionManager._memory_sessions[session_id] = new_session
                    return new_session
                
                session_key = self._get_session_key(session_id)
                try:
                    session_data = await redis.get(session_key)
                    if session_data:
                        parsed_session = json.loads(session_data)
                        # Store in memory for faster access
                        SessionManager._memory_sessions[session_id] = parsed_session
                        return parsed_session
                except Exception as e:
                    logger.error(f"Error reading session: {e}")
                    # Check memory fallback
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    raise
                
                # Create new session
                new_session = await self._create_or_verify_session(session_id)
                try:
                    await redis.set(
                        session_key,
                        json.dumps(new_session),
                        ex=settings.SESSION_TTL_SECONDS
                    )
                    # Store in memory too
                    SessionManager._memory_sessions[session_id] = new_session
                except Exception as e:
                    logger.error(f"Error saving new session: {e}")
                    # Still store in memory
                    SessionManager._memory_sessions[session_id] = new_session
                return new_session
                
        except Exception as e:
            logger.error(f"Session operation failed: {e}")
            raise
    
    async def update_session(self, session_id: str, session_data: Dict[str, Any]) -> None:
        """Update existing session"""
        try:
            # Update last interaction time
            session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
            
            async with self.get_redis() as redis:
                if redis is None:
                    # Redis not available, use in-memory storage
                    logger.warning("Redis connection not available, using in-memory storage")
                    # Store in memory
                    SessionManager._memory_sessions[session_id] = session_data
                    return
                
                # Store updated session using consistent key format
                session_key = self._get_session_key(session_id)
                await redis.set(
                    session_key,
                    json.dumps(session_data),
                    ex=settings.SESSION_TTL_SECONDS
                )
                # Update memory cache
                SessionManager._memory_sessions[session_id] = session_data
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            # Fall back to in-memory storage
            SessionManager._memory_sessions[session_id] = session_data

    async def reset_session(self, session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
        """Reset session while optionally preserving patient data"""
        try:
            current_session = await self.get_session(session_id)
            patient_data = current_session.get('patient') if preserve_patient else None
            
            new_session = self._create_default_session(session_id)
            if patient_data:
                new_session['patient'] = patient_data
            
            await self.save_session(session_id, new_session)
            return new_session
            
        except Exception as e:
            logger.error(f"Error resetting session: {e}")
            return self._create_default_session(session_id)

    async def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """Save complete session data"""
        try:
            # Update last interaction time
            session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
            
            # Update memory cache
            SessionManager._memory_sessions[session_id] = session_data
            
            async with self.get_redis() as redis:
                if redis is None:
                    return False
                
                await redis.set(
                    self._get_session_key(session_id),
                    json.dumps(session_data),
                    ex=settings.SESSION_TTL_SECONDS
                )
                return True
                
        except aioredis.RedisError as e:
            logger.error(f"Redis error saving session: {e}")
            return False
        except Exception as e:
            logger.error(f"Error saving session: {e}")
            return False

    async def _create_or_verify_session(self, session_id: str) -> Dict[str, Any]:
        """Creates a new session and verifies patient data if email provided"""
        session = self._create_default_session(session_id)
        
        # Verify patient if session_id looks like an email
        if '@' in session_id:
            try:
                patient_data = await self.fhir_service.get_patient_by_email(session_id)
                if patient_data:
                    logger.info(f"Found patient data for {session_id}")
                    session['patient'] = patient_data
            except Exception as e:
                logger.error(f"Error verifying patient: {e}")
        
        return session

    def _create_default_session(self, session_id: str) -> Dict[str, Any]:
        """Create a default session with all required fields"""
        return {
            'id': session_id,
            'greeted': False,
            'booking_state': None,
            'cancellation_options': None,
            'requested_datetime': None,
            'last_interaction': datetime.now(timezone.utc).isoformat(),
            'verified': False,
            'patient': None
        }

    async def _verify_patient(self, session_id):
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                return patient_data
            return None
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return None

    async def verify_patient(self, session_id: str) -> bool:
        """Verify patient exists in FHIR"""
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                self.session['patient'] = patient_data
                self.session['verified'] = True
                return True
            return False
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return False

# Global instance
session_manager = SessionManager()

# For backwards compatibility with existing imports
async def get_session(session_id: str) -> Dict[str, Any]:
    return await session_manager.get_session(session_id)

async def update_session(session_id: str, updates: Dict[str, Any]) -> bool:
    # Added basic validation to avoid sending None as updates
    if not session_id or not updates:
        logger.error("Invalid parameters for update_session: session_id or updates missing")
        return False
        
    # Create a new dict to avoid modifying the original
    safe_updates = {}
    for k, v in updates.items():
        if k and v is not None:  # Only include non-None values
            safe_updates[k] = v
    
    return await session_manager.update_session(session_id, safe_updates)

async def reset_session(session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
    return await session_manager.reset_session(session_id, preserve_patient)

async def save_session(session_id: str, session_data: Dict[str, Any]) -> bool:
    return await session_manager.save_session(session_id, session_data)

================
File: symptom_guidance_service.py
================
# chatbot/views/services/symptom_guidance_service.py

import logging
from django.conf import settings
import json
from ..utils.formatters import format_message
from .fhir_service import FHIRService
from datetime import datetime
from asgiref.sync import sync_to_async
from ...utils.openai_manager import openai_manager
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
class SymptomGuidanceService:
    def __init__(self):
        self.fhir_service = FHIRService()
        
        # Define red flag symptoms
        self.RED_FLAGS = {
            'chest_pain': [
                'chest pain', 'chest tightness', 'crushing pain',
                'heart attack', 'cardiac', 'heart pain'
            ],
            'breathing': [
                'cannot breathe', 'difficulty breathing', 'shortness of breath',
                'struggling to breathe', 'gasping', 'choking'
            ],
            'stroke': [
                'face drooping', 'arm weakness', 'speech difficulty',
                'numbness one side', 'sudden confusion', 'sudden dizziness'
            ],
            'consciousness': [
                'unconscious', 'passed out', 'fainting',
                'not responding', 'lost consciousness'
            ],
            'bleeding': [
                'severe bleeding', 'heavy bleeding', 'uncontrolled bleeding',
                'bleeding heavily', 'blood loss'
            ],
            'allergic': [
                'anaphylaxis', 'allergic reaction', 'throat swelling',
                'cannot swallow', 'severe allergy'
            ]
        }
        
        # Risk levels with their descriptions
        self.RISK_LEVELS = {
            'EMERGENCY': {
                'level': 4,
                'action': 'CALL EMERGENCY SERVICES IMMEDIATELY (112 or 999)',
                'urgency': 'Immediate emergency attention required'
            },
            'HIGH': {
                'level': 3,
                'action': 'Seek immediate medical attention or go to the nearest urgent care center',
                'urgency': 'Urgent medical attention recommended'
            },
            'MEDIUM': {
                'level': 2,
                'action': 'Consider visiting urgent care or booking an urgent appointment',
                'urgency': 'Prompt medical attention advised'
            },
            'LOW': {
                'level': 1,
                'action': 'Schedule a routine appointment with your healthcare provider',
                'urgency': 'Non-urgent medical attention'
            }
        }

    async def red_flag_checker(self, symptom_description):
        """
        Check for red flag symptoms that require immediate emergency attention
        Returns: tuple (bool, list of matched red flags)
        """
        try:
            symptom_description = symptom_description.lower()
            matched_flags = []

            for category, phrases in self.RED_FLAGS.items():
                if any(phrase in symptom_description for phrase in phrases):
                    matched_flags.append(category)
                    await sync_to_async(logger.warning)(f"Red flag detected: {category} in symptom: {symptom_description}")

            return bool(matched_flags), matched_flags

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in red flag checking: {str(e)}")
            return True, ['error_defaulting_to_emergency']  # Err on side of caution

    async def symptom_analyzer(self, symptom_description, patient_data=None):
        """
        Analyze symptoms using OpenAI for severity assessment
        Returns: dict with analysis results
        """
        try:
            prompt = await sync_to_async(self._build_analysis_prompt)(symptom_description, patient_data)
            
            response = await openai_manager.chat_completion(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a medical triage assistant. Always err on the side of caution."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )

            analysis = json.loads(response.choices[0].message.content)
            await sync_to_async(logger.info)(f"Symptom analysis completed: {analysis}")
            return analysis

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in symptom analysis: {str(e)}")
            return {
                'severity': 'HIGH',
                'confidence': 0.0,
                'recommendation': 'Due to analysis error, recommending careful evaluation',
                'error': str(e)
            }

    async def risk_level_determiner(self, symptom_analysis, red_flags=None):
        """
        Determine risk level based on symptom analysis and red flags
        Returns: dict with risk assessment
        """
        try:
            if red_flags:
                return {
                    'level': 'EMERGENCY',
                    'action': self.RISK_LEVELS['EMERGENCY']['action'],
                    'urgency': self.RISK_LEVELS['EMERGENCY']['urgency'],
                    'red_flags': red_flags,
                    'timestamp': datetime.utcnow().isoformat()
                }

            # Map severity to risk level
            severity_mapping = {
                'MILD': 'LOW',
                'MODERATE': 'MEDIUM',
                'SEVERE': 'HIGH',
                'CRITICAL': 'EMERGENCY'
            }

            assessed_level = severity_mapping.get(
                symptom_analysis.get('severity', 'SEVERE'),  # Default to SEVERE if unclear
                'HIGH'  # Default to HIGH if mapping fails
            )

            return {
                'level': assessed_level,
                'action': self.RISK_LEVELS[assessed_level]['action'],
                'urgency': self.RISK_LEVELS[assessed_level]['urgency'],
                'confidence': symptom_analysis.get('confidence', 0.0),
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in risk level determination: {str(e)}")
            return {
                'level': 'HIGH',
                'action': self.RISK_LEVELS['HIGH']['action'],
                'urgency': 'Due to assessment error, recommending urgent evaluation',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    async def response_formatter(self, risk_assessment, patient_data=None):
        """
        Format the response based on risk assessment
        Returns: dict with formatted response messages
        """
        try:
            # Standard disclaimer
            disclaimer = (
                "IMPORTANT: This is an automated guidance system and not a medical diagnosis. "
                "If you're unsure or your condition worsens, please seek immediate medical attention."
            )

            # Emergency message template
            if risk_assessment['level'] == 'EMERGENCY':
                messages = [
                    "🚨 EMERGENCY MEDICAL ATTENTION RECOMMENDED 🚨",
                    f"ACTION NEEDED: {risk_assessment['action']}",
                    "Key points:",
                    "- Call emergency services (112 or 999) immediately",
                    "- Do not delay seeking help",
                    "- Stay calm and find a safe location",
                    "",
                    disclaimer
                ]

            # High risk message template
            elif risk_assessment['level'] == 'HIGH':
                messages = [
                    "⚠️ URGENT MEDICAL ATTENTION ADVISED ⚠️",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Next steps:",
                    "- Visit your nearest urgent care center",
                    "- If symptoms worsen, call emergency services",
                    "- Keep someone informed of your condition",
                    "",
                    disclaimer
                ]

            # Medium risk message template
            elif risk_assessment['level'] == 'MEDIUM':
                messages = [
                    "🏥 MEDICAL ATTENTION RECOMMENDED",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Options:",
                    "- Visit an urgent care center",
                    "- Book an urgent appointment with your doctor",
                    "- Monitor your symptoms closely",
                    "",
                    disclaimer
                ]

            # Low risk message template
            else:
                messages = [
                    "ℹ️ MEDICAL GUIDANCE",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Book a routine appointment",
                    "- Monitor your symptoms",
                    "- If condition worsens, seek urgent care",
                    "",
                    disclaimer
                ]

            # Add local emergency numbers if available
            if patient_data and 'address' in patient_data:
                country = patient_data['address'][0].get('country', 'Unknown')
                messages.append(f"\nLocal emergency numbers for {country}:")
                if country == "Italy":
                    messages.append("Emergency: 112")
                    messages.append("Medical Emergency: 118")
                elif country == "United Kingdom":
                    messages.append("Emergency: 999 or 112")
                    messages.append("NHS Non-emergency: 111")

            return {
                'messages': messages,
                'risk_level': risk_assessment['level'],
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error formatting response: {str(e)}")
            return {
                'messages': [
                    "⚠️ ERROR IN PROCESSING",
                    "For your safety, please seek medical attention or call emergency services if you're concerned.",
                    "",
                    disclaimer
                ],
                'risk_level': 'ERROR',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    def _build_analysis_prompt(self, symptom_description, patient_data):
        """Helper method to build the analysis prompt"""
        base_prompt = f"""
        Analyze the following symptoms and provide a severity assessment.
        Symptoms: {symptom_description}
        
        Respond in the following JSON format:
        {{
            "severity": "MILD|MODERATE|SEVERE|CRITICAL",
            "confidence": <float 0-1>,
            "recommendation": <string>,
            "key_symptoms": [<list of key symptoms identified>],
            "reasoning": <string explaining assessment>
        }}
        
        Always err on the side of caution. If in doubt, rate severity higher.
        """

        if patient_data:
            # Add relevant patient information to the prompt
            age = None
            if 'birthDate' in patient_data:
                birth_date = datetime.strptime(patient_data['birthDate'], '%Y-%m-%d')
                age = (datetime.now() - birth_date).days // 365

            additional_context = f"""
            Patient Context:
            - Age: {age if age else 'Unknown'} years
            - Gender: {patient_data.get('gender', 'Unknown')}
            """
            base_prompt += additional_context

        return base_prompt

    async def provide_specific_info(self, user_query):
        """
        Provide detailed information addressing the user's specific query.
        Uses OpenAI to generate a structured and informative response.
        """
        try:
            prompt = f"""
            You are a medical information assistant. Provide a detailed, accurate, and easy-to-understand answer to the following question:

            "{user_query}"

            Structure your response with numbered points, covering the following aspects:
            1. Explanation of the condition: what it is, what causes it, how it's transmitted, etc.
            2. Common symptoms.
            3. Diagnostic methods.
            4. Treatment options.
            5. When to seek medical attention.

            Include a disclaimer at the end stating that this information is for educational purposes only and should not replace professional medical advice.
            """

            response = await openai.ChatCompletion.acreate(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a helpful and accurate medical information assistant."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=500
            )

            detailed_info = response.choices[0].message.content.strip()

            return {
                'messages': [detailed_info]
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in provide_specific_info: {str(e)}")
            return {
                'messages': ["I'm sorry, I couldn't retrieve detailed information at this time."]
            }
print ("41")



================================================================
End of Codebase
================================================================
