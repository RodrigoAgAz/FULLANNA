This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Django_app/
  anna_project/
    __init__.py
    asgi.py
    celery.py
    settings.py
    urls.py
    wsgi.py
  chatbot/
    fhir/
      utils.py
    views/
      api/
        endpoints.py
        test_explicit.py
        webhooks.py
      handlers/
        appointment_handler.py
        chat_handler.py
        context_manager.py
        debug_utils.py
        medical_handler.py
        medication_reminder_handler.py
        symptom_guidance_handler.py
      services/
        fhir_service.py
        intent_service.py
        language_service.py
        medication_service.py
        personalized_medical_advice_service.py
        post_appointment_checkin_service.py
        post_discharge_service.py
        preventive_care_reminder_service.py
        scheduler.py
        session.py
        symptom_guidance_service.py
      utils/
        constants.py
        datetime_utils.py
        formatters.py
        shared.py
      config.py
      utils.py
    __init__.py
    admin.py
    apps.py
    chat_client.py
    f&f_creation.py
    middleware.py
    models.py
    new_intent_test.py
    tasks.py
    test_sms.py
    upload_test_results.py
    urls.py
  .cursorignore
  .env
  application.yaml
  custom_asgi.py
  debug_init.py
  docker-compose.yml
  fhir_client_module.py
  find_messages.py
  manage.py
  requirements.txt
  test_chat_view.py
  test_django.py
  test_endpoint.py
  test_explicit.py
  test_handler.py
.gitignore
.repomixignore
CLAUDE.md
play.py
product.txt
test_async.py

================================================================
Files
================================================================

================
File: Django_app/anna_project/__init__.py
================
from .celery import app as celery_app

__all__ = ('celery_app',)

================
File: Django_app/anna_project/asgi.py
================
# Django_app/anna_project/asgi.py
"""
ASGI config for anna_project.
It exposes the ASGI callable as a module-level variable named 'application'.
"""

import os
print(f"DEBUG: DJANGO_SETTINGS_MODULE at ASGI startup = {os.environ.get('DJANGO_SETTINGS_MODULE')}")

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')

# Import Django ASGI application first
from django.core.asgi import get_asgi_application

print("1 - Loading Django ASGI application")

# Get the Django ASGI application
application = get_asgi_application()

print("2 - Django ASGI application loaded")

# Import any other routing frameworks if needed
try:
    from channels.routing import ProtocolTypeRouter
    from channels.auth import AuthMiddlewareStack
    
    print("3 - Setting up protocol router")
    # Set up ProtocolTypeRouter if using channels
    application = ProtocolTypeRouter({
        "http": application,  # Django ASGI application
    })
    print("4 - Protocol router setup complete")
except ImportError:
    # If channels isn't available, just use the Django ASGI application
    print("Channels not available, using only Django ASGI application")

================
File: Django_app/anna_project/celery.py
================
# chatbot/celery.py (Create this file in your Django project root)

from __future__ import absolute_import, unicode_literals
import os
from celery import Celery
from django.conf import settings
from celery.schedules import crontab

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
print ("3")
# Create the Celery app
app = Celery('anna_project')

# Configure Celery using Django settings
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs
app.autodiscover_tasks()

# Define your beat schedule
app.conf.beat_schedule = {
    'send-post-discharge-reminders-hourly': {
        'task': 'chatbot.tasks.send_post_discharge_reminders',
        'schedule': crontab(minute=0, hour='*/1'),  # Every hour
    },
    'example-task': {
        'task': 'your_app.tasks.example_task',
        'schedule': 300.0,  # Run every 300 seconds (5 minutes)
    }
}
app.conf.beat_schedule = {
    'send-post-discharge-reminders-hourly': {
        'task': 'chatbot.tasks.send_post_discharge_reminders',
        'schedule': crontab(minute=0, hour='*/1'),
    },
    'example-task': {
        'task': 'your_app.tasks.example_task',
        'schedule': 300.0,
    },
    'preventive-care-reminders-daily': {
        'task': 'chatbot.tasks.process_preventive_care_reminders',
        'schedule': crontab(hour=8, minute=0),  # runs daily at 8 AM
    },
}


app.conf.beat_schedule.update({
    'process-medication-reminders-every-hour': {
         'task': 'chatbot.tasks.process_medication_reminders_task',
         'schedule': crontab(minute=0, hour='*/2'),  # run every 2 hour
    },
    
})

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
print("4")

================
File: Django_app/anna_project/settings.py
================
# anna_project/settings.py

import os
from pathlib import Path
from dotenv import load_dotenv
from celery.schedules import crontab
# Load environment variables
load_dotenv()

# Set the base directory
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv('DEBUG', 'False') == 'True'

ALLOWED_HOSTS = ['*']  # Adjust as needed for production
print ("5")
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',       # Added
    'django.contrib.staticfiles',
    'django.contrib.messages',
    'rest_framework',
    'chatbot', 
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'chatbot.middleware.CustomCsrfMiddleware',  # Replace the default CSRF middleware
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'anna_project.urls'  # Ensure this line is present

# Add ASGI application path
ASGI_APPLICATION = 'anna_project.asgi.application'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],  # Add template directories if needed
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'anna_project.wsgi.application'

# Database
# Using SQLite for simplicity. Configure as needed.
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


REDIS_HOST = os.getenv('REDIS_HOST', 'redis')
REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
REDIS_DB = int(os.getenv('REDIS_DB', 0))

# OpenAI API Key
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

# FHIR Server URL
FHIR_SERVER_URL = os.getenv('FHIR_SERVER_URL', 'http://localhost:8080/fhir/')
FHIR_VERIFY_SSL = False  # Set to False for development, True for production

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    # Add more validators as needed
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'  # Adjust as needed
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'app.log'),
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'chatbot': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}


# Twilio Settings
TWILIO_ACCOUNT_SID = os.getenv('TWILIO_ACCOUNT_SID') 
TWILIO_AUTH_TOKEN = os.getenv('TWILIO_AUTH_TOKEN')
TWILIO_PHONE_NUMBER = os.getenv('TWILIO_PHONE_NUMBER') 



CELERY_BROKER_URL = f'redis://{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}'  # Using existing Redis settings
CELERY_RESULT_BACKEND = CELERY_BROKER_URL

CELERY_BEAT_SCHEDULE = {
    'morning-medication-reminders': {
        'task': 'chatbot.views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=9, minute=0),
    },
    'afternoon-medication-reminders': {
        'task': 'chatbot.views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=14, minute=0),
    },
    'evening-medication-reminders': {
        'task': 'chatbot.views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=20, minute=0),
    },
}

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
    ],
    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'rest_framework.negotiation.DefaultContentNegotiation',
}

# CSRF settings
CSRF_COOKIE_NAME = "csrftoken"
CSRF_HEADER_NAME = "HTTP_X_CSRFTOKEN"
CSRF_TRUSTED_ORIGINS = ['http://localhost:8000']  # Add your domains




print("6")

================
File: Django_app/anna_project/urls.py
================
# anna_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('chatbot/', include('chatbot.urls')),  # Make sure this is here
]

================
File: Django_app/anna_project/wsgi.py
================
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')

application = get_wsgi_application()

================
File: Django_app/chatbot/fhir/utils.py
================
import requests
import json
from django.conf import settings
import logging
import openai
from ..views.utils.constants import OPENAI_MODEL

logger = logging.getLogger(__name__)

class FHIRClient:
    def __init__(self):
        self.base_url = settings.FHIR_SERVER_URL
        self.headers = {
            'Content-Type': 'application/fhir+json',
            'Accept': 'application/fhir+json'
        }
        self.timeout = settings.FHIR_SERVER_TIMEOUT

    def get_patient_by_phone(self, phone_number):
        """Find patient by phone number"""
        try:
            response = requests.get(
                f"{self.base_url}/Patient",
                params={
                    'telecom': f'phone|{phone_number}'
                },
                headers=self.headers,
                timeout=self.timeout
            )
            if response.status_code == 200:
                bundle = response.json()
                if bundle.get('entry', []):
                    return bundle['entry'][0]['resource']
            return None
        except Exception as e:
            logger.error(f"Error fetching patient by phone: {e}")
            return None

    def get_patient_appointments(self, patient_id):
        """Get patient's appointments"""
        try:
            response = requests.get(
                f"{self.base_url}/Appointment",
                params={
                    'patient': f'Patient/{patient_id}',
                    '_sort': '-date',
                    '_count': '5'
                },
                headers=self.headers,
                timeout=self.timeout
            )
            if response.status_code == 200:
                return response.json()
            return None
        except Exception as e:
            logger.error(f"Error fetching appointments: {e}")
            return None

    def get_patient_medications(self, patient_id):
        """Get patient's current medications"""
        try:
            response = requests.get(
                f"{self.base_url}/MedicationStatement",
                params={
                    'subject': f'Patient/{patient_id}',
                    'status': 'active'
                },
                headers=self.headers,
                timeout=self.timeout
            )
            if response.status_code == 200:
                return response.json()
            return None
        except Exception as e:
            logger.error(f"Error fetching medications: {e}")
            return None

def detect_intent(text):
    """Detect intents from user input"""
    try:
        # Prepare the prompt for GPT
        prompt = {
            "messages": [
                {"role": "system", "content": "You are a healthcare chatbot assistant. Analyze the user input and identify the intent and entities."},
                {"role": "user", "content": text}
            ]
        }
        
        # Get response from OpenAI
        response = openai.ChatCompletion.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": "Identify the intent and entities in this message. Valid intents are: greeting, identifier, set_appointment, cancel_appointment, check_appointments, other."},
                {"role": "user", "content": text}
            ]
        )
        
        # Parse the response
        result = json.loads(response.choices[0].message['content'])
        logger.debug(f"OpenAI GPT response: {result}")
        
        return result.get('intents', [])
    except Exception as e:
        logger.error(f"Error detecting intent: {e}")
        return []

================
File: Django_app/chatbot/views/api/endpoints.py
================
from django.http import JsonResponse
import json
import logging
import inspect
from asgiref.sync import sync_to_async
from inspect import iscoroutinefunction

from chatbot.views.services.session import get_session
from chatbot.views.handlers.chat_handler import ChatHandler

logger = logging.getLogger('chatbot')


async def chat(request):
    """Async endpoint that processes chat messages using ChatHandler"""
    print("DEBUG-EP-1: Starting chat endpoint function")
    print(f"DEBUG-EP-REQUEST: URL={request.path}, METHOD={request.method}")
    
    # Debug logging to confirm we're hitting this function
    if request.path == "/chatbot/chat/":
        print("DEBUG-EP-CONTINUING: Passing request to chat handler")
    
    try:
        logger.debug("chat function called")
        print("DEBUG-EP-2: About to read request body")
        body = request.body  # This is bytes
        print("DEBUG-EP-3: Parsed request body")
        data = json.loads(body.decode('utf-8'))  # Decode to string and parse JSON
        user_id = data.get('user_id')
        user_message = data.get('message', '')
        print(f"DEBUG-EP-4: Got user_id={user_id}, message={user_message}")

        print("DEBUG-EP-5: Getting session data")
        session_data = await get_session(user_id)
        print(f"Is ChatHandler.__init__ a coroutine function? {iscoroutinefunction(ChatHandler.__init__)}")
        print("DEBUG-EP-6: Creating ChatHandler")
        handler = ChatHandler(session_data, user_message, user_id)
        print("DEBUG-EP-7: About to initialize handler")
        await handler.initialize()  # Initialize handler
        print("DEBUG-EP-8: Handler initialized")
        
        print("DEBUG-EP-9: About to call handle_message")
        result = await handler.handle_message()  # This needs to be awaited
        print(f"DEBUG-EP-10: handle_message returned, type={type(result)}, is coroutine={inspect.iscoroutine(result)}")
        
        print("DEBUG-EP-11: Processing result")
        # Check if result is a tuple (response, session) or just response
        if isinstance(result, tuple) and len(result) == 2:
            print("DEBUG-EP-12: Result is a tuple")
            response, updated_session = result
        else:
            print("DEBUG-EP-13: Result is not a tuple")
            response = result
            updated_session = session_data
        
        # Ensure we return a JsonResponse object
        print(f"DEBUG-EP-14: Response type is {type(response)}")
        if isinstance(response, dict):
            print("DEBUG-EP-15: Converting dict to JsonResponse")
            final_response = JsonResponse(response)
        elif isinstance(response, JsonResponse):
            print("DEBUG-EP-16: Using JsonResponse directly")
            final_response = response
        else:
            print(f"DEBUG-EP-17: Unexpected response type: {type(response)}")
            logger.error(f"Unexpected response type: {type(response)}")
            final_response = JsonResponse({"messages": ["An unexpected error occurred."]})
            
        print("DEBUG-EP-18: About to return final response")
        print(f"DEBUG-EP-19: Final response type: {type(final_response)}, is coroutine={inspect.iscoroutine(final_response)}")
        return final_response
            
    except Exception as e:
        print(f"DEBUG-EP-ERROR: Exception in chat endpoint: {str(e)}")
        print(f"DEBUG-EP-ERROR-TYPE: Exception type: {type(e)}")
        import traceback
        print(f"DEBUG-EP-ERROR-TRACE: {traceback.format_exc()}")
        logger.error(f"Error handling chat request: {str(e)}", exc_info=True)
        return JsonResponse({"messages": ["Sorry, something went wrong."]})

================
File: Django_app/chatbot/views/api/test_explicit.py
================
"""
Explicit test endpoint to diagnose routing issues
"""
from django.http import JsonResponse

async def explicit_test(request):
    """A very simple test endpoint that returns a specific response"""
    print("EXPLICIT-TEST: This function was called!")
    return JsonResponse({"message": "This is from the explicit test endpoint"})

================
File: Django_app/chatbot/views/api/webhooks.py
================
print("7")

================
File: Django_app/chatbot/views/handlers/appointment_handler.py
================
# chatbot/views/handlers/appointment_handler.py

from datetime import datetime
from zoneinfo import ZoneInfo
from django.conf import settings
from chatbot.views.utils.formatters import get_resource_name
from chatbot.views.utils.datetime_utils import format_datetime_for_user
from chatbot.views.config import config as app_config  # Fixed import
from ..services.session import update_session
from ..services.fhir_service import get_user_appointments, get_practitioner
import logging

logger = logging.getLogger('chatbot')
print("9")
def handle_appointment_query(session, user_message):
    """Handle showing upcoming appointments"""
    try:
        if not session.get('patient'):
            return "Please verify your identity first."
        
        patient_id = session['patient']['id']
        logger.info(f"Fetching appointments for patient {patient_id}")
        
        # Get FHIR client from app_config
        fhir_client = app_config.get_fhir_client()  # Using the correct config
        
        # Build the search parameters
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        search_params = {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "_sort": "date"
        }
        
        # Search for appointments
        logger.debug(f"Searching appointments with params: {search_params}")
        response = fhir_client.search("Appointment", search_params)
        
        if not response or 'entry' not in response or not response['entry']:
            return "You don't have any upcoming appointments scheduled."
        
        # Format appointments
        appointments = []
        for entry in response['entry']:
            appt = entry['resource']
            
            # Skip non-booked appointments
            if appt.get('status') not in ['booked', 'pending']:
                continue
            
            # Get the appointment time
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            local_time = start_time.astimezone(ZoneInfo('America/New_York'))
            formatted_time = local_time.strftime("%A, %B %d, %Y at %I:%M %p %Z")
            
            # Get practitioner info
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('type') == 'Practitioner':
                    pract_ref = participant['actor']['reference']
                    try:
                        pract_id = pract_ref.split('/')[-1]
                        practitioner = fhir_client.read("Practitioner", pract_id)
                        if practitioner and 'name' in practitioner:
                            name_data = practitioner['name'][0] if isinstance(practitioner['name'], list) else practitioner['name']
                            if isinstance(name_data, dict):
                                if 'text' in name_data:
                                    practitioner_name = f"Dr. {name_data['text']}"
                                elif 'family' in name_data:
                                    given = name_data.get('given', [''])[0]
                                    practitioner_name = f"Dr. {given} {name_data['family']}"
                    except Exception as e:
                        logger.error(f"Error getting practitioner details: {str(e)}")
                    break
            
            appointments.append(f"- {formatted_time} with {practitioner_name}")
            if appt.get('description'):
                appointments[-1] += f" ({appt['description']})"
        
        if not appointments:
            return "You don't have any upcoming appointments scheduled."
        
        return "Here are your upcoming appointments:\n\n" + "\n".join(appointments)
        
    except Exception as e:
        logger.error(f"Error handling appointment query: {str(e)}", exc_info=True)
        return "I'm sorry, I couldn't retrieve your appointments at this time. Please try again later."

def handle_appointment_cancellation(session, user_message):
    """Handle appointment cancellation requests"""
    try:
        # Get FHIR client from app_config
        fhir_client = app_config.get_fhir_client()

        if not session.get('patient'):
            return "Please verify your identity first."
            
        patient_id = session['patient']['id']
        logger.debug(f"Handling appointment cancellation for patient {patient_id}")
        
        # If we're already in cancellation mode
        if session.get('cancellation_options'):
            if user_message.isdigit():
                option_num = user_message
                if option_num in session['cancellation_options']:
                    appt_id = session['cancellation_options'][option_num]
                    try:
                        appointment = fhir_client.read("Appointment", appt_id)
                        if appointment:
                            appointment['status'] = 'cancelled'
                            fhir_client.update("Appointment", appt_id, appointment)
                            session.pop('cancellation_options', None)
                            update_session(session['id'], session)
                            return "Your appointment has been cancelled. Is there anything else I can help you with?"
                    except Exception as e:
                        logger.error(f"Error cancelling appointment {appt_id}: {str(e)}")
                        return "There was an error cancelling your appointment. Please try again."
                return "Please select a valid appointment number from the list."
        
        # Get upcoming appointments
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        search_params = {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "status": "booked,pending",
            "_sort": "date"
        }
        
        appointments = fhir_client.search("Appointment", search_params)
        if not appointments or 'entry' not in appointments or not appointments['entry']:
            return "You don't have any upcoming appointments to cancel."
            
        # Create numbered list of appointments
        options = {}
        messages = ["Which appointment would you like to cancel?"]
        
        for i, entry in enumerate(appointments['entry'], 1):
            appt = entry['resource']
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            local_time = start_time.astimezone(ZoneInfo('America/New_York'))
            formatted_time = local_time.strftime("%A, %B %d at %I:%M %p")
            
            # Get practitioner info
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('type') == 'Practitioner':
                    pract_ref = participant['actor']['reference']
                    try:
                        pract = fhir_client.read("Practitioner", pract_ref.split('/')[-1])
                        if pract:
                            practitioner_name = f"Dr. {get_resource_name(pract)}"
                    except Exception as e:
                        logger.error(f"Error getting practitioner: {str(e)}")
            
            messages.append(f"{i}. {formatted_time} with {practitioner_name}")
            options[str(i)] = appt['id']
            
        # Store options in session
        session['cancellation_options'] = options
        update_session(session['id'], session)
        
        return "\n".join(messages)
        
    except Exception as e:
        logger.error(f"Error handling cancellation: {str(e)}")
        return "I'm sorry, I couldn't process your cancellation request at this time. Please try again later."
print ("10")

================
File: Django_app/chatbot/views/handlers/chat_handler.py
================
# chatbot/views/handlers/chat_handler.py

import inspect
import logging
import json
import re
from datetime import datetime, timedelta, time
from zoneinfo import ZoneInfo
from asgiref.sync import sync_to_async
# Django imports
from django.conf import settings
from django.http import JsonResponse
# Third-party imports
from openai import AsyncOpenAI
from twilio.rest import Client
from chatbot.views.services.fhir_service import FHIRService
from fhirclient.models.observation import Observation
from fhirclient.models.diagnosticreport import DiagnosticReport
from chatbot.views.config import config as app_config
from chatbot.views.services.language_service import LanguageService, LanguageHandler
from chatbot.views.services.session import update_session
from chatbot.views.utils.datetime_utils import format_datetime_for_user
from chatbot.views.utils.shared import get_resource_name
from chatbot.views.utils.constants import OPENAI_MODEL
import dateparser
from chatbot.views.services.intent_service import (
    detect_intent,
)
from chatbot.views.services.symptom_guidance_service import SymptomGuidanceService
from chatbot.views.handlers.symptom_guidance_handler import SymptomGuidanceHandler
from chatbot.views.services.personalized_medical_advice_service import (
    PersonalizedMedicalAdviceService,
    AsyncGPT4Client
)
from chatbot.views.handlers.medical_handler import (
    get_complete_medical_record,
)
from chatbot.views.services.fhir_service import (
    get_available_practitioners,
)
from chatbot.views.services.scheduler import search_available_slots, get_patient_appointments

from fhirclient.models.condition import Condition
from fhirclient.models.patient import Patient
from fhirclient.models.immunization import Immunization
from fhirclient.models.bundle import Bundle
from fhirclient.server import FHIRServer
# Removed debug utils imports that were causing issues

from .context_manager import ContextManager  # Import the ContextManager

logger = logging.getLogger(__name__)

MEDICAL_DISCLAIMER = """
This information is for educational purposes only and is not a substitute for professional medical advice.
Always seek the advice of your physician or other qualified health provider with any questions you may have.
"""
print("11")
# Removed @trace_async_calls decorator that was causing issues
class ChatHandler:
    def __init__(self, session_data, user_message, user_id=None):
        # If no user_id is provided, default to the phone number in the session
        self.user_id = user_id if user_id is not None else session_data.get('phone_number')
        self.session = session_data
        self.user_message = user_message

        # Log the user_id for debugging purposes
        logger.debug(f"ChatHandler initialized for user_id: {self.user_id}")

        # Initialize FHIR service using your existing FHIRService class
        self.fhir_service = FHIRService()
        self.fhir_client = self.fhir_service  # Use fhir_service for all FHIR operations

        # Extract patient data from session if available
        self.patient = session_data.get('patient')
        if self.patient and isinstance(self.patient, dict):
            # Prefer numeric_id if available; otherwise, use 'id' or a resource ID from the patient data
            if 'numeric_id' in self.patient:
                self.patient_id = self.patient['numeric_id']
                logger.debug(f"Using numeric patient ID: {self.patient_id}")
            elif 'id' in self.patient:
                self.patient_id = self.patient['id']
                logger.debug(f"Using full patient ID: {self.patient_id}")
            elif 'resource' in self.patient and isinstance(self.patient['resource'], dict):
                self.patient_id = self.patient['resource'].get('id')
                logger.debug(f"Using resource patient ID: {self.patient_id}")
            else:
                self.patient_id = None
                logger.warning("No valid patient ID found in patient data")
        else:
            self.patient_id = None
            logger.debug("No patient data in session")

        # Initialize other attributes
        self.current_context = session_data.get('current_context')
        self.last_intent = session_data.get('last_intent')
        self.conversation_history = session_data.get('conversation_history', [])
        if session_data and 'conversation_context' in session_data:
            self.conversation_context.__dict__.update(session_data['conversation_context'])

        # Register intent handlers.  This is the CRITICAL part.
        self.intent_handlers = {
            'medical_info_query': self._handle_symptom_report,
            'medical_record': self._handle_medical_record,
            'symptoms': self._handle_symptom_report,  # This handles all symptom queries
            'symptom_report': self._handle_symptom_report,  # Added missing symptom_report handler
 
            'set_appointment': self.handle_booking_flow,
            'appointment': self.handle_booking_flow,
            'show_appointments': self._handle_show_appointments,
            'nextAppointment': self._handle_show_appointments,
            'query_appointments': self._handle_show_appointments,
            'immunizations': self._handle_immunizations_query,
            'vaccines': self._handle_immunizations_query,
            'lab_results': self._handle_lab_results,
            'lab_results_query': self._handle_lab_results,
            'capabilities': self._handle_capabilities_query,
            'explanation_query': self._handle_explanation_query,
            'reset_context': self._handle_reset_context,
            'greeting': self._handle_greeting,
            'conditions': self.handle_conditions_query,
            'medications': self.handle_medications_query,
            'screening': self._handle_screening,
            'height': self._handle_height_query
        }

        # Initialize lab context
        self.lab_context = {
            'last_results': None,
            'current_topic': None
        }
        
        # These will be initialized in the initialize() method
        self.openai_client = None
        self.language_handler = None
        self.language_service = None
        self.context_manager = None
        self.current_language = None

    async def initialize(self):
        """Async initialization tasks"""
        logger.debug("[initialize] ChatHandler initialize started")
        try:
            # Initialize OpenAI client
            logger.debug("Initializing AsyncOpenAI client")
            self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
            
            # Initialize language services
            logger.debug("Initializing language services")
            self.language_service = LanguageService()
            # We need to set the openai_client in the language service
            self.language_service.openai_client = self.openai_client
            
            self.language_handler = LanguageHandler()
            # Set the openai_client in the language handler's language_service
            self.language_handler.language_service.openai_client = self.openai_client
            
            # Initialize context manager
            logger.debug("Initializing context manager")
            self.context_manager = ContextManager(
                user_id=self.user_id,
                session=self.session, 
                openai_client=self.openai_client
            )
            
            # Detect language
            logger.debug("Detecting language")
            self.current_language = await self.language_service.detect_language(self.user_message)
            logger.debug(f"Language detected: {self.current_language}")
            
            logger.debug("Initialize completed successfully")
        except Exception as e:
            logger.error(f"Error in async initialization: {str(e)}", exc_info=True)
            raise
            logger.debug("(initialisation finished)")

    async def handle_message(self, message=None, **kwargs):
        """Main message handling method, now with extensive debugging."""
        print("DEBUG-CH-HM-1: Starting handle_message")
        logger.debug("=== ENTER handle_message ===")
        
        if message is None:
            print("DEBUG-CH-HM-2: No message provided, using self.user_message")
            message = self.user_message
        print(f"DEBUG-CH-HM-3: Processing message: {message}")
        logger.debug(f"Processing message: {message}")

        # Check if we need to identify the user by phone number
        if not self.patient_id and not self.session.get('awaiting_phone_number'):
            # Check if the message might contain a phone number
            if self._is_phone_number(message):
                return await self._identify_user_by_phone(message)
            else:
                # Ask for phone number
                self.session['awaiting_phone_number'] = True
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Welcome to ANNA! To help you access your medical information, please provide your phone number."]
                }), self.session
        
        # If we're awaiting a phone number, try to process it
        if self.session.get('awaiting_phone_number') and not self.patient_id:
            # Check if this looks like a phone number
            if self._is_phone_number(message):
                return await self._identify_user_by_phone(message)
            else:
                return JsonResponse({
                    "messages": ["That doesn't look like a valid phone number. Please enter your phone number (e.g., 1234567890)."]
                }), self.session

        try:
            # Language Detection and Translation
            print("DEBUG-CH-HM-4: About to perform language detection")
            logger.debug("Performing language detection")
            print("DEBUG-CH-HM-5: Calling language_service.detect_language")
            detected_lang = await self.language_service.detect_language(self.user_message)
            print(f"DEBUG-CH-HM-6: Language detected: {detected_lang}")
            
            if detected_lang != 'en':
                print(f"DEBUG-CH-HM-7: Skipping translation (disabled)")
                logger.debug(f"Skipping translation from {detected_lang} to English")
                # Skip translation and just use the original text
                english_text = self.user_message
                needs_translation = False
            else:
                print("DEBUG-CH-HM-10: No translation needed (English detected)")
                english_text = self.user_message
                needs_translation = False
            print(f"DEBUG-CH-HM-11: Text for processing: {english_text}")
            logger.debug(f"Text for processing: {english_text}")

            # Context management
            print("DEBUG-CH-HM-12: Starting context management")
            logger.debug("Adding message to context manager")
            try:
                print("DEBUG-CH-HM-13: Calling context_manager.add_message")
                await self.context_manager.add_message(self.user_id, self.user_message)
                print("DEBUG-CH-HM-14: Message added to context manager")
            except Exception as cm_error:
                print(f"DEBUG-CH-HM-ERROR: Error adding message to context manager: {str(cm_error)}")
                import traceback
                print(f"DEBUG-CH-HM-ERROR-TRACE: {traceback.format_exc()}")

            try:
                print("DEBUG-CH-HM-15: Getting context")
                context = await self.context_manager.get_context(self.user_id)
                print("DEBUG-CH-HM-16: Context retrieved")
                
                print("DEBUG-CH-HM-17: Getting user facts")
                user_facts = await self.context_manager.get_user_facts(self.user_id)
                print("DEBUG-CH-HM-18: User facts retrieved")
                
                print("DEBUG-CH-HM-19: Extracting user facts from message")
                new_facts = await self.context_manager._extract_user_facts(self.user_message)
                print(f"DEBUG-CH-HM-20: User facts extracted: {new_facts}")
            
            except Exception as facts_error:
                print(f"DEBUG-CH-HM-ERROR: Error in facts extraction: {str(facts_error)}")
                import traceback
                print(f"DEBUG-CH-HM-ERROR-TRACE: {traceback.format_exc()}")
                # Set defaults if there's an error
                context = {"summary": "", "recent_messages": []}
                user_facts = {}
                new_facts = {}

            if new_facts:
                print("DEBUG-CH-HM-21: Adding new facts to session")
                logger.debug(f"Found new facts: {new_facts}")
                if 'user_facts' not in self.session:
                    self.session['user_facts'] = {}
                # Merge them
                for k, v in new_facts.items():
                    self.session['user_facts'][k] = v
                print("DEBUG-CH-HM-22: Updating session with new facts")
                await update_session(self.user_id, self.session)
                print("DEBUG-CH-HM-23: Session updated")

            # Prepare the context for intent detection
            print("DEBUG-CH-HM-24: Preparing context for intent detection")
            context_info = {
                "summary": context["summary"],
                "recent_messages": context["recent_messages"],
                "user_facts": user_facts
            }
            print(f"DEBUG-CH-HM-25: Context info prepared: {context_info}")

            # --- Intent Detection ---
            print("DEBUG-CH-HM-26: Starting intent detection")
            logger.debug("Detecting intent")
            try:
                print("DEBUG-CH-HM-27: Calling detect_intent")
                intent_data = await detect_intent(
                    user_input=english_text,
                    conversation_context=context_info,
                    last_intent=self.session.get('last_intent')
                )
                print(f"DEBUG-CH-HM-28: Intent detected: {intent_data.get('intent')}")
            except Exception as intent_error:
                print(f"DEBUG-CH-HM-ERROR: Error in intent detection: {str(intent_error)}")
                import traceback
                print(f"DEBUG-CH-HM-ERROR-TRACE: {traceback.format_exc()}")
                # Provide default intent data if there's an error
                intent_data = {"intent": "unknown", "confidence": 0.0, "entities": {}}
            logger.debug(f"Detected intent: {intent_data.get('intent')}, confidence: {intent_data.get('confidence')}")
            logger.debug(f"[handle_message] Detected intent data: {json.dumps(intent_data, indent=2)}")

            # Extract intent information
            intent = intent_data.get("intent")
            confidence = intent_data.get("confidence", 0.0)
            entities = intent_data.get("entities", {})

            responses = []

            # Check for active booking flow or booking-related intent
            if self.session.get('booking_state'):
                logger.debug("Processing active booking flow")
                # Check for cancel command first
                if english_text.lower() == 'cancel':
                    logger.debug("Cancelling booking")
                    self.session.pop('booking_state', None)
                    await update_session(self.user_id, self.session)
                    return ["Booking cancelled. I'm here to help you with any questions you may have."], self.session
                
                # Continue with booking flow if not cancelled
                logger.debug("[handle_message] Handling booking flow")
                response, self.session = await self.handle_booking_flow(self.user_message)
                logger.debug(f"Booking flow returned response type: {type(response).__name__}")
                print(f"DEBUG: Type of response in handle_message after booking flow: {type(response)}")
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                print(f"Final response type: {type(response)}")
                print(f"Is coroutine: {inspect.iscoroutine(response)}")
                
                return response, self.session

            elif intent == "set_appointment":
                logger.debug("Processing set_appointment intent")
                # Check if this is a rescheduling request
                if any(word in english_text.lower() for word in ["reschedule", "change", "move", "modify"]):
                    logger.debug("[handle_message] Detected rescheduling request")
                    response, self.session = await self._handle_reschedule_request()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                        logger.error(f"Attempting to await the coroutine")
                        response = await response  # Try to fix it
                    
                    return response, self.session

                # Start new booking flow if it's a fresh appointment request
                logger.debug("[handle_message] Starting new booking flow")
                response, self.session = await self.handle_booking_flow(self.user_message)
                print(f"DEBUG: Type of response in handle_message after booking flow: {type(response)}")
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                return response, self.session

            # Store the intent data in the instance
            self.intent_data = intent_data

            # Add condition-specific routing
            if any(keyword in self.user_message.lower() for keyword in
                ['my conditions', 'my medical conditions', 'what conditions', 'show me my conditions']):
                logger.debug("Handling conditions query")
                response, self.session = await self._handle_explanation_query(self.user_message)
                
                # Check for unawaited coroutine
                if inspect.iscoroutine(response):
                    logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                    logger.error(f"Attempting to await the coroutine")
                    response = await response  # Try to fix it
                
                return response, self.session

            # Continue with intent handling regardless of triage classification
            if not intent:
                logger.debug("[handle_message] No intent detected")
                general_response = "I'm not sure how to help with that. Could you please rephrase?"
                if needs_translation:
                    general_response = await self.language_handler.translate_text(general_response, self.current_language)
                responses.append(general_response)
            else:
                primary_intent = intent
                logger.debug(f"[handle_message] Primary intent: {primary_intent}")
                logger.debug(f"Available handlers: {self.intent_handlers.keys()}")
                logger.debug(f"Looking for handler: {primary_intent}")
                logger.debug(f"[handle_message] Handler dict: {self.intent_handlers}")
                logger.debug(f"[handle_message] Handler type: {type(self.intent_handlers.get(primary_intent))}")

                # Add capabilities to your intent handling
                if primary_intent == 'capabilities':
                    logger.debug("Handling capabilities intent")
                    response, self.session = await self._handle_capabilities_query()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                        logger.error(f"Attempting to await the coroutine")
                        response = await response  # Try to fix it
                    
                    return response, self.session

                # Special handling for viewing appointments
                if primary_intent == 'appointment' and any(keyword in self.user_message.lower()
                    for keyword in ['show', 'view', 'my', 'upcoming']):
                    logger.debug("[handle_message] Handling show appointments request")
                    appointments_response, self.session = await self._handle_show_appointments()
                    
                    # Check for unawaited coroutine
                    if inspect.iscoroutine(appointments_response):
                        logger.error(f"CRITICAL ERROR: Got unawaited coroutine {appointments_response}")
                        logger.error(f"Attempting to await the coroutine")
                        appointments_response = await appointments_response  # Try to fix it
                    
                    return appointments_response, self.session

                # Special handling for appointment booking initialization
                elif primary_intent == 'appointment' and not self.session.get('booking_state'):
                    logger.debug("[handle_message] Initializing new appointment booking")
                    self.session['booking_state'] = {
                        'step': 'select_practitioner_type',
                        'appointment_info': {}
                    }
                    await self._update_session()
                    
                    messages = [
                        "What type of healthcare provider would you like to see?\n\n"
                        "1. Doctor\n"
                        "2. Nurse\n"
                        "3. Specialist\n\n"
                        "Please select a number or type 'cancel' to stop booking."
                    ]
                    if needs_translation:
                        messages = [await self.language_handler.translate_text(m, self.current_language) for m in messages]
                    responses.extend(messages)
                    
                else:
                    # Intent handlers mapping with async/sync specifications
                    intent_handlers = {
                        # Async handlers
                        'medical_record': self._handle_medical_record,
                        'medical_info_query': self._handle_symptom_report,
                        'medical_info': self._handle_medical_record,
                        'show_records': self._handle_medical_record,
                        'set_appointment': self.handle_booking_flow,
                        'appointment': self.handle_booking_flow,
                        'nextAppointment': self._handle_show_appointments,
                        'query_appointments': self._handle_show_appointments,
                        'show_appointments': self._handle_show_appointments,
                        'immunizations': self._handle_immunizations_query,
                        'vaccines': self._handle_immunizations_query,
                        'lab_results': self._handle_lab_results,
                        # Regular handlers requiring user_id
                        'height': self._handle_height_query,
                        'greeting': self._handle_greeting,
                        'conditions': self.handle_conditions_query,
                        'medications': self.handle_medications_query,
                        'capabilities': self._handle_capabilities_query,
                        'explanation_query': self._handle_explanation_query,
                    }

                    # Get the handler from the instance's intent_handlers
                    logger.debug(f"Looking for handler for intent: {primary_intent}")
                    handler = self.intent_handlers.get(primary_intent)
                    logger.debug(f"Found handler: {handler.__name__ if handler else 'None'}")

                    if handler:
                        try:
                            logger.debug(f"Calling handler with message={message}, intent_data={intent_data}")
                            response = await handler(message=message, intent_data=intent_data)
                            logger.debug(f"Handler returned response of type: {type(response).__name__}")
                            
                            # Check for unawaited coroutine
                            if inspect.iscoroutine(response):
                                logger.error(f"CRITICAL ERROR: Got unawaited coroutine {response}")
                                logger.error(f"Attempting to await the coroutine")
                                response = await response  # Try to fix it
                            
                            print(f"Final response type: {type(response)}")
                            print(f"Is coroutine: {inspect.iscoroutine(response)}")
                            
                            # If returning a tuple, check each part
                            if isinstance(response, tuple):
                                # Create a new tuple with awaited items if needed
                                new_response = []
                                for i, item in enumerate(response):
                                    if inspect.iscoroutine(item):
                                        logger.error(f"Tuple item {i} is a coroutine!")
                                        new_response.append(await item)  # Await the coroutine
                                    else:
                                        new_response.append(item)
                                response = tuple(new_response)  # Create a new tuple
                                
                                logger.debug(f"Response is a tuple with {len(response)} items")
                                return response
                            else:
                                logger.debug("Response is not a tuple, wrapping with session")
                                return response, self.session
                        except Exception as e:
                            logger.error(f"[handle_message] Error in handler execution: {str(e)}")
                            raise
                    else:
                        logger.warning(f"[handle_message] No handler found for intent: {primary_intent}")
                        unknown_intent_response = "I'm not sure how to help with that specific request. Could you try rephrasing?"
                        if needs_translation:
                            unknown_intent_response = await self.language_handler.translate_text(
                                unknown_intent_response,
                                self.current_language
                            )
                        responses.append(unknown_intent_response)

            # Create JsonResponse at the end
            print(f"DEBUG-CH-HM-FINAL-1: Creating final JsonResponse with {len(responses)} messages")
            logger.debug(f"Creating final JsonResponse with {len(responses)} messages")
            
            # Final check for coroutines
            if inspect.iscoroutine(responses):
                print(f"DEBUG-CH-HM-FINAL-ERROR: Got unawaited coroutine {responses}")
                logger.error(f"CRITICAL ERROR: Got unawaited coroutine {responses}")
                logger.error(f"Attempting to await the coroutine")
                print(f"DEBUG-CH-HM-FINAL-2: Attempting to await the coroutine")
                responses = await responses  # Try to fix it
                print(f"DEBUG-CH-HM-FINAL-3: Successfully awaited coroutine")
            
            print(f"DEBUG-CH-HM-FINAL-4: Final response type: {type(responses)}")
            print(f"DEBUG-CH-HM-FINAL-5: Is coroutine: {inspect.iscoroutine(responses)}")
            
            # Create the response object
            final_response = JsonResponse({"messages": responses})
            print(f"DEBUG-CH-HM-FINAL-6: Created JsonResponse object: {type(final_response)}")
            print(f"DEBUG-CH-HM-FINAL-7: Is JsonResponse a coroutine? {inspect.iscoroutine(final_response)}")
            
            # Create the return tuple
            return_value = (final_response, self.session)
            print(f"DEBUG-CH-HM-FINAL-8: Return value created: {type(return_value)}")
            print(f"DEBUG-CH-HM-FINAL-9: Is return value a coroutine? {inspect.iscoroutine(return_value)}")
            
            # Return the tuple with response and session
            return return_value

        except Exception as e:
            print(f"DEBUG-CH-HM-ERROR-FINAL: Error in handle_message: {str(e)}")
            import traceback
            print(f"DEBUG-CH-HM-ERROR-FINAL-TRACE: {traceback.format_exc()}")
            logger.error(f"Error handling message: {str(e)}", exc_info=True)
            
            error_response = JsonResponse({
                "messages": ["I'm sorry, something went wrong while processing your request."]
            })
            print(f"DEBUG-CH-HM-ERROR-FINAL-1: Created error JsonResponse: {type(error_response)}")
            print(f"DEBUG-CH-HM-ERROR-FINAL-2: Is error response a coroutine? {inspect.iscoroutine(error_response)}")
            
            return_tuple = (error_response, self.session)
            print(f"DEBUG-CH-HM-ERROR-FINAL-3: Created error return tuple: {type(return_tuple)}")
            print(f"DEBUG-CH-HM-ERROR-FINAL-4: Is error return tuple a coroutine? {inspect.iscoroutine(return_tuple)}")
            
            return return_tuple

        finally:
            # Store conversation_history and user_facts back to session
            try:
                print("DEBUG-CH-HM-FINALLY-1: Saving conversation history and user facts to session")
                logger.debug("[handle_message] Saving conversation history and user facts to session")
                await self.context_manager.save_session()
                print("DEBUG-CH-HM-FINALLY-2: Session saved successfully")
            except Exception as session_error:
                print(f"DEBUG-CH-HM-FINALLY-ERROR: Failed to save session: {str(session_error)}")
                import traceback
                print(f"DEBUG-CH-HM-FINALLY-ERROR-TRACE: {traceback.format_exc()}")
                logger.error(f"[handle_message] Failed to save session: {str(session_error)}", exc_info=True)
            print("DEBUG-CH-HM-FINALLY-3: Exiting handle_message")
            logger.debug("=== EXIT handle_message ===")

    async def _detect_conversation_topic(self, message):
        """Detect the topic of conversation from message and history"""
        topic_categories = {
            'respiratory': ['asthma', 'bronchitis', 'breathing', 'lung', 'respiratory'],
            'musculoskeletal': ['elbow', 'arm', 'shoulder', 'knee', 'leg', 'back'],
            'allergies': ['hayfever', 'allergic', 'allergy'],
            'symptoms': ['pain', 'hurt', 'ache', 'sore']
        }

        message_words = message.lower().split()
        current_topics = set()

        # Check current message for topics
        for category, keywords in topic_categories.items():
            if any(keyword in message_words for keyword in keywords):
                current_topics.add(category)

        # Check recent history if no topic in current message
        if not current_topics and self.conversation_history:
            recent_messages = [msg['message'].lower() for msg in self.conversation_history[-3:]]
            for msg in recent_messages:
                for category, keywords in topic_categories.items():
                    if any(keyword in msg for keyword in keywords):
                        current_topics.add(category)

        return list(current_topics) if current_topics else None
   

    async def handle_booking_flow(self, message=None, intent_data=None) -> JsonResponse:
        """Handle the booking flow state machine"""
        try:
            # Check if we're in an active booking flow
            booking_state = self.session.get('booking_state', {})

            # If we have an active booking state, handle the current step
            if booking_state and booking_state.get('step'):
                logger.debug(f"Continuing booking flow at step: {booking_state['step']}")
                step_handlers = {
                    'initial_choice': self._handle_initial_choice,
                    'select_role': self._handle_type_selection,
                    'select_practitioner': self._handle_practitioner_selection,
                    'enter_reason': self._handle_reason_entry,
                    'select_datetime': self._handle_datetime_selection,
                    'confirm_booking': self._handle_booking_confirmation
                }

                handler = step_handlers.get(booking_state['step'])
                if handler:
                    response = await handler(booking_state)
                    print(f"DEBUG: Type of response in handle_booking_flow after {booking_state['step']}: {type(response)}")  
                    return response
                else:
                    logger.error(f"Invalid booking step: {booking_state['step']}")
                    return await self._handle_booking_error("Invalid booking state")

            # Initialize new booking flow
            logger.debug("Initializing new booking flow")
            # Get available practitioners using FHIRService
            practitioners = await self.fhir_service.get_available_practitioners()

            if not practitioners:
                return JsonResponse({
                    "messages": ["I apologize, but no healthcare providers are currently available."]
                })

            # Initialize booking state
            self.session['booking_state'] = {
                'step': 'initial_choice',
                'appointment_info': {}
            }
            await update_session(self.user_id, self.session)

            response = JsonResponse({
                "messages": [
                    "How would you like to find a healthcare provider?\n\n"
                    "1. Search by practitioner name\n"
                    "2. Search by role (Doctor, Nurse, Specialist)\n\n"
                    "Or type 'cancel' to stop booking."
                ]
            })
            print(f"DEBUG: Type of response in handle_booking_flow before return: {type(response)}")  
            return response

        except Exception as e:
            logger.error(f"Error in booking flow: {str(e)}", exc_info=True)
            return await self._handle_booking_error("Error processing booking request")

    async def _handle_datetime_selection(self, booking_state):
        """
        Handle the datetime selection for appointment booking.
        This version tries multiple approaches:
        1. Direct parsing with Python's dateparser.
        2. If direct parsing fails, tries a GPT-based approach (optional).
        3. Provides clear error messages to the user.
        """
        user_input = self.user_message.lower().strip()

        # Allow the user to cancel
        if user_input == 'cancel':
            self.session.pop('booking_state', None)
            await self._update_session()
            return JsonResponse({
                "messages": ["Booking cancelled. Is there anything else I can help you with?"]
            }), self.session

        # Attempt to parse using dateparser for maximum flexibility
        parsed_datetime, error_message = await self._parse_datetime_with_timezone(user_input)
        if error_message:
            # If parsing failed, give feedback and re-ask
            return JsonResponse({"messages": [error_message]})

        # If parsed correctly, continue with slot checking
        logger.debug(f"Looking for slot at time: {parsed_datetime.isoformat()}")
        try:
            search_time = parsed_datetime.strftime("%Y-%m-%dT%H:%M:00+00:00")
            logger.debug(f"Searching for slot with time: {search_time}")

            # Search for an available slot in FHIR
            search_params = {
                'schedule': f"Schedule/{booking_state.get('schedule', '25549')}",
                'start': f"eq{search_time}",
                'status': 'free'
            }
            logger.debug(f"Search params: {search_params}")

            slots = await self.fhir_service.search("Slot", search_params)
            if not slots or 'entry' not in slots or not slots['entry']:
                return JsonResponse({
                    "messages": ["That time slot is not available. Please select another time."]
                }), self.session

            # Get the first available slot
            selected_slot = slots['entry'][0]['resource']

            # Store the slot information
            booking_state['appointment_info'].update({
                'datetime': parsed_datetime.isoformat(),
                'slot': {
                    'id': selected_slot['id'],
                    'start': selected_slot['start'],
                    'end': selected_slot['end']
                }
            })

            # Move to confirmation step
            booking_state['step'] = 'confirm_booking'
            self.session['booking_state'] = booking_state
            await self._update_session()
            formatted_time = await self._format_appointment_time(selected_slot['start'])
            return JsonResponse({
                "messages": [
                    f"Please confirm your appointment:\n\n"
                    f"Provider: {booking_state['appointment_info'].get('practitioner_name')}\n"
                    f"Type: {booking_state['appointment_info']['type'].title()}\n"
                    f"Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info'].get('reason', 'General consultation')}\n\n"
                    "Type 'confirm' to book or 'cancel' to start over."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error searching for slots: {str(e)}", exc_info=True)
            return await self._handle_booking_error("Error checking slot availability")

    async def _handle_practitioner_selection(self, booking_state):
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            if not self.user_message.isdigit():
                return JsonResponse({
                    "messages": ["Please select a practitioner by entering their number, or type 'cancel' to stop booking."]
                }), self.session

            selection = int(self.user_message)
            practitioners = self.session['booking_state'].get('practitioners', {})

            if not practitioners:
                logger.error("No practitioners dictionary in booking state")
                return self._handle_booking_error()

            if str(selection) not in practitioners:
                return JsonResponse({
                    "messages": ["Please select a valid practitioner number from the list."]
                }), self.session

            practitioner_id = practitioners[str(selection)]

            # Use the async search method instead of sync read
            search_result = await self.fhir_service.search('Practitioner', {'_id': practitioner_id})
            practitioner = search_result['entry'][0]['resource'] if search_result.get('entry') else None

            if not practitioner:
                logger.error(f"Could not fetch practitioner with ID {practitioner_id}")
                return self._handle_booking_error()

            # Update booking state
            self.session['booking_state']['selected_practitioner'] = practitioner_id
            self.session['booking_state']['appointment_info']['practitioner_name'] = get_resource_name(practitioner)
            self.session['booking_state']['step'] = 'enter_reason'  # Changed from 'confirm_booking' to 'enter_reason'
            await update_session(self.user_id, self.session)

            return JsonResponse({
                "messages": [
                    f"You've selected {self.session['booking_state']['appointment_info']['practitioner_name']}.\n\n"
                    "Please enter the reason for your visit."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in practitioner selection: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_booking_error(self):
        """Handle booking flow errors uniformly"""
        self.session.pop('booking_state', None)
        return JsonResponse({
            "messages": ["I'm sorry, there was an error processing your booking request. Please try again."]
        }), self.session

    async def _handle_booking_confirmation(self, booking_state):
        """Handle final booking confirmation"""
        try:
            if self.user_message.lower() not in ['confirm', 'yes', 'y']:
                return JsonResponse({
                    "messages": ["Please type 'confirm' to book the appointment or 'cancel' to start over."]
                }), self.session

            # Get complete slot info from booking state
            slot_info = booking_state.get('appointment_info', {}).get('slot')
            if not slot_info or not all(key in slot_info for key in ['id', 'start', 'end']):
                logger.error(f"Invalid slot information in booking state: {booking_state}")
                return self._handle_booking_error()

            # Create appointment resource
            appointment_data = {
                'resourceType': 'Appointment',
                'status': 'booked',
                'slot': [{'reference': f"Slot/{slot_info['id']}"}],
                'start': slot_info['start'],
                'end': slot_info['end'],
                'participant': [
                    {
                        'actor': {'reference': f"Patient/{self.patient_id}"},
                        'status': 'accepted'
                    },
                    {
                        'actor': {'reference': f"Practitioner/{booking_state['selected_practitioner']}"},
                        'status': 'accepted'
                    }
                ],
                'appointmentType': {
                    'text': booking_state['appointment_info']['type']
                },
                'reason': [{
                    'text': booking_state['appointment_info'].get('reason', 'General consultation')
                }],
                'created': datetime.now(ZoneInfo("UTC")).isoformat()
            }

            # Create the appointment
            created = await sync_to_async(self.fhir_client.create)('Appointment', appointment_data)
            if not created:
                return self._handle_booking_error()

            # Update slot status
            slot_update = {
                'resourceType': 'Slot',
                'id': slot_info['id'],
                'status': 'busy'
            }
            await sync_to_async(self.fhir_client.update)('Slot', slot_info['id'], slot_update)

            # Clear booking state
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)

            # Format success message
            formatted_time = await self._format_appointment_time(slot_info['start'])
            return JsonResponse({
                "messages": [
                    f"Your appointment has been confirmed!\n\n"
                    f"Provider: {booking_state['appointment_info']['practitioner_name']}\n"
                    f"Type: {booking_state['appointment_info']['type'].title()}\n"
                    f"Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info'].get('reason', 'General consultation')}\n\n"
                    f"You will receive a confirmation email shortly. Is there anything else I can help you with?"
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in booking confirmation: {str(e)}")
            return self._handle_booking_error()
    
    async def _handle_symptom_report(self, message=None, intent_data=None):
        """
        Simplified symptom handler that directly uses SymptomGuidanceService
        to analyze symptoms and provide appropriate guidance.
        """
        try:
            if message is None:
                message = self.user_message
                
            logger.debug(f"Processing symptom query: {message}")
            
            # Initialize the symptom guidance service directly
            symptom_service = SymptomGuidanceService()
            
            # Get patient data from session if available
            patient_data = self.patient.get('resource') if self.patient else None
            
            # 1. Check for red flags first
            has_red_flags, red_flags = await sync_to_async(symptom_service.red_flag_checker)(message)
            
            # 2. Analyze symptoms
            symptom_analysis = await sync_to_async(symptom_service.symptom_analyzer)(
                message, 
                patient_data
            )
            
            # 3. Determine risk level
            risk_assessment = await sync_to_async(symptom_service.risk_level_determiner)(
                symptom_analysis,
                red_flags if has_red_flags else None
            )
            
            # 4. Format response
            response_data = await sync_to_async(symptom_service.response_formatter)(
                risk_assessment,
                patient_data
            )
            
            # 5. Get specific guidance based on symptoms 
            specific_info = await sync_to_async(symptom_service.provide_specific_info)(
                message
            )
            
            # Combine general guidance with specific information
            if 'messages' in specific_info:
                response_data['messages'].extend(specific_info['messages'])
            
            # Log the interaction for audit purposes
            await self._log_symptom_interaction(
                message,
                symptom_analysis,
                risk_assessment,
                response_data
            )
            
            return JsonResponse(response_data), self.session
            
        except Exception as e:
            logger.error(f"Error in symptom handler: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": [
                    "I apologize, but I encountered an error processing your symptoms.",
                    "If you're experiencing a medical emergency, please call emergency services immediately."
                ]
            }), self.session
            
    async def _log_symptom_interaction(self, original_message, analysis, assessment, response):
        """Log the symptom interaction for audit purposes"""
        try:
            interaction_log = {
                'timestamp': datetime.utcnow().isoformat(),
                'patient_id': self.patient_id,
                'original_message': original_message,
                'symptom_analysis': analysis,
                'risk_assessment': assessment,
                'response_given': response,
                'session_id': self.session.get('id')
            }
            
            await sync_to_async(logger.info)(f"Symptom interaction logged: {json.dumps(interaction_log)}")
            
        except Exception as e:
            await sync_to_async(logger.error)(f"Error logging symptom interaction: {str(e)}")

    async def handle_procedures_query(self):
        """Handle request to show patient's procedures"""
        try:
            if not self.patient_id:
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Get procedures from FHIR server
            procedures = await self.fhir_client.search('Procedure',
                params={'patient': self.patient_id, '_sort': '-date'})

            if procedures and procedures.get('entry'):
                formatted_procedures = ['Your past procedures are:']
                for entry in procedures['entry']:
                    procedure = entry['resource']
                    name = procedure.get('code', {}).get('text', 'Unknown procedure')
                    date = procedure.get('performedDateTime', '').split('T')[0]
                    formatted_procedures.append(f"- {name} (Date: {date})")
                return JsonResponse({"messages": formatted_procedures}), self.session
            return JsonResponse({
                "messages": ["I couldn't find any procedures in your medical record."]
            }), self.session

        except Exception as e:
            logger.error(f"Error fetching procedures: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your procedure records right now."]
            }), self.session

    async def _create_appointment(self, slot, booking_state, parsed_datetime):
        """Create the actual appointment with all necessary details"""
        try:
            logger.info(f"Creating appointment for slot: {slot}")

            # Get the slot resource correctly
            slot_resource = slot.get('resource', slot)

            # Create the appointment resource
            appointment = {
                'resourceType': 'Appointment',
                'status': 'booked',
                'appointmentType': {
                    'coding': [{
                        'system': 'http://terminology.hl7.org/CodeSystem/v2-0276',
                        'code': booking_state['appointment_info']['type'],
                        'display': booking_state['appointment_info']['type']
                    }]
                },
                'description': booking_state['appointment_info']['reason'],
                'start': slot_resource['start'],
                'end': slot_resource['end'],
                'minutesDuration': 30,
                'slot': [
                    {'reference': f"Slot/{slot_resource['id']}"}
                ],
                'participant': [
                    {
                        'actor': {
                            'reference': f"Patient/{self.patient_id}",
                            'type': 'Patient'
                        },
                        'status': 'accepted'
                    },
                    {
                        'actor': {
                            'reference': f"Practitioner/{booking_state['selected_practitioner']}",
                            'type': 'Practitioner'
                        },
                        'status': 'accepted'
                    }
                ],
                'created': datetime.now(ZoneInfo("UTC")).isoformat()
            }

            # Create the appointment
            logger.info("Attempting to create appointment in FHIR")
            created_appointment = await self.fhir_client.create('Appointment', appointment)

            if not created_appointment:
                raise Exception("Failed to create appointment in FHIR")

            # Update the slot status to booked
            logger.info("Updating slot status to booked")
            slot_resource['status'] = 'busy'
            await self.fhir_client.update('Slot', slot_resource['id'], slot_resource)

            # Clear booking state
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)

            # Format the confirmation message
            clinic_tz = self._get_clinic_timezone()
            formatted_time = await self._format_appointment_time(parsed_datetime.isoformat())

            return JsonResponse({
                "messages": [
                    f"Great! I've booked your {booking_state['appointment_info']['type']} appointment:\n\n"
                    f"Provider: Dr. {booking_state['appointment_info']['practitioner_name']}\n"
                    f"Date/Time: {formatted_time}\n"
                    f"Reason: {booking_state['appointment_info']['reason']}\n\n"
                    "You'll receive a confirmation email shortly. Is there anything else I can help you with?"
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error creating appointment: {str(e)}", exc_info=True)
            self.session.pop('booking_state', None)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm sorry, there was an error creating your appointment. Please try again."]
            }), self.session

    def send_message(self, to_number, message):
        """Send SMS message using Twilio"""
        try:
            client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
            message = client.messages.create(
                body=message,
                from_=settings.TWILIO_PHONE_NUMBER,
                to=to_number
            )
            logger.info(f"SMS sent successfully to {to_number}: {message.sid}")
            return True
        except Exception as e:
            logger.error(f"Error sending SMS to {to_number}: {str(e)}")
            return False
            
    def _is_phone_number(self, text):
        """Check if text looks like a phone number"""
        # Remove common phone number formatting
        digits_only = ''.join(c for c in text if c.isdigit())
        
        # Check if we have a reasonable number of digits for a phone number
        # Most phone numbers are 10-15 digits
        return 7 <= len(digits_only) <= 15
        
    async def _identify_user_by_phone(self, phone_input):
        """Identify a user by their phone number and fetch their data"""
        try:
            # Clean the phone number - remove non-digits
            phone_number = ''.join(c for c in phone_input if c.isdigit())
            
            # Format with country code if needed
            if len(phone_number) == 10 and not phone_number.startswith('1'):
                # Add US country code for 10-digit numbers
                phone_number = '1' + phone_number
                
            logger.info(f"Attempting to identify user by phone number: {phone_number}")
            
            # Try to find a patient directly using FHIR search
            try:
                # Try multiple search patterns for phone numbers
                search_attempts = [
                    {'telecom': f"phone|{phone_number}"},
                    {'telecom': phone_number}
                ]
                
                # Try each search pattern
                for params in search_attempts:
                    logger.info(f"Trying search with params: {params}")
                    result = await self.fhir_service.search('Patient', params)
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                        logger.info(f"Found patient using params: {params}")
                        break
                else:
                    # Get the first patient for demo/testing purposes
                    logger.info("No patient found with phone, using first patient for demo")
                    result = await self.fhir_service.search('Patient', {'_count': '1'})
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                    else:
                        patient = None
            except Exception as e:
                logger.error(f"Error searching for patient: {str(e)}")
                patient = None
            
            if not patient:
                # No patient found with this phone number
                self.session['awaiting_phone_number'] = False  # Reset the flag
                await update_session(self.user_id, self.session)
                
                return JsonResponse({
                    "messages": [
                        "I couldn't find a patient record with that phone number.",
                        "Please check the number and try again, or contact support for assistance."
                    ]
                }), self.session
            
            # Store in session
            self.session['patient'] = {
                'resource': patient,
                'id': patient.get('id'),
                'phone_number': phone_number
            }
            self.patient = self.session['patient']
            self.patient_id = patient.get('id')
            
            # Clear the awaiting flag and save the session
            self.session['awaiting_phone_number'] = False
            # Only update once with a longer timeout to ensure it's saved
            await update_session(self.user_id, self.session)
            
            # Get patient name for greeting
            name = patient.get('name', [{}])[0]
            given_name = name.get('given', [''])[0] if name else ''
            
            return JsonResponse({
                "messages": [
                    f"Thank you! I've found your records, {given_name}.",
                    "How can I assist you with your healthcare today?"
                ]
            }), self.session
            
        except Exception as e:
            logger.error(f"Error identifying user by phone: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble processing your request. Please try again later."]
            }), self.session

    async def _handle_show_appointments(self, message=None, intent_data=None, user_id=None):
        """Handle showing appointments for a user.

        Args:
            message: The user's message
            intent_data: Intent data from NLP
            user_id: The user's ID (optional, falls back to self.user_id)
        """
        try:
            if not self.patient or not self.patient.get('email'):
                return JsonResponse({
                    "messages": ["Please verify your email first to view your appointments."]
                }), self.session

            patient_email = self.patient['email']
            patient_id = self.patient['id']
            logger.info(f"Fetching appointments for patient email: {patient_email}")

            # Get current time in UTC
            current_time = datetime.now(ZoneInfo("UTC")).isoformat()

            # Search for appointments using patient ID directly
            appointment_params = {
                "patient": f"Patient/{patient_id}",
                "date": f"ge{current_time}",
                "_sort": "date"
            }

            logger.debug(f"Searching appointments with params: {appointment_params}")
            appointments = await self.fhir_service.search("Appointment", appointment_params)

            if not appointments or 'entry' not in appointments or not appointments['entry']:
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments scheduled."]
                }), self.session

            # Format appointments
            messages = ["Here are your upcoming appointments:"]

            for entry in appointments['entry']:
                appointment = entry['resource']

                # Skip non-booked appointments
                if appointment.get('status') not in ['booked', 'pending']:
                    continue

                # Format the appointment time
                start_time = datetime.fromisoformat(appointment['start'].replace('Z', '+00:00'))
                formatted_time = await self._format_appointment_time(appointment['start'])

                # Get practitioner info from participants
                practitioner_name = "Unknown Provider"
                for participant in appointment.get('participant', []):
                    actor = participant.get('actor', {})
                    if actor.get('type') == 'Practitioner' or 'Practitioner/' in actor.get('reference', ''):
                        practitioner_ref = actor['reference'].split('/')[-1]
                        practitioner = await sync_to_async(self.fhir_service.read)('Practitioner', practitioner_ref)
                        if practitioner:
                            practitioner_name = get_resource_name(practitioner)
                        break

                # Build appointment info string
                appt_info = f"- {formatted_time} with {practitioner_name}"

                # Add reason if available
                if appointment.get('description'):
                    appt_info += f" ({appointment['description']})"
                elif appointment.get('reason'):
                    appt_info += f" ({appointment['reason'][0].get('text', 'No reason provided')})"

                messages.append(appt_info)

            if len(messages) == 1:  # Only header message
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments scheduled."]
                }), self.session

            return JsonResponse({
                "messages": messages
            }), self.session

        except Exception as e:
            logger.error(f"Error showing appointments: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm sorry, I couldn't retrieve your appointments at this time. Please try again later."]
            }), self.session

    async def _handle_height_query(self):
        """Handle request to show patient's height"""
        try:
            logger.debug("Handling height query")
            if not self.patient or not self.patient.get('resource'):
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Get height from patient resource extensions
            patient_resource = self.patient['resource']
            height_extension = next(
                (ext for ext in patient_resource.get('extension', [])
                 if ext['url'] == "http://example.org/fhir/StructureDefinition/height"),
                None
            )

            if height_extension and 'valueQuantity' in height_extension:
                height_value = height_extension['valueQuantity']['value']
                height_unit = height_extension['valueQuantity']['unit']
                logger.debug(f"Found height: {height_value} {height_unit}")
                return JsonResponse({"messages": [f"Your height is {height_value} {height_unit}."]}), self.session

            return JsonResponse({"messages": ["I couldn't find your height information in your records."]}), self.session

        except Exception as e:
            logger.error(f"Error fetching height: {str(e)}", exc_info=True)
            return JsonResponse({"messages": ["I'm sorry, I couldn't retrieve your height information at this time."]}), self.session

    async def _handle_greeting(self, message=None, intent_data=None):
        try:
            if self.patient and self.patient.get('resource'):
                name = self.patient['resource'].get('name', [{}])[0]
                if name and name.get('given') and name.get('family'):
                    greeting = f"Hello {name.get('given', [''])[0]} {name.get('family')}! How can I help you today?"
                    return JsonResponse({"messages": [greeting]}), self.session

            return JsonResponse({"messages": ["Hello! How can I help you today?"]}), self.session
        except Exception as e:
            logger.error(f"Error in greeting: {str(e)}")
            return JsonResponse({"messages": ["Hello! How can I help you today?"]}), self.session

    async def handle_medications_query(self):
        """Handle request to show patient's medications"""
        try:
            if not self.patient_id:
                return JsonResponse({"messages": ["I couldn't find your patient records."]}), self.session

            # Wrap synchronous search methods with sync_to_async
            medication_statements = await sync_to_async(self.fhir_client.search)('MedicationStatement',
                params={'patient': f"Patient/{self.patient_id}", 'status': 'active'})

            medication_requests = await sync_to_async(self.fhir_client.search)('MedicationRequest',
                params={'patient': f"Patient/{self.patient_id}", 'status': 'active'})

            medications = []

            # Process MedicationStatements
            if medication_statements and medication_statements.get('entry'):
                for entry in medication_statements['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display', 'Unknown medication')
                    dosage = med.get('dosage', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")

            # Process MedicationRequests
            if medication_requests and medication_requests.get('entry'):
                for entry in medication_requests['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text', 'Unknown medication')
                    dosage = med.get('dosageInstruction', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")

            if medications:
                formatted_meds = ['Your current medications are:']
                formatted_meds.extend(medications)
                await update_session(self.user_id, self.session)
                return JsonResponse({"messages": formatted_meds}), self.session

            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I couldn't find any active medications in your records."]
            }), self.session

        except Exception as e:
            logger.error(f"Error fetching medications: {str(e)}", exc_info=True)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your medication records right now."]
            }), self.session

    async def _handle_medical_record(self):
        logger.debug("=== Medical Record Query Debug ===")
        logger.debug(f"Patient data: {self.patient}")
        logger.debug(f"Patient ID: {self.patient_id}")

        """Handle request to show complete medical record"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't access your medical records. Please ensure you're logged in."]
                }), self.session

            # Initialize the record list
            record = []
            patient_resource = self.patient['resource']

            # Basic Information
            record.append("PERSONAL INFORMATION:")
            name = patient_resource.get('name', [{}])[0]
            full_name = f"{name.get('given', [''])[0]} {name.get('family', '')}"
            record.append(f"Name: {full_name}")
            record.append(f"Gender: {patient_resource.get('gender', 'Not specified')}")
            record.append(f"Birth Date: {patient_resource.get('birthDate', 'Not specified')}")

            # Vital Signs
            record.append("\nVITAL SIGNS:")
            for extension in patient_resource.get('extension', []):
                if extension['url'].endswith('height'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Height: {value.get('value')} {value.get('unit')}")
                elif extension['url'].endswith('weight'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Weight: {value.get('value')} {value.get('unit')}")

            # Contact Information
            record.append("\nCONTACT INFORMATION:")
            for telecom in patient_resource.get('telecom', []):
                system = telecom.get('system', '').title()
                value = telecom.get('value', '')
                record.append(f"{system}: {value}")

            # Emergency Contacts
            record.append("\nEMERGENCY CONTACTS:")
            contacts = await sync_to_async(self.fhir_client.search)("RelatedPerson", {
                "patient": f"Patient/{self.patient_id}"
            })
            if contacts and contacts.get('entry'):
                for entry in contacts['entry']:
                    contact = entry['resource']
                    relationship = contact.get('relationship', [{}])[0].get('text', 'Contact')
                    name = contact.get('name', [{}])[0]
                    contact_name = f"{name.get('given', [''])[0]} {name.get('family', '')}"
                    record.append(f"- {relationship}: {contact_name}")
                    for telecom in contact.get('telecom', []):
                        record.append(f"  {telecom.get('system', '').title()}: {telecom.get('value', '')}")
            else:
                record.append("No emergency contacts listed")

            # Allergies
            record.append("\nALLERGIES:")
            allergies = await sync_to_async(self.fhir_client.search)("AllergyIntolerance", {
                "patient": f"Patient/{self.patient_id}"
            })
            if allergies and allergies.get('entry'):
                for entry in allergies['entry']:
                    allergy = entry['resource']
                    substance = (allergy.get('code', {}).get('text') or
                               allergy.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown'))
                    severity = allergy.get('reaction', [{}])[0].get('severity', 'unknown')
                    record.append(f"- {substance} (Severity: {severity})")
            else:
                record.append("No known allergies")

            # Social History
            record.append("\nSOCIAL HISTORY:")
            social_history = await sync_to_async(self.fhir_client.search)("Observation", {
                "patient": f"Patient/{self.patient_id}",
                "category": "social-history"
            })
            if social_history and social_history.get('entry'):
                for entry in social_history['entry']:
                    observation = entry['resource']
                    record.append(f"- {observation.get('code', {}).get('text')}: {observation.get('valueString', '')}")
            else:
                record.append("No social history recorded")

            # Healthcare Providers
            record.append("\nHEALTHCARE PROVIDERS:")
            providers = await sync_to_async(self.fhir_client.search)("PractitionerRole", {
                "patient": f"Patient/{self.patient_id}"
            })
            if providers and providers.get('entry'):
                for entry in providers['entry']:
                    provider = entry['resource']
                    role = provider.get('specialty', [{}])[0].get('text', 'Healthcare Provider')
                    practitioner = provider.get('practitioner', {}).get('display', 'Unknown')
                    record.append(f"- {role}: Dr. {practitioner}")
            else:
                record.append("No healthcare providers listed")

            # ----------- Fetching Medical Conditions -----------
            try:
                # First attempt: Fetch active, relapse, and recurrence conditions sorted by recorded-date
                conditions = await sync_to_async(self.fhir_client.search)("Condition", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-recorded-date",  # Corrected sort parameter
                    "clinical-status": "active,relapse,recurrence"  # Ensure these are valid statuses
                })

                logger.debug(f"Conditions response: {json.dumps(conditions)}")  # Debug logging

                # If no conditions found, try fetching all conditions sorted by recorded-date
                if not conditions or not conditions.get('entry'):
                    conditions = await sync_to_async(self.fhir_client.search)("Condition", {
                        "patient": f"Patient/{self.patient_id}",
                        "_sort": "-recorded-date"  # Corrected sort parameter
                    })
                    logger.debug(f"Conditions response after second attempt: {json.dumps(conditions)}")  # Debug logging

                if conditions and conditions.get('entry'):
                    record.append("\nMEDICAL CONDITIONS:")
                    for entry in conditions['entry']:
                        condition = entry['resource']

                        # Extract condition name
                        name = (condition.get('code', {}).get('text') or
                                condition.get('code', {}).get('coding', [{}])[0].get('display') or
                                'Unknown condition')

                        # Extract clinical status
                        clinical_status_obj = condition.get('clinicalStatus', {})
                        clinical_status = (clinical_status_obj.get('text') or
                                           clinical_status_obj.get('coding', [{}])[0].get('display') or
                                           clinical_status_obj.get('coding', [{}])[0].get('code', 'unknown'))

                        # Extract verification status
                        verification_obj = condition.get('verificationStatus', {})
                        verification_status = (verification_obj.get('text') or
                                               verification_obj.get('coding', [{}])[0].get('display') or
                                               verification_obj.get('coding', [{}])[0].get('code', ''))

                        # Extract onset date
                        onset_date = None
                        if condition.get('onsetDateTime'):
                            onset_date = condition['onsetDateTime'].split('T')[0]
                        elif condition.get('onsetPeriod', {}).get('start'):
                            onset_date = condition['onsetPeriod']['start'].split('T')[0]
                        elif condition.get('onsetString'):
                            onset_date = condition['onsetString']

                        # Build condition line
                        condition_line = f"- {name}"
                        if clinical_status and clinical_status.lower() != 'active':
                            condition_line += f" (Status: {clinical_status})"
                        if onset_date:
                            condition_line += f" (Onset: {onset_date})"
                        if verification_status and verification_status.lower() != 'confirmed':
                            condition_line += f" ({verification_status})"

                        record.append(condition_line)

                        # Add condition notes if available
                        if condition.get('note'):
                            for note in condition['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nMEDICAL CONDITIONS:")
                    record.append("No current medical conditions found")
            except Exception as e:
                logger.error(f"Error fetching conditions: {str(e)}", exc_info=True)
                record.append("\nMEDICAL CONDITIONS:")
                record.append("Error retrieving conditions")

            # ----------- Fetching Medications -----------
            try:
                medications = await sync_to_async(self.fhir_client.search)("MedicationRequest", {
                    "patient": f"Patient/{self.patient_id}",
                    "status": "active"
                })

                if medications and medications.get('entry'):
                    record.append("\nCURRENT MEDICATIONS:")
                    for entry in medications['entry']:
                        med = entry['resource']
                        name = (med.get('medicationCodeableConcept', {}).get('text') or
                                med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or
                                'Unknown medication')

                        dosage = med.get('dosageInstruction', [{}])[0]
                        dosage_text = (dosage.get('text') or
                                       f"{dosage.get('timing', {}).get('repeat', {}).get('frequency', 'as needed')} times per day")

                        record.append(f"- {name} ({dosage_text})")

                        # Add medication notes if available
                        if med.get('note'):
                            for note in med['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nCURRENT MEDICATIONS:")
                    record.append("No active medications found")

            except Exception as e:
                logger.error(f"Error fetching medications: {str(e)}")
                record.append("\nCURRENT MEDICATIONS:")
                record.append("Error retrieving medications")

            # ----------- Fetching Procedures -----------
            try:
                procedures = await sync_to_async(self.fhir_client.search)("Procedure", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-recorded-date"  # Corrected sort parameter
                })

                if procedures and procedures.get('entry'):
                    record.append("\nPAST PROCEDURES:")
                    for entry in procedures['entry']:
                        procedure = entry['resource']
                        name = (procedure.get('code', {}).get('text') or
                                procedure.get('code', {}).get('coding', [{}])[0].get('display') or
                                'Unknown procedure')

                        date = procedure.get('performedDateTime', '').split('T')[0]
                        status = procedure.get('status', 'unknown')

                        procedure_line = f"- {name}"
                        if date:
                            procedure_line += f" (Date: {date})"
                        if status != 'completed':
                            procedure_line += f" (Status: {status})"

                        record.append(procedure_line)

                        # Add procedure notes if available
                        if procedure.get('note'):
                            for note in procedure['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nPAST PROCEDURES:")
                    record.append("No procedures found")

            except Exception as e:
                logger.error(f"Error fetching procedures: {str(e)}")
                record.append("\nPAST PROCEDURES:")
                record.append("Error retrieving procedures")

            # ----------- Fetching Immunizations -----------
            try:
                immunizations = await sync_to_async(self.fhir_client.search)("Immunization", {
                    "patient": f"Patient/{self.patient_id}"
                })

                if immunizations and immunizations.get('entry'):
                    record.append("\nIMMUNIZATIONS:")
                    for entry in immunizations['entry']:
                        immunization = entry['resource']
                        vaccine = (immunization.get('vaccineCode', {}).get('text') or
                                   immunization.get('vaccineCode', {}).get('coding', [{}])[0].get('display') or
                                   'Unknown vaccine')

                        date = immunization.get('occurrenceDateTime', '').split('T')[0]
                        status = immunization.get('status', 'unknown')

                        record.append(f"- {vaccine} (Date: {date}, Status: {status})")

                        # Add immunization notes if available
                        if immunization.get('note'):
                            for note in immunization['note']:
                                if note.get('text'):
                                    record.append(f"  Note: {note['text']}")
                else:
                    record.append("\nIMMUNIZATIONS:")
                    record.append("No immunization records found")

            except Exception as e:
                logger.error(f"Error fetching immunizations: {str(e)}")
                record.append("\nIMMUNIZATIONS:")
                record.append("Error retrieving immunizations")

            # Compile and return the complete medical record
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["Here is your complete medical record:\n\n" + "\n".join(record)]
            }), self.session

        except Exception as e:
            logger.error(f"Error handling medical record query: {str(e)}", exc_info=True)
            await update_session(self.user_id, self.session)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your medical records right now."]
            }), self.session

    async def _handle_initial_choice(self):
        """Handle initial choice for finding healthcare provider"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            if not self.user_message.isdigit() or self.user_message not in ['1', '2']:
                return JsonResponse({
                    "messages": [
                        "Please select a valid option:\n\n"
                        "1. Search by practitioner name\n"
                        "2. Search by role (Doctor, Nurse, Specialist)\n\n"
                        "Or type 'cancel' to stop booking."
                    ]
                }), self.session

            if self.user_message == '1':
                # Search by name
                practitioners = await self.fhir_service.get_available_practitioners()
                if not practitioners:
                    return JsonResponse({
                        "messages": ["I apologize, but no healthcare providers are currently available."]
                    }), self.session

                messages = ["Please select a practitioner by number:"]
                practitioner_map = {}
                for i, pract in enumerate(practitioners, 1):
                    name = pract['name']
                    specialty = pract.get('specialty', 'General Practice')
                    messages.append(f"{i}. {name} - {specialty}")
                    practitioner_map[str(i)] = pract['id']

                messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

                # Update booking state
                self.session['booking_state']['practitioners'] = practitioner_map
                self.session['booking_state']['step'] = 'select_practitioner'
                await update_session(self.user_id, self.session)

                return JsonResponse({"messages": messages}), self.session

            else:  # self.user_message == '2'
                # Get available practitioners
                practitioners = await self.fhir_service.get_available_practitioners()
                if not practitioners:
                    return JsonResponse({
                        "messages": ["I apologize, but no healthcare providers are currently available."]
                    }), self.session

                # Get unique roles
                roles = sorted(set(p.get('role', 'General Practitioner') for p in practitioners))
                messages = ["Please select a healthcare provider role:"]
                role_map = {}
                for i, role in enumerate(roles, 1):
                    messages.append(f"{i}. {role}")
                    role_map[str(i)] = role

                messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

                # Update booking state
                self.session['booking_state']['roles'] = role_map
                self.session['booking_state']['step'] = 'select_role'
                await update_session(self.user_id, self.session)

                return JsonResponse({"messages": messages}), self.session

        except Exception as e:
            logger.error(f"Error handling initial choice: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_name_search(self, booking_state):
        """Handle practitioner name search"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            # Search for practitioner by name
            practitioners = await self.fhir_service.get_available_practitioners(name=self.user_message)

            if not practitioners:
                return JsonResponse({
                    "messages": [
                        "No practitioners found with that name. Please try again with a different name.\n"
                        "Or type 'cancel' to stop booking."
                    ]
                }), self.session

            # Store practitioners and move to reason entry
            booking_state['practitioners'] = {str(i): p['id'] for i, p in enumerate(practitioners, 1)}
            booking_state['step'] = 'enter_reason'
            booking_state['selected_practitioner'] = practitioners[0]['id']  # Since we're searching by name
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            practitioner_name = await get_resource_name(practitioners[0])
            return JsonResponse({
                "messages": [
                    f"Found Dr. {practitioner_name}.\n\n"
                    "Please provide a brief reason for your visit.\n"
                    "Or type 'cancel' to stop booking."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in name search: {str(e)}", exc_info=True)
            return self._handle_booking_error()


    async def _handle_immunizations_query(self):
        """Handle immunization/vaccine queries"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't find your patient records."]
                }), self.session

            medical_record = await get_complete_medical_record(self.patient_id)

            # Extract immunizations section from medical record
            if isinstance(medical_record, str):
                immunizations_section = ""
                capture_immunizations = False
                immunizations = []

                for line in medical_record.split('\n'):
                    if 'Immunizations:' in line:
                        capture_immunizations = True
                        continue
                    elif capture_immunizations and line.strip() and not line.startswith('7.'):
                        immunizations.append(line.strip())
                    elif capture_immunizations and line.startswith('7.'):
                        break

                if immunizations:
                    response = ["Your immunization record includes:"]
                    response.extend([f"- {imm}" for imm in immunizations if imm.strip()])
                    return JsonResponse({"messages": response})
            return JsonResponse({
                "messages": ["I couldn't find any immunization records in your file."]
            }), self.session

        except Exception as e:
            logger.error(f"Error handling immunizations query: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your immunization records right now."]
            }), self.session

    async def detect_language(self, text):
        try:
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a language detector. Respond only with the ISO language code."},
                    {"role": "user", "content": f"What language is this: {text}"}
                ]
            )
            detected = response.choices[0].message.content.strip().lower()
            # Ensure we return a string, not any other type
            return str(detected) if detected else 'en'
        except Exception as e:
            logger.error(f"Error detecting language: {str(e)}")
            return 'en'  # Default to English on error


    async def handle_conditions_query(self):
        """Handle request to view patient conditions"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["I couldn't find your patient records."]
                }), self.session

            # Use sync_to_async to wrap the synchronous search method
            search_params = {
                "patient": f"Patient/{self.patient_id}",
                "_sort": "-recorded-date"
            }

            conditions_bundle = await sync_to_async(self.fhir_client.search)("Condition", search_params)

            if not conditions_bundle or 'entry' not in conditions_bundle:
                return JsonResponse({
                    "messages": ["I don't see any recorded conditions in your medical record."]
                }), self.session

            # Format conditions into readable text
            conditions_list = ["Your current conditions are:"]
            for entry in conditions_bundle['entry']:
                condition = entry['resource']
                name = condition.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown condition')
                status = condition.get('clinicalStatus', {}).get('coding', [{}])[0].get('code', 'unknown')

                condition_text = f"- {name} (Status: {status})"
                conditions_list.append(condition_text)
            return JsonResponse({
                "messages": conditions_list
            }), self.session

        except Exception as e:
            logger.error(f"Error retrieving conditions: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble accessing your conditions right now. Please try again later."]
            }), self.session



    async def _handle_type_selection(self, booking_state):
        """Handle selection of practitioner role"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            roles = booking_state.get('roles', {})
            if not roles:
                logger.error("No roles dictionary in booking state")
                return self._handle_booking_error()

            if not self.user_message.isdigit() or self.user_message not in roles:
                messages = ["Please select a valid role number:"]
                for i, role in roles.items():
                    messages.append(f"{i}. {role}")
                messages.append("\nOr type 'cancel' to stop booking.")
                return JsonResponse({"messages": messages}), self.session

            selected_role = roles[self.user_message]

            # Get practitioners with the selected role
            all_practitioners = await self.fhir_service.get_available_practitioners()
            role_practitioners = [p for p in all_practitioners if p.get('role') == selected_role]

            if not role_practitioners:
                return JsonResponse({
                    "messages": [f"I apologize, but no {selected_role}s are currently available."]
                }), self.session

            # Create numbered list of practitioners
            messages = [f"Please select a {selected_role} by number:"]
            practitioner_map = {}
            for i, pract in enumerate(role_practitioners, 1):
                name = pract['name']
                specialty = pract.get('specialty', 'General Practice')
                messages.append(f"{i}. {name} - {specialty}")
                practitioner_map[str(i)] = pract['id']

            messages.append("\nEnter the number of your choice, or type 'cancel' to stop booking.")

            # Update booking state
            booking_state['practitioners'] = practitioner_map
            booking_state['step'] = 'select_practitioner'
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            return JsonResponse({"messages": messages}), self.session

        except Exception as e:
            logger.error(f"Error handling role selection: {str(e)}", exc_info=True)
            return self._handle_booking_error()

    async def _handle_reason_entry(self, booking_state):
        """Handle the entry of appointment reason"""
        try:
            if self.user_message.lower() == 'cancel':
                self.session.pop('booking_state', None)
                await update_session(self.user_id, self.session)
                return JsonResponse({
                    "messages": ["Booking cancelled. Is there anything else I can help you with?"]
                }), self.session

            # Store the reason and update step
            booking_state['appointment_info']['reason'] = self.user_message
            booking_state['step'] = 'select_datetime'
            self.session['booking_state'] = booking_state
            await update_session(self.user_id, self.session)

            return JsonResponse({
                "messages": [
                    "Please enter your preferred date and time for the appointment.\n\n"
                    "For example:\n"
                    "- Tomorrow at 2pm\n"
                    "- Next Tuesday at 10:30am\n"
                    "- December 1st at 3pm\n\n"
                    "Our hours are 9 AM to 5 PM, Monday through Friday."
                ]
            }), self.session

        except Exception as e:
            logger.error(f"Error in reason entry: {str(e)}")
            return self._handle_booking_error()

    async def _parse_datetime_with_timezone(self, datetime_string):
        """
        Parse a natural language datetime string with multiple fallback strategies:
        1. Attempt direct parsing with 'dateparser'.
        2. Validate business hours and days.
        3. If fails, return a helpful error message.

        Returns:
            (datetime or None, error_message or None)
        """
        try:
            # 1. Use dateparser for natural language date-time handling.
            #    Set a base reference time if needed, e.g., now in UTC.
            now = datetime.now(ZoneInfo("UTC"))
            parsed = dateparser.parse(
                datetime_string,
                settings={
                    'RETURN_AS_TIMEZONE_AWARE': True,
                    'TIMEZONE': 'UTC',
                    'RELATIVE_BASE': now,
                    'PREFER_DATES_FROM': 'future'
                }
            )

            if not parsed:
                # Could not parse at all
                return None, "I couldn't understand that date/time. Please try a more standard format like 'December 9th at 1pm' or 'next Monday at 2 PM'."

            # If the parsed date is today or in the past, assume user meant next occurrence
            if parsed.date() <= now.date():
                # Get the target weekday (0 = Monday, 6 = Sunday)
                target_weekday = parsed.weekday()
                current_weekday = now.weekday()

                # Calculate days until next occurrence
                days_ahead = target_weekday - current_weekday
                if days_ahead <= 0:  # Target day already passed this week
                    days_ahead += 7

                # Adjust the date to next occurrence
                parsed = parsed.replace(year=now.year, month=now.month, day=now.day) + timedelta(days=days_ahead)

            # 2. Validate business rules: Monday-Friday, 9-17 hours
            if parsed.weekday() >= 5:
                # Weekend
                return None, "We are only open Monday through Friday. Please choose a weekday."

            # Business hours check
            if not (9 <= parsed.hour < 17):
                return None, "Our hours are 9 AM to 5 PM. Please select a time within these hours."

            # Round to the nearest 30-minute increment
            minutes = parsed.minute
            rounded_minutes = 0 if minutes < 30 else 30
            parsed = parsed.replace(minute=rounded_minutes, second=0, microsecond=0)

            return parsed, None

        except Exception as e:
            logger.error(f"Error parsing datetime: {str(e)}", exc_info=True)
            return None, "There was an error processing your date/time selection. Please try again."
    async def _format_appointment_time(self, datetime_str):
        """
        Format datetime string into user-friendly format.
        Args:
            datetime_str: ISO format datetime string
        Returns:
            Formatted string like "Tuesday, November 21st at 2:00 PM"
        """
        try:
            # Parse the ISO datetime string
            if isinstance(datetime_str, str):
                if datetime_str.endswith('Z'):
                    datetime_str = datetime_str[:-1] + '+00:00'
                dt = datetime.fromisoformat(datetime_str)
            else:
                dt = datetime_str

            # Ensure timezone is UTC if none specified
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=ZoneInfo("UTC"))

            # Convert to local timezone
            local_dt = dt.astimezone(ZoneInfo(settings.TIME_ZONE))

            # Format date components
            day_name = local_dt.strftime("%A")
            month = local_dt.strftime("%B")
            day = local_dt.day

            # Add ordinal suffix
            suffix = "th" if 11 <= day <= 13 else {1: "st", 2: "nd", 3: "rd"}.get(day % 10, "th")

            # Format time
            time_str = local_dt.strftime("%I:%M %p").lstrip("0")

            return f"{day_name}, {month} {day}{suffix} at {time_str}"

        except Exception as e:
            logger.error(f"Error formatting appointment time: {str(e)}", exc_info=True)
            return str(datetime_str)


    async def _handle_appointment_booking(self, message, intent_data=None, user_id=None):
        """Handle appointment booking requests"""
        try:
            logger.debug("Handling appointment booking request")

            # Get available practitioners
            practitioners = await get_available_practitioners(self.fhir_client)

            # Get available slots
            available_slots = await search_available_slots(self.fhir_client)

            if not practitioners or not available_slots:
                return JsonResponse({
                    "messages": ["I apologize, but there are no available appointment slots at this time."],
                    "type": "error"
                }), self.session

            return JsonResponse({
                "messages": ["Please select a healthcare provider and preferred time from the available slots:"],
                "type": "appointment_booking",
                "data": {
                    "practitioners": practitioners,
                    "available_slots": available_slots
                }
            }), self.session

        except Exception as e:
            logger.error(f"Error handling appointment booking: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I apologize, but I couldn't process your appointment booking request at this time."],
                "type": "error"
            }), self.session

    async def _handle_reschedule_request(self):
        """Handle appointment rescheduling requests."""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["Please verify your identity first to reschedule appointments."]
                }), self.session

            # Fetch upcoming appointments
            appointments = await get_patient_appointments(self.patient_id)
            if not appointments:
                return JsonResponse({
                    "messages": ["You don't have any upcoming appointments to reschedule."]
                }), self.session

            # Format appointment list for selection
            messages = ["Which appointment would you like to reschedule?"]
            appointment_map = {}
            for i, appt in enumerate(appointments, 1):
                formatted_time = await self._format_appointment_time(appt["start"])
                messages.append(f"{i}. {formatted_time} with {appt['provider']}")
                appointment_map[str(i)] = appt["id"]

            messages.append("\nEnter the number of the appointment you'd like to reschedule.")

            # Store selection context
            self.session["reschedule_options"] = appointment_map
            await update_session(self.user_id, self.session)

            return JsonResponse({"messages": messages})
        except Exception as e:
            logger.error(f"Error handling reschedule request: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble retrieving your appointments. Please try again later."]
            }), self.session

    async def _handle_lab_results(self, message=None, intent_data=None, user_id=None):
        """Handle requests to view lab results"""
        try:
            if not self.patient_id:
                return JsonResponse({
                    "messages": ["Please verify your identity first to view your lab results."]
                }), self.session

            logger.debug(f"Fetching lab results for patient {self.patient_id}")

            # Try a simpler query first
            try:
                # First, try just getting DiagnosticReport without includes
                diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                    "patient": f"Patient/{self.patient_id}",
                    "_sort": "-date"
                })

                logger.debug(f"Initial query response: {diagnostic_reports}")

                if not diagnostic_reports or 'entry' not in diagnostic_reports:
                    # Try alternative category coding
                    diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                        "patient": f"Patient/{self.patient_id}",
                        "category": "LAB",
                        "_sort": "-date"
                    })
                    if not diagnostic_reports or 'entry' not in diagnostic_reports:
                        return JsonResponse({
                            "messages": ["No lab results found in your records."]
                        }), self.session

            except Exception as query_error:
                logger.error(f"Error in initial lab results query: {str(query_error)}")
                # Try fallback query
                diagnostic_reports = await self.fhir_service.search("DiagnosticReport", {
                    "patient": self.patient_id,  # Try without Patient/ prefix
                    "_sort": "-date"
                })

            # Format the results
            formatted_results = ["Here are your lab results:"]

            if diagnostic_reports and 'entry' in diagnostic_reports:
                for entry in diagnostic_reports['entry']:
                    report = entry['resource']
                    if report['resourceType'] != 'DiagnosticReport':
                        continue

                    # Get basic report info
                    date = report.get('effectiveDateTime', report.get('issued', '')).split('T')[0]

                    # Try different ways to get the category
                    category = None
                    if 'category' in report:
                        for cat in report['category']:
                            if 'text' in cat:
                                category = cat['text']
                                break
                            elif 'coding' in cat:
                                for coding in cat['coding']:
                                    if coding.get('display'):
                                        category = coding['display']
                                        break

                    category = category or 'Laboratory'

                    formatted_results.append(f"\n {category} Report ({date})")

                    # Add the conclusion if available
                    if report.get('conclusion'):
                        formatted_results.append(f"Conclusion: {report['conclusion']}")

                    # Get the actual results
                    if 'result' in report:
                        try:
                            for result_ref in report['result']:
                                # Try to get the referenced observation
                                obs_id = result_ref['reference'].split('/')[-1]
                                observation = await self.fhir_service.read("Observation", obs_id)

                                if observation:
                                    test_name = observation.get('code', {}).get('text', 'Unknown Test')
                                    value = observation.get('valueQuantity', {})
                                    if value:
                                        value_str = f"{value.get('value', '')} {value.get('unit', '')}"
                                        formatted_results.append(f"- {test_name}: {value_str}")
                                    else:
                                        # Handle non-numeric results
                                        value_str = observation.get('valueString',
                                                  observation.get('valueCodeableConcept', {}).get('text',
                                                  'No value recorded'))
                                        formatted_results.append(f"- {test_name}: {value_str}")
                        except Exception as obs_error:
                            logger.error(f"Error fetching observation details: {str(obs_error)}")
                            formatted_results.append("- Unable to fetch detailed results")

            if len(formatted_results) == 1:  # Only has the header
                return JsonResponse({
                    "messages": ["No lab results found in your records."]
                }), self.session

            logger.debug("Successfully formatted lab results")
            return JsonResponse({
                "messages": formatted_results
            }), self.session

        except Exception as e:
            logger.error(f"Error handling lab results: {str(e)}", exc_info=True)
            return JsonResponse({
                "messages": ["I'm having trouble retrieving your lab results right now. Please try again later."]
            }), self.session

    async def _analyze_lab_question(self, message, lab_results):
        """Analyze the user's question about lab results with improved context"""
        try:
            # Get the last lab topic from session if it exists
            last_lab_context = self.session.get('last_lab_context', {})

            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                temperature=0.1,
                messages=[
                    {
                        "role": "system",
                        "content": """
                        You are a medical lab result analyzer.
                        If the question appears to be a follow-up, use the previous lab context.
                        Analyze the user's question and return a JSON structure with:
                        - test_name: The specific test being asked about (or use previous context if it's a follow-up)
                        - comparison_type: "value", "trend", or "reference_range"
                        - temporal_context: "most_recent", "specific_date", or "trend"
                        - question_type: "interpretation", "comparison", or "general"
                        - is_followup: true if this appears to be a follow-up question
                        """
                    },
                    {
                        "role": "user",
                        "content": f"""
                        Previous lab context: {json.dumps(last_lab_context)}
                        Current question: {message}
                        Available results: {lab_results}
                        """
                    }
                ]
            )

            analysis = json.loads(response.choices[0].message.content)

            # Update session with current lab context
            self.session['last_lab_context'] = {
                'test_name': analysis.get('test_name'),
                'last_query': message,
                'timestamp': datetime.now().isoformat()
            }

            return analysis

        except Exception as e:
            logger.error(f"Error analyzing lab question: {str(e)}")
            raise

    async def _find_specific_result(self, lab_results_response, test_info):
        """Find specific lab result with improved logging"""
        try:
            test_name = test_info['test_name'].lower()
            target_date = test_info.get('target_date')
            logger.debug(f"Looking for test: {test_name}")

            # Extract messages from JsonResponse
            if hasattr(lab_results_response, 'content'):
                content = json.loads(lab_results_response.content.decode())
                messages = content.get('messages', [])
            else:
                messages = lab_results_response.get('messages', [])

            logger.debug(f"Processing messages: {messages}")

            current_date = None
            for message in messages:
                if 'Date:' in message:
                    current_date = message.replace('Date:', '').strip()
                    logger.debug(f"Found date: {current_date}")
                elif test_name in message.lower():
                    logger.debug(f"Found matching test: {message}")
                    # Extract test details using regex
                    match = re.match(r'-\s*([^:]+):\s*(\d+\.?\d*)\s*([^\s\(]+)(?:\s*\(Reference Range:\s*([^\)]+)\))?', message)
                    if match:
                        return {
                            'test_name': match.group(1).strip(),
                            'value': match.group(2),
                            'unit': match.group(3),
                            'reference_range': match.group(4) if match.group(4) else None,
                            'date': current_date
                        }

            return None

        except Exception as e:
            logger.error(f"Error finding specific result: {str(e)}")
            return None

    async def _format_lab_response(self, result, test_info):
        """Format lab result with educational context only - flexible for any biomarker"""
        try:
            test_name = result.get('test_name', '')
            value = result.get('value', '')
            unit = result.get('unit', '')
            ref_range = result.get('reference_range', '')
            date = result.get('date', '')

            # Basic result and range information
            response = [
                f"For your {test_name} from {date}:",
                f"Value: {value} {unit}",
                f"Reference Range: {ref_range}\n"
            ]

            try:
                current_value = float(value.split()[0])
                range_parts = ref_range.split('-')
                if len(range_parts) == 2:
                    low = float(range_parts[0])
                    high = float(range_parts[1])

                    # Simple position relative to range
                    if current_value < low:
                        response.append("This result is below the reference range.")
                    elif current_value > high:
                        response.append("This result is above the reference range.")
                    else:
                        response.append("This result is within the reference range.")

            except (ValueError, IndexError) as e:
                logger.error(f"Error analyzing values: {str(e)}")

            # Generic educational disclaimer for any biomarker
            response.extend([
                "\nImportant notes:",
                "- Laboratory results can be affected by many factors including:",
                "   Diet and nutrition",
                "   Physical activity",
                "   Time of day",
                "   Medications",
                "   Sample collection and handling",
                "",
                "- This information is for educational purposes only",
                "- Always consult your healthcare provider for medical advice",
                "- Your healthcare provider will interpret these results in the context of your overall health"
            ])

            return "\n".join(response)

        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}")
            return "Error displaying results. Please consult your healthcare provider."
    async def _handle_screening(self, message=None, intent_data=None):
       """Placeholder for screening intent handler."""
       return ["This is a placeholder for screening information."], self.session

    async def _parse_lab_query(self, query, context=None):
        """Parse lab query with improved date handling and context awareness"""
        try:
            test_info = {
                'test_name': None,
                'temporal_context': 'most_recent',
                'target_date': None
            }

            # Extract test name
            test_names = {
                'potassium': ['potassium', 'k+'],
                'glucose': ['glucose', 'blood sugar', 'sugar'],
                'hemoglobin': ['hemoglobin', 'hgb', 'hb'],
                # Add more test mappings
            }

            # Check for test name in query
            for test, aliases in test_names.items():
                if any(alias in query for alias in aliases):
                    test_info['test_name'] = test
                    break

            # If no test found but we have context, use that
            if not test_info['test_name'] and context and context.get('last_test'):
                test_info['test_name'] = context['last_test']

            # Parse dates using improved regex patterns
            date_patterns = [
                # Natural language dates
                r'(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|'
                r'jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|'
                r'dec(?:ember)?)\s+\d+(?:st|nd|rd|th)?(?:\s*,?\s*\d{4})?',
                # ISO format dates
                r'\d{4}-\d{2}-\d{2}',
                # Other common formats
                r'\d{2}/\d{2}/\d{4}'
            ]

            for pattern in date_patterns:
                match = re.search(pattern, query, re.IGNORECASE)
                if match:
                    test_info['temporal_context'] = 'specific_date'
                    test_info['target_date'] = await self._normalize_date(match.group())
                    break

            return test_info

        except Exception as e:
            logger.error(f"Error parsing lab query: {str(e)}")
            return {'test_name': None, 'temporal_context': 'most_recent', 'target_date': None}

    async def _normalize_date(self, date_str):
        """Convert various date formats to ISO format"""
        try:
            # Try parsing natural language dates
            if any(month in date_str.lower() for month in ['jan', 'feb', 'mar', 'apr', 'may', 'jun',
                                                          'jul', 'aug', 'sep', 'oct', 'nov', 'dec']):
                # Remove ordinal indicators and clean up
                date_str = re.sub(r'(st|nd|rd|th)', '', date_str)
                # Add current year if not specified
                if not re.search(r'\d{4}', date_str):
                    date_str = f"{date_str}, {datetime.now().year}"
                return datetime.strptime(date_str, "%B %d, %Y").strftime("%Y-%m-%d")

            # Handle other common formats
            for fmt in ["%Y-%m-%d", "%m/%d/%Y", "%d/%m/%Y"]:
                try:
                    return datetime.strptime(date_str, fmt).strftime("%Y-%m-%d")
                except ValueError:
                    continue

            raise ValueError(f"Unable to parse date: {date_str}")

        except Exception as e:
            logger.error(f"Error normalizing date {date_str}: {str(e)}")
            return None
    def _get_clinic_timezone(self):
        """Get the clinic timezone from settings or use default"""
        try:
            return ZoneInfo(settings.TIME_ZONE) if hasattr(settings, 'TIME_ZONE') else ZoneInfo("UTC")
        except Exception as e:
            logger.error(f"Error getting clinic timezone: {str(e)}")
            return ZoneInfo("UTC")  # Default to UTC


    async def _update_session(self):
        """Update session state"""
        try:
            self.session['last_interaction'] = datetime.now().isoformat()
            self.session['verified'] = True
            await update_session(self.user_id, self.session)
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            raise

    async def _handle_capabilities_query(self):
        capabilities = [
            "Schedule new medical appointments",
            "View your upcoming appointments",
            "Cancel existing appointments",
            "Access and explain your medical records, including:",
            "    Current conditions",
            "    Active medications",
            "    Recent procedures",
            "View and explain your test results",
            "Receive medication reminders",
            "Get notifications for annual screenings and check-ups",
            "Answer questions about your health information",
            "Provide general medical information and guidance",
            "Send appointment reminders via SMS",
            "Communicate through email notifications"
        ]

        response_text = "I can help you with:\n\n" + "\n".join(capabilities) + \
                   "\n\nPlease note: While I can provide information and explanations based on your medical records, " + \
                   "I am not a substitute for professional medical advice. Always consult your healthcare provider " + \
                   "for medical decisions."

        return JsonResponse({
            "messages": [response_text],
            "type": "capabilities"
        }), self.session

    async def _handle_explanation_query(self, message=None, intent_data=None):
        # Get the original text and check for context reset
        original_text = intent_data.get('entities', {}).get('original_text', '').lower()

        # Clear context if user explicitly states they're not talking about previous topic
        if 'not talking about' in original_text or 'i dont mean' in original_text:
            self.session.pop('last_topic', None)
            self.session.pop('last_context', None)
            await update_session(self.user_id, self.session)  # Ensure session update is persisted
            return JsonResponse({
                "messages": [
                    "I understand you want an explanation about something else. "
                    "Could you please specify what exactly you'd like me to explain? "
                    "I can help explain:"
                    "\n- Medical terms"
                    "\n- Test results"
                    "\n- Procedures"
                    "\n- Medications"
                    "\n- Or other health-related topics"
                ]
            }), self.session

        # Extract key terms from the topic to determine what needs explanation
        key_terms = {
            'check-up': 'regular medical check-ups and preventive care',
            'screening': 'medical screening and preventive tests',
            'vaccination': 'vaccinations and immunizations',
            'blood test': 'blood tests and laboratory work',
            'medication': 'medication adherence and treatment plans',
            'appointment': 'medical appointments and follow-ups',
            'test results': 'medical test results and monitoring',
            'symptoms': 'symptom monitoring and reporting'
        }

        topic = intent_data.get('entities', {}).get('topic', '')

        # Determine the explanation topic
        explanation_topic = None
        for term, description in key_terms.items():
            if term.lower() in topic.lower():
                explanation_topic = description
                break

        # If no specific term found, use a generic medical topic
        if not explanation_topic:
            explanation_topic = "general medical advice and recommendations"

        messages = [
            {
                "role": "system",
                "content": f"""You are a medical assistant providing clear explanations about {explanation_topic}.
                Explain the importance and benefits in simple terms, focusing on preventive care and health maintenance.
                Include:
                1. Why it's important
                2. Key benefits
                3. Potential risks of neglecting it
                4. General recommendations

                Keep the tone informative but reassuring."""
            },
            {
                "role": "user",
                "content": f"Please explain why {explanation_topic} is important for maintaining good health."
            }
        ]

        response = await self.openai_client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=messages,
            temperature=0.7
        )

        explanation = response.choices[0].message.content

        # Update conversation history
        if hasattr(self, 'conversation_history'):
            self.conversation_history.append({
                'text': topic,
                'is_user': True,
                'timestamp': datetime.now().isoformat()
            })
            self.conversation_history.append({
                'text': explanation,
                'is_user': False,
                'timestamp': datetime.now().isoformat()
            })

        return JsonResponse({
            "messages": [explanation]
        }), self.session

    async def _handle_reset_context(self, intent_data):
        # Clear context
        self.session.pop('last_topic', None)
        self.session.pop('last_context', None)
        self.session.pop('current_test', None)
        self.lab_context = {'last_results': None, 'current_topic': None}
        await update_session(self.user_id, self.session)  # Ensure session update is persisted

        excluded_topic = intent_data.get('entities', {}).get('excluded_topic')
        response = f"I understand you don't want to talk about {excluded_topic if excluded_topic else 'the previous topic'}. "
        response += "What would you like to discuss instead? I can help with:\n"
        response += "- Your medical records\n"
        response += "- Scheduling appointments\n"
        response += "- Explaining lab results\n"
        response += "- General health information\n"
        response += "Or you can ask 'what can you do' to see all my capabilities."

        return [response], self.session

================
File: Django_app/chatbot/views/handlers/context_manager.py
================
"""
chatbot/views/handlers/context_manager.py

This module manages conversation context for a HIPAA-compliant medical chatbot.
It supports threaded conversations, adaptive topic switching, incremental summarization,
and semantic retrieval while ensuring robust PHI redaction, local embedding generation,
and enhanced topic & fact extraction.
"""

import logging
import json
import re
from datetime import datetime
from typing import List, Dict, Any
import hashlib
import os
from dotenv import load_dotenv
import sys
from pathlib import Path

# Add the project root directory to Python path
project_root = str(Path(__file__).resolve().parent.parent.parent)
sys.path.append(project_root)

from dotenv import load_dotenv
load_dotenv()

import django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
django.setup()
import numpy as np
from django.conf import settings
from openai import AsyncOpenAI
load_dotenv()

import django
from asgiref.sync import sync_to_async
# Session update function (ensure this function handles encryption and secure storage)
from chatbot.views.services.session import update_session
print ("15")
# ---------------------------
# Initialize Global Components
# ---------------------------

# Initialize Microsoft Presidio Analyzer for PHI detection
try:
    from presidio_analyzer import AnalyzerEngine
    presidio_analyzer = AnalyzerEngine()
except ImportError:
    raise ImportError("Please install presidio-analyzer for robust PHI redaction.")

# Initialize spaCy with a medical model if available, otherwise fallback
try:
    import spacy
    nlp = spacy.load("en_core_web_lg")
except Exception as e:
    logging.warning("en_core_web_lg not found. Falling back to en_core_web_sm. Error: %s", e)
    import spacy
    nlp = spacy.load("en_core_web_sm")

# Initialize SentenceTransformer for generating real embeddings locally
try:
    from sentence_transformers import SentenceTransformer
    embedding_model = SentenceTransformer("all-MiniLM-L6-v2")
except ImportError:
    raise ImportError("Please install sentence_transformers to generate embeddings.")

# Initialize a zero-shot classification pipeline from Hugging Face for topic classification
try:
    from transformers import pipeline
    topic_classifier = pipeline("zero-shot-classification", model="facebook/bart-large-mnli")
except ImportError:
    raise ImportError("Please install transformers to enable topic classification.")

logger = logging.getLogger(__name__)

# ---------------------------
# Utility Functions
# ---------------------------

def redact_sensitive_info(text: str) -> str:
    """
    Use Microsoft Presidio to detect and redact PHI in the text.
    """
    try:
        results = presidio_analyzer.analyze(text=text, language="en")
        for result in results:
            # Replace each detected entity with [REDACTED]
            text = text.replace(result.entity_text, "[REDACTED]")
    except Exception as e:
        logger.error(f"Error in PHI redaction: {str(e)}", exc_info=True)
    return text

def generate_embedding(text: str) -> np.ndarray:
    """
    Generate a real embedding vector for the text using SentenceTransformer.
    """
    # Ensure text is redacted before embedding to avoid storing raw PHI
    redacted_text = redact_sensitive_info(text)
    embedding = embedding_model.encode(redacted_text)
    return embedding

def cosine_similarity(vec1: np.ndarray, vec2: np.ndarray) -> float:
    """
    Compute cosine similarity between two vectors.
    """
    norm1 = np.linalg.norm(vec1)
    norm2 = np.linalg.norm(vec2)
    if norm1 == 0 or norm2 == 0:
        return 0.0
    return float(np.dot(vec1, vec2) / (norm1 * norm2))

def compute_hash(text: str) -> str:
    """
    Compute an MD5 hash of the given text.
    Useful for caching summaries.
    """
    return hashlib.md5(text.encode("utf-8")).hexdigest()

async def summarize_messages(messages: List[str], openai_client: AsyncOpenAI) -> str:
    """
    Use GPT-4-turbo (or similar) to generate a concise bullet-point summary.
    Redacts sensitive data before summarization.
    """
    if not messages:
        return ""

    # Redact PHI in each message and join them
    joined_messages = "\n".join(f"User: {redact_sensitive_info(m)}" for m in messages)
    
    system_prompt = (
        "You are an assistant that summarizes conversation context. "
        "Return a concise bullet list (max ~100 tokens) capturing key user info "
        "(symptoms, conditions, preferences) without including any sensitive data."
    )

    prompt = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Conversation so far:\n{joined_messages}"}
    ]

    try:
        response = await openai_client.chat.completions.create(
            model="gpt-4-turbo",  # Adjust as needed
            messages=prompt,
            temperature=0.7,
            max_tokens=150
        )
        summary_text = response.choices[0].message.content.strip()
        return summary_text
    except Exception as e:
        logger.error(f"Error summarizing messages: {str(e)}", exc_info=True)
        return ""

def classify_topic(message: str) -> str:
    """
    Classify the topic of the message using a zero-shot classification pipeline.
    """
    candidate_labels = ["scheduling", "medication", "symptoms", "general"]
    try:
        result = topic_classifier(message, candidate_labels)
        topic = result["labels"][0]
        return topic
    except Exception as e:
        logger.error(f"Error classifying topic: {str(e)}", exc_info=True)
        # Fallback to keyword matching
        message_lower = message.lower()
        if "appointment" in message_lower or "schedule" in message_lower:
            return "scheduling"
        elif "medication" in message_lower or "prescription" in message_lower:
            return "medication"
        elif "symptom" in message_lower or "pain" in message_lower:
            return "symptoms"
        else:
            return "general"

def extract_medical_facts(text: str) -> Dict[str, str]:
    """
    Use spaCy's NER to extract medical-related entities such as conditions and medications.
    """
    facts = {}
    try:
        doc = nlp(text)
        for ent in doc.ents:
            # You may refine this based on the entity labels your model produces.
            if ent.label_.lower() in ["condition", "disease", "symptom"]:
                facts["condition"] = ent.text
            elif ent.label_.lower() in ["medication", "drug"]:
                facts["medication"] = ent.text
    except Exception as e:
        logger.error(f"Error extracting medical facts: {str(e)}", exc_info=True)
    return facts

# ---------------------------
# ContextManager Class
# ---------------------------

class ContextManager:
    def __init__(self, user_id: str, session: Dict[str, Any], openai_client: AsyncOpenAI):
        self.user_id = user_id
        self.session = session
        self.openai_client = openai_client

        # Retrieve or initialize conversation data from the session.
        self.conversation_history = self.session.get("conversation_history", [])
        self.topic_summaries = self.session.get("topic_summaries", {})  # {topic: summary}
        self.embeddings = self.session.get("embeddings", {})  # {timestamp: embedding vector as list}
        # Cache summary hashes to avoid unnecessary API calls.
        self.summary_cache = self.session.get("summary_cache", {})

    async def add_message(self, user_id: str, message: str):
        """
        Add a new message to the conversation.
        Processes the message with robust PHI redaction, topic classification,
        and embedding generation.
        """
        topic = classify_topic(message)
        redacted_message = redact_sensitive_info(message)
        timestamp = datetime.now().isoformat()

        # Extract additional facts from the raw message using spaCy.
        extracted_facts = extract_medical_facts(message)

        message_entry = {
            "message": redacted_message,            # Redacted version for storage
            "original_message": message,            # Raw text (ensure strict access controls)
            "is_user": True,
            "timestamp": timestamp,
            "topic": topic,
            "facts": extracted_facts
        }

        self.conversation_history.append(message_entry)
        self.session["conversation_history"] = self.conversation_history

        # Generate and store an embedding for the redacted message.
        embedding = generate_embedding(redacted_message)
        self.embeddings[timestamp] = embedding.tolist()  # Save as list for JSON serialization
        self.session["embeddings"] = self.embeddings

        # Update the summary for the specific topic if necessary.
        await self._maybe_summarize_history(topic)

        logger.info(f"Added message for user {user_id} with topic '{topic}' at {timestamp}")
        await self.save_session()

    async def get_context(self, user_id: str, current_topic: str = "general") -> Dict[str, Any]:
        """
        Retrieve the current context for the conversation.
        Returns:
          - Topic-specific summary
          - Last N (default 10) messages matching the current topic
        """
        recent_messages = [msg for msg in self.conversation_history if msg.get("topic") == current_topic][-10:]
        summary = self.topic_summaries.get(current_topic, self.session.get("conversation_summary", ""))
        return {"summary": summary, "recent_messages": recent_messages}

    async def add_user_fact(self, user_id: str, fact_type: str, fact: str):
        """
        Add or update a user-specific fact (e.g., conditions, medications) in the session.
        """
        user_facts = self.session.get("user_facts", {}).get(fact_type, [])
        if fact not in user_facts:
            user_facts.append(fact)
            self.session.setdefault("user_facts", {})[fact_type] = user_facts
            logger.info(f"Added {fact_type} fact for user {user_id}: {fact}")
            await self.save_session()

    async def _build_gpt_prompt(self, user_input: str, current_topic: str = "general") -> str:
        """
        Build the system prompt for GPT including user facts and conversation context.
        """
        user_facts = self.session.get("user_facts", {})
        facts_str = "\n".join(f"- {k}: {v}" for k, v in user_facts.items())
        conversation_summary = self.topic_summaries.get(current_topic, self.session.get("conversation_summary", ""))

        system_prompt = f"""
You are a helpful, HIPAA-compliant medical assistant.
Known user facts:
{facts_str}

Summarized conversation (topic: '{current_topic}'):
{conversation_summary}

The user says: {user_input}
"""
        return system_prompt

    async def get_user_facts(self, user_id: str) -> Dict[str, List[str]]:
        """
        Retrieve stored user facts.
        """
        return self.session.get("user_facts", {})

    async def save_session(self):
        """
        Save the updated session.
        Ensure that the session backend is secure and encrypted.
        """
        logger.info(f"Session saved for user {self.user_id} at {datetime.now().isoformat()}")
        await update_session(self.user_id, self.session)

    async def _maybe_summarize_history(self, topic: str):
        """
        If the number of raw messages for a given topic exceeds a threshold,
        generate and cache a summary to reduce API calls and keep context lean.
        """
        MAX_RAW_MESSAGES = 10
        topic_messages = [msg for msg in self.conversation_history if msg.get("topic") == topic]
        if len(topic_messages) > MAX_RAW_MESSAGES:
            # Build a concatenated string of the messages to summarize.
            older_chunk = [msg["message"] for msg in topic_messages[:-MAX_RAW_MESSAGES]]
            combined_text = "\n".join(older_chunk)
            text_hash = compute_hash(combined_text)

            # Check if this summary is already cached.
            if self.summary_cache.get(topic) == text_hash:
                logger.info(f"Summary for topic '{topic}' is already up-to-date; skipping summarization.")
                return

            summary_text = await summarize_messages(older_chunk, self.openai_client)
            old_summary = self.topic_summaries.get(topic, "")
            combined_summary = f"{old_summary}\n{summary_text}".strip() if old_summary else summary_text
            self.topic_summaries[topic] = combined_summary
            self.session["topic_summaries"] = self.topic_summaries

            # Cache the hash for this topic summary.
            self.summary_cache[topic] = text_hash
            self.session["summary_cache"] = self.summary_cache

            # Prune older messages for this topic (retain only the last MAX_RAW_MESSAGES).
            recent_topic_messages = topic_messages[-MAX_RAW_MESSAGES:]
            # Remove all messages of this topic and add back the recent ones.
            self.conversation_history = [msg for msg in self.conversation_history if msg.get("topic") != topic] + recent_topic_messages
            self.session["conversation_history"] = self.conversation_history

            await self.save_session()
            logger.info(f"Summarized and pruned history for topic '{topic}' for user {self.user_id}")

    async def _extract_user_facts(self, message_text: str) -> Dict[str, str]:
        """
        Optionally extract key facts (e.g., conditions or medications) using spaCy.
        This method calls extract_medical_facts, which is a synchronous function.
        """
        # Use sync_to_async to properly wrap the synchronous function
        # This ensures the method correctly returns an awaitable result
        extract_medical_facts_async = sync_to_async(extract_medical_facts)
        facts = await extract_medical_facts_async(message_text)
        return facts

    async def retrieve_similar_messages(self, current_input: str, top_n: int = 5) -> List[Dict[str, Any]]:
        """
        Retrieve semantically similar messages using embeddings.
        """
        current_embedding = generate_embedding(redact_sensitive_info(current_input))
        similarities = []
        for msg in self.conversation_history:
            msg_timestamp = msg.get("timestamp")
            msg_embedding_list = self.embeddings.get(msg_timestamp)
            if msg_embedding_list:
                msg_embedding = np.array(msg_embedding_list)
                similarity = cosine_similarity(current_embedding, msg_embedding)
                similarities.append((similarity, msg))
        similarities.sort(key=lambda x: x[0], reverse=True)
        top_messages = [msg for sim, msg in similarities[:top_n]]
        return top_messages

print ("this script is working just fine ")

================
File: Django_app/chatbot/views/handlers/debug_utils.py
================
import logging
import inspect
import types
import sys
import traceback
from functools import wraps

# Configure logging
debug_logger = logging.getLogger('chatbot.debug')
debug_logger.setLevel(logging.DEBUG)

# Create file handler
file_handler = logging.FileHandler('chat_handler_debug.log')
file_handler.setLevel(logging.DEBUG)

# Create console handler
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Add handlers to logger
debug_logger.addHandler(file_handler)
debug_logger.addHandler(console_handler)

def trace_async_calls(cls):
    """
    Class decorator to trace all async method calls in ChatHandler
    """
    original_methods = {}
    
    # Store original methods and wrap them with debug logging
    for name, method in inspect.getmembers(cls, inspect.isfunction):
        if inspect.iscoroutinefunction(method):
            original_methods[name] = method
            
            @wraps(method)
            async def wrapped_method(self, *args, **kwargs):
                caller_frame = sys._getframe(1)
                caller_info = f"{caller_frame.f_code.co_filename}:{caller_frame.f_lineno}"
                
                debug_logger.debug(f"ENTER async {cls.__name__}.{method.__name__} called from {caller_info}")
                debug_logger.debug(f"  args: {args}")
                debug_logger.debug(f"  kwargs: {kwargs}")
                
                try:
                    result = await method(self, *args, **kwargs)
                    result_type = type(result).__name__
                    is_coroutine = inspect.iscoroutine(result)
                    debug_logger.debug(f"EXIT  async {cls.__name__}.{method.__name__} returned {result_type} (is_coroutine={is_coroutine})")
                    
                    if isinstance(result, tuple):
                        debug_logger.debug(f"  result is a tuple with len={len(result)}")
                        for i, item in enumerate(result):
                            debug_logger.debug(f"  result[{i}] type: {type(item).__name__}")
                    
                    return result
                except Exception as e:
                    debug_logger.error(f"ERROR in async {cls.__name__}.{method.__name__}: {str(e)}")
                    debug_logger.error(traceback.format_exc())
                    raise
            
            setattr(cls, name, wrapped_method)
    
    # Also wrap normal methods to detect if they're calling async methods without await
    for name, method in inspect.getmembers(cls, inspect.isfunction):
        if name not in original_methods and not inspect.iscoroutinefunction(method):
            original_methods[name] = method
            
            @wraps(method)
            def wrapped_normal_method(self, *args, **kwargs):
                debug_logger.debug(f"ENTER sync {cls.__name__}.{method.__name__}")
                
                try:
                    result = method(self, *args, **kwargs)
                    result_type = type(result).__name__
                    is_coroutine = inspect.iscoroutine(result)
                    debug_logger.debug(f"EXIT  sync {cls.__name__}.{method.__name__} returned {result_type} (is_coroutine={is_coroutine})")
                    
                    if is_coroutine:
                        debug_logger.error(f"WARNING: {cls.__name__}.{method.__name__} returned a coroutine without await!")
                    
                    return result
                except Exception as e:
                    debug_logger.error(f"ERROR in sync {cls.__name__}.{method.__name__}: {str(e)}")
                    debug_logger.error(traceback.format_exc())
                    raise
            
            setattr(cls, name, wrapped_normal_method)
    
    # Store original methods for reference
    cls._original_methods = original_methods
    return cls

def debug_intent_handlers(cls_instance):
    """
    Debug function to inspect all intent handlers in a ChatHandler instance.
    Call this after initialization to check all registered handlers.
    """
    debug_logger.debug("--- Inspecting Intent Handlers ---")
    for intent, handler in cls_instance.intent_handlers.items():
        is_async = inspect.iscoroutinefunction(handler)
        debug_logger.debug(f"Intent: {intent}, Handler: {handler.__name__}, Is Async: {is_async}")
    debug_logger.debug("--- End Intent Handlers Inspection ---")

async def trace_handler_execution(handler, *args, **kwargs):
    """
    Utility to trace a specific handler execution.
    Helps test individual handlers without running the full flow.
    """
    debug_logger.debug(f"Testing handler: {handler.__name__}")
    debug_logger.debug(f"Args: {args}")
    debug_logger.debug(f"Kwargs: {kwargs}")
    
    try:
        if inspect.iscoroutinefunction(handler):
            debug_logger.debug(f"{handler.__name__} is an async function, awaiting it")
            result = await handler(*args, **kwargs)
        else:
            debug_logger.debug(f"{handler.__name__} is a regular function, calling it directly")
            result = handler(*args, **kwargs)
        
        debug_logger.debug(f"Handler result type: {type(result).__name__}")
        if inspect.iscoroutine(result):
            debug_logger.error(f"WARNING: {handler.__name__} returned a coroutine that wasn't awaited!")
            # Try to handle it properly
            result = await result
            debug_logger.debug(f"After awaiting, result type: {type(result).__name__}")
            
        return result
    except Exception as e:
        debug_logger.error(f"Error in handler execution: {str(e)}")
        debug_logger.error(traceback.format_exc())
        raise

================
File: Django_app/chatbot/views/handlers/medical_handler.py
================
from django.conf import settings

from chatbot.views.services.fhir_service import get_patient_allergies, get_patient_conditions, get_patient_immunizations, get_patient_medications, get_practitioner_for_patient
from ..config import config
from ..utils.formatters import get_resource_name
import logging
import openai
from asgiref.sync import sync_to_async
from fhirclient.models.patient import Patient
from fhirclient.models.condition import Condition
from fhirclient.models.immunization import Immunization
from fhirclient.models.medicationrequest import MedicationRequest
from fhirclient.models.procedure import Procedure
from fhirclient.models.bundle import Bundle
openai.api_key = settings.OPENAI_API_KEY

print ("15")
# Configure logging
logger = logging.getLogger('chatbot')

# Initialize FHIR Client
fhir_client = config.fhir_client
# Initialize Redis client for session management




def format_medications_detailed(medication_entries):
    """
    Formats medication information with detailed dosage and timing.
    
    :param medication_entries: List of medication resources from FHIR server
    :return: Formatted string with medication details
    """
    if not medication_entries:
        return "No active medications found."
    
    try:
        formatted = ["Your current medications:"]
        
        for entry in medication_entries:
            med = entry['resource']
            
            # Get medication name
            med_code = med.get('medicationCodeableConcept', {})
            name = med_code.get('text') or \
                   med_code.get('coding', [{}])[0].get('display', 'Unknown Medication')
            
            formatted.append(f"\n- {name}")
            
            # Get status
            status = med.get('status', 'unknown')
            if status != 'active':
                formatted.append(f"  Status: {status}")
            
            # Process dosage instructions
            dosage_list = med.get('dosage', [])
            if dosage_list:
                for dosage in dosage_list:
                    # Get dose
                    dose_and_rate = dosage.get('doseAndRate', [{}])[0]
                    dose = dose_and_rate.get('doseQuantity', {})
                    dose_value = dose.get('value', '')
                    dose_unit = dose.get('unit', '')
                    if dose_value and dose_unit:
                        formatted.append(f"  Dose: {dose_value} {dose_unit}")
                    
                    # Get timing
                    timing = dosage.get('timing', {})
                    repeat = timing.get('repeat', {})
                    
                    # Frequency
                    frequency = repeat.get('frequency')
                    period = repeat.get('period')
                    period_unit = repeat.get('periodUnit', 'day')
                    if frequency and period:
                        formatted.append(f"  Frequency: {frequency} time(s) per {period} {period_unit}")
                    
                    # Specific times
                    times = repeat.get('timeOfDay', [])
                    if times:
                        formatted.append(f"  Times: {', '.join(times)}")
                    
                    # Route
                    route = dosage.get('route', {}).get('text')
                    if route:
                        formatted.append(f"  Route: {route}")
                    
                    # Additional instructions
                    instructions = dosage.get('patientInstruction')
                    if instructions:
                        formatted.append(f"  Instructions: {instructions}")
                    
                    # Method
                    method = dosage.get('method', {}).get('text')
                    if method:
                        formatted.append(f"  Method: {method}")
            
            # Get reason for medication
            reason_reference = med.get('reasonReference', [])
            if reason_reference:
                reasons = []
                for reason in reason_reference:
                    reason_display = reason.get('display')
                    if reason_display:
                        reasons.append(reason_display)
                if reasons:
                    formatted.append(f"  Reason: {', '.join(reasons)}")
            
            # Get additional notes
            note = med.get('note', [])
            if note:
                notes = [n.get('text') for n in note if n.get('text')]
                if notes:
                    formatted.append(f"  Notes: {' '.join(notes)}")
        
        return "\n".join(formatted)
    
    except Exception as e:
        logger.error(f"Error formatting medications: {str(e)}")
        return "Error formatting medication information."

async def get_complete_medical_record(patient_id, fhir_client):
    try:
        logger.debug(f"Fetching complete medical record for patient {patient_id}")
        
        # Use Patient.read to get patient information
        patient = await sync_to_async(Patient.read)(patient_id, fhir_client.server)
        
        # Use Condition.where to search for conditions
        conditions_bundle = await sync_to_async(Condition.where({
            'patient': patient_id,
            'clinical-status': 'active'
        }).perform)(fhir_client.server)
        
        # Use Immunization.where to search for immunizations
        immunizations_bundle = await sync_to_async(Immunization.where({
            'patient': patient_id,
            '_sort': '-date'
        }).perform)(fhir_client.server)
        
        # Use MedicationRequest.where to search for medications
        medications_bundle = await sync_to_async(MedicationRequest.where({
            'patient': patient_id,
            'status': 'active'
        }).perform)(fhir_client.server)
        
        # Use Procedure.where to search for procedures
        procedures_bundle = await sync_to_async(Procedure.where({
            'patient': patient_id,
            '_sort': '-date'
        }).perform)(fhir_client.server)

        # Now extract and format the data from the bundles
        # Patient information
        name = patient.name[0]
        formatted_name = f"{name.given[0]} {name.family}"

        # Conditions
        conditions = []
        if conditions_bundle.entry:
            for entry in conditions_bundle.entry:
                condition = entry.resource
                condition_name = condition.code.text or condition.code.coding[0].display
                conditions.append(condition_name)

        # Immunizations
        immunizations = []
        if immunizations_bundle.entry:
            for entry in immunizations_bundle.entry:
                immunization = entry.resource
                vaccine_name = immunization.vaccineCode.text or immunization.vaccineCode.coding[0].display
                occurrence_date = immunization.occurrenceDateTime.isostring.split('T')[0]
                immunizations.append(f"{vaccine_name} ({occurrence_date})")

        # Medications
        medications = []
        if medications_bundle.entry:
            for entry in medications_bundle.entry:
                medication_request = entry.resource
                med_code = medication_request.medicationCodeableConcept
                med_name = med_code.text or med_code.coding[0].display
                medications.append(med_name)

        # Procedures
        procedures = []
        if procedures_bundle.entry:
            for entry in procedures_bundle.entry:
                procedure = entry.resource
                proc_code = procedure.code
                proc_name = proc_code.text or proc_code.coding[0].display
                performed_date = procedure.performedDateTime.isostring.split('T')[0] if procedure.performedDateTime else ''
                procedures.append(f"{proc_name} ({performed_date})" if performed_date else proc_name)

        return {
            'name': formatted_name,
            'birthDate': patient.birthDate.isostring,
            'gender': patient.gender,
            'conditions': conditions,
            'immunizations': immunizations,
            'medications': medications,
            'procedures': procedures
        }

    except Exception as e:
        logger.error(f"Error in get_complete_medical_record: {str(e)}", exc_info=True)
        return None
def format_procedures(procedures):
    """
    Formats a list of procedures into a readable string with detailed information.
    
    :param procedures: List of procedure resources from FHIR server
    :return: Formatted string with procedure details
    """
    if not procedures:
        return "No past procedures found."
    
    try:
        formatted = ["Your past procedures:"]
        
        for procedure in procedures:
            # Get procedure name
            code = procedure.get('code', {})
            name = code.get('text') or \
                   code.get('coding', [{}])[0].get('display', 'Unknown Procedure')
            
            # Start new procedure entry
            formatted.append(f"\n- {name}")
            
            # Get performed date/period
            if 'performedDateTime' in procedure:
                performed_date = procedure['performedDateTime'].split('T')[0]
                formatted.append(f"  Date: {performed_date}")
            elif 'performedPeriod' in procedure:
                period = procedure['performedPeriod']
                start = period.get('start', '').split('T')[0]
                end = period.get('end', '').split('T')[0]
                if start == end:
                    formatted.append(f"  Date: {start}")
                else:
                    formatted.append(f"  Period: {start} to {end}")
            
            # Get status
            status = procedure.get('status', '')
            if status:
                formatted.append(f"  Status: {status}")
            
            # Get category
            category = procedure.get('category', {}).get('text')
            if category:
                formatted.append(f"  Category: {category}")
            
            # Get location
            location = procedure.get('location', {}).get('display')
            if location:
                formatted.append(f"  Location: {location}")
            
            # Get performer information
            performers = procedure.get('performer', [])
            if performers:
                performer_names = []
                for performer in performers:
                    actor = performer.get('actor', {})
                    display = actor.get('display')
                    if display:
                        performer_names.append(display)
                if performer_names:
                    formatted.append(f"  Performed by: {', '.join(performer_names)}")
            
            # Get outcome
            outcome = procedure.get('outcome', {}).get('text')
            if outcome:
                formatted.append(f"  Outcome: {outcome}")
            
            # Get complications
            complication = procedure.get('complication', [])
            if complication:
                complications = []
                for comp in complication:
                    comp_text = comp.get('text') or comp.get('coding', [{}])[0].get('display')
                    if comp_text:
                        complications.append(comp_text)
                if complications:
                    formatted.append(f"  Complications: {', '.join(complications)}")
            
            # Get follow-up
            follow_up = procedure.get('followUp', [])
            if follow_up:
                followups = []
                for fu in follow_up:
                    fu_text = fu.get('text') or fu.get('coding', [{}])[0].get('display')
                    if fu_text:
                        followups.append(fu_text)
                if followups:
                    formatted.append(f"  Follow-up: {', '.join(followups)}")
            
            # Get notes
            notes = procedure.get('note', [])
            if notes:
                note_texts = [note.get('text') for note in notes if note.get('text')]
                if note_texts:
                    formatted.append(f"  Notes: {' '.join(note_texts)}")
        
        return "\n".join(formatted)
    
    except Exception as e:
        logger.error(f"Error formatting procedures: {str(e)}")
        return "Error formatting procedure information."

def format_conditions(conditions):
    """
    Formats a list of conditions into a readable string.
    """
    if not conditions:
        return "No active conditions found."
    
    formatted = ["Your current conditions:"]
    for condition in conditions:
        try:
            # Get condition details
            name = condition.get('code', {}).get('text') or \
                   condition.get('code', {}).get('coding', [{}])[0].get('display', 'Unknown Condition')
            
            # Get severity if available
            severity = condition.get('severity', {}).get('text', '')
            severity_str = f" ({severity})" if severity else ""
            
            # Get onset date if available
            onset = condition.get('onsetDateTime', '').split('T')[0] if condition.get('onsetDateTime') else ''
            onset_str = f" - diagnosed on {onset}" if onset else ""
            
            # Get clinical status
            clinical_status = condition.get('clinicalStatus', {}).get('coding', [{}])[0].get('code', 'unknown')
            status_str = f" - {clinical_status}" if clinical_status != 'unknown' else ""
            
            formatted.append(f"- {name}{severity_str}{status_str}{onset_str}")
            
            # Add notes if available
            notes = condition.get('note', [])
            for note in notes:
                if note.get('text'):
                    formatted.append(f"  Note: {note['text']}")
                    
        except Exception as e:
            logger.error(f"Error formatting condition: {e}")
            formatted.append(f"- Error formatting condition")
    
    return "\n".join(formatted)
print ("16")

================
File: Django_app/chatbot/views/handlers/medication_reminder_handler.py
================
from ..services.medication_service import MedicationReminderService
from .chat_handler import ChatHandler
print ("18")
class MedicationReminderHandler(ChatHandler):
    def __init__(self):
        super().__init__()
        self.reminder_service = MedicationReminderService()

    def handle_reminder_response(self, message, session):
        """Handle patient responses to medication reminders."""
        response_text = message.lower().strip()
        patient_id = session.get('patient_id')
        
        if not patient_id:
            return self.create_error_response("Patient not identified")

        success = self.reminder_service.process_reminder_response(
            patient_id, 
            response_text
        )

        if success:
            return self.create_response(
                "Thank you for confirming your medication. Stay healthy!"
            )
        return self.create_response(
            "I'm not sure what you mean. Please reply 'TAKEN' when you've taken your medication."
        )
print ("19")

================
File: Django_app/chatbot/views/handlers/symptom_guidance_handler.py
================
# chatbot/views/handlers/symptom_guidance_handler.py
from datetime import datetime
import json
from django.http import JsonResponse
import logging
from ..services.symptom_guidance_service import SymptomGuidanceService
from asgiref.sync import sync_to_async
print ("20")
logger = logging.getLogger('chatbot')

class SymptomGuidanceHandler:
    def __init__(self, session, user_message, user_id):
        self.session = session
        self.user_message = user_message
        self.user_id = user_id
        self.guidance_service = SymptomGuidanceService()
        self.patient = session.get('patient')
        self.patient_id = self.patient.get('id') if self.patient else None
        
    async def handle_symptom_guidance(self):
        """Handle symptom assessment and provide guidance"""
        try:
            logger.info(f"Processing symptom guidance for message: {self.user_message}")
            
            # 1. Check for red flags first - wrap sync method
            has_red_flags, red_flags = await sync_to_async(self.guidance_service.red_flag_checker)(self.user_message)
            
            if has_red_flags:
                logger.warning(f"Red flags detected: {red_flags}")
                emergency_response = await sync_to_async(self.guidance_service.response_formatter)({
                    'level': 'EMERGENCY',
                    'action': 'Seek immediate emergency care',
                    'red_flags': red_flags
                }, self.patient.get('resource') if self.patient else None)
                
                # Additionally provide detailed guidance for red flag cases
                specific_response = await sync_to_async(self.guidance_service.provide_specific_info)(
                    self.user_message,
                    emergency=True
                )
                
                # Combine emergency and specific guidance
                combined_messages = emergency_response['messages'] + specific_response['messages']
                
                return JsonResponse({
                    'messages': combined_messages,
                    'risk_level': 'EMERGENCY'
                })
            
            # 2. Analyze symptoms
            symptom_analysis = await sync_to_async(self.guidance_service.symptom_analyzer)(
                self.user_message,
                self.patient.get('resource') if self.patient else None
            )
            
            # 3. Determine risk level
            risk_assessment = await sync_to_async(self.guidance_service.risk_level_determiner)(
                symptom_analysis,
                red_flags if has_red_flags else None
            )
            
            # 4. Format response
            response = await sync_to_async(self.guidance_service.response_formatter)(
                risk_assessment,
                self.patient.get('resource') if self.patient else None
            )
            
            # 5. Get specific guidance based on symptoms
            specific_info = await sync_to_async(self.guidance_service.provide_specific_info)(
                self.user_message,
                emergency=False
            )
            
            # Combine general guidance with specific information
            response['messages'].extend(specific_info['messages'])
            
            # 6. Log the interaction
            await self._log_guidance_interaction(
                symptom_analysis,
                risk_assessment,
                response
            )
            
            return JsonResponse(response)
            
        except Exception as e:
            logger.error(f"Error in symptom guidance: {str(e)}", exc_info=True)
            return JsonResponse({
                'messages': [
                    "I apologize, but I encountered an error while analyzing your symptoms.",
                    "For your safety, please contact your healthcare provider or emergency services if you're concerned."
                ]
            })
    
    async def _log_guidance_interaction(self, analysis, assessment, response):
        """Log the guidance interaction for audit purposes"""
        try:
            interaction_log = {
                'timestamp': datetime.utcnow().isoformat(),
                'patient_id': self.patient_id,
                'original_message': self.user_message,
                'symptom_analysis': analysis,
                'risk_assessment': assessment,
                'response_given': response,
                'session_id': self.session.get('id')
            }
            
            await sync_to_async(logger.info)(f"Symptom guidance interaction logged: {json.dumps(interaction_log)}")
            
        except Exception as e:
            await sync_to_async(logger.error)(f"Error logging guidance interaction: {str(e)}")
print ("21")

================
File: Django_app/chatbot/views/services/fhir_service.py
================
# chatbot/views/services/fhir_service.py
# chatbot/views/services/fhir_service.py

from django.conf import settings
from fhirclient import client
from chatbot.views.utils.shared import get_resource_name
from datetime import datetime
from zoneinfo import ZoneInfo
import urllib.parse
import logging
from asgiref.sync import sync_to_async
import requests
import httpx

# Configure logging
logger = logging.getLogger('chatbot')
print ("22")
# Initialize FHIR Client
def get_fhir_client():
    """Get a configured FHIR client instance"""
    settings_dict = {
        'app_id': 'anna_chatbot',  # Replace with your actual app ID
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        fhir_server = client.FHIRClient(settings=settings_dict).server
        logger.info("FHIR server initialized successfully")
        return fhir_server  # Return server instance which has request_json method
    except Exception as e:
        logger.error(f"Failed to initialize FHIR server: {e}")
        raise

# Initialize global FHIR client with the server object
def get_fhir_server():
    """Get FHIR server instance with proper configuration"""
    settings_dict = {
        'app_id': 'anna_chatbot',
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        smart = client.FHIRClient(settings=settings_dict)
        logger.info("FHIR server initialized successfully")
        return smart.server  # Return the server object that has request_json
    except Exception as e:
        logger.error(f"Failed to initialize FHIR server: {e}")
        raise

# Initialize global FHIR server
fhir_server = get_fhir_server()

# Add all these standalone functions
async def get_patient_by_email(email):
    """Get patient by email"""
    fhir_service = FHIRService()
    result = await fhir_service.search('Patient', {'email': email})
    return result

async def get_patient_by_phone(phone_number):
    """Get patient by phone number"""
    fhir_service = FHIRService()
    # Clean the phone number to just digits
    clean_phone = ''.join(c for c in phone_number if c.isdigit())
    
    # Try multiple search patterns
    search_attempts = [
        {'telecom': f"phone|{phone_number}"},
        {'telecom': f"phone|{clean_phone}"},
        {'telecom': phone_number},
        {'telecom': clean_phone}
    ]
    
    # Try each pattern
    for params in search_attempts:
        result = await fhir_service.search('Patient', params)
        if result and 'entry' in result and result['entry']:
            return result
    
    # If no match, get first patient for demo
    return await fhir_service.search('Patient', {'_count': '1'})

async def get_patient_allergies(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_allergies(patient_id)

async def get_patient_conditions(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_conditions(patient_id)

async def get_patient_immunizations(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_immunizations(patient_id)

async def get_patient_medications(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_medications(patient_id)

async def get_practitioner_for_patient(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_practitioner_for_patient(patient_id)

async def get_available_practitioners():
    fhir_service = FHIRService()
    return await fhir_service.get_available_practitioners()

async def get_practitioner(practitioner_id):
    fhir_service = FHIRService()
    return await fhir_service.get_practitioner(practitioner_id)

async def get_patient_procedures(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_procedures(patient_id)

async def get_complete_medical_record(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_complete_medical_record(patient_id)

async def get_user_appointments(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments(patient_id, timezone)

async def get_user_appointments_direct(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments_direct(patient_id, timezone)

async def get_user_appointments_formatted(patient_id, timezone='America/New_York'):
    fhir_service = FHIRService()
    return await fhir_service.get_user_appointments_formatted(patient_id, timezone)

async def search_available_slots(fhir_client):
    fhir_service = FHIRService()
    return await fhir_service.search_available_slots(fhir_client)

async def get_patient_appointments(patient_id):
    fhir_service = FHIRService()
    return await fhir_service.get_patient_appointments(patient_id)

class FHIRService:
    def __init__(self):
        self.base_url = settings.FHIR_SERVER_URL
        self.fhir_client = fhir_server
        self.logger = logging.getLogger('chatbot')
        self.fhir_client = get_fhir_client()

    async def search(self, resource_type, params=None):
        """Perform asynchronous FHIR search"""
        try:
            search_path = f"{resource_type}"
            if params:
                param_str = "&".join(f"{k}={v}" for k, v in params.items())
                search_path = f"{search_path}?{param_str}"
            
            logger.debug(f"FHIR search path: {search_path}")
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/{search_path}",
                    timeout=30.0
                )
                response.raise_for_status()
                return response.json()
                
        except httpx.TimeoutException:
            logger.error(f"FHIR search timeout for {search_path}")
            return None
        except httpx.HTTPError as e:
            logger.error(f"FHIR search HTTP error: {str(e)}")
            return None
        except Exception as e:
            logger.error(f"FHIR search error: {str(e)}")
            return None
            
    # Removed problematic get_patient_by_phone method - now using search directly

    def get_practitioner_name(self, resource):
        """Extracts practitioner's full name using the get_resource_name utility."""
        try:
            return get_resource_name(resource)
        except Exception as e:
            self.logger.error(f"Error getting practitioner name: {str(e)}")
            return "Unknown"

    def get_practitioner_specialty(self, resource):
        """Extracts practitioner's specialties from the resource."""
        try:
            qualifications = resource.get('qualification', [])
            specialties = []
            for qual in qualifications:
                code = qual.get('code', {})
                display = (code.get('text') or 
                          code.get('coding', [{}])[0].get('display'))
                if display:
                    specialties.append(display)
            return ', '.join(specialties) if specialties else 'General Practice'
        except Exception as e:
            self.logger.error(f"Error extracting practitioner specialty: {str(e)}")
            return 'General Practice'

    def get_patient(self, patient_id):
        """Get patient by ID"""
        try:
            patient = self.fhir_client.read("Patient", patient_id)
            self.logger.debug(f"Retrieved patient: {patient}")
            return patient
        except Exception as e:
            self.logger.error(f"Error retrieving patient {patient_id}: {str(e)}")
            return None

    async def get_patient_by_email(self, email: str):
        """Get patient by email"""
        try:
            search_params = {'telecom:contains': email}
            result = await self.search('Patient', search_params)  # Make sure this is awaited
            
            if result and 'entry' in result:
                return result['entry'][0]['resource']
            return None
            
        except Exception as e:
            logger.error(f"Error getting patient by email: {str(e)}")
            return None

    def get_patient_by_phone(self, phone_number):
        """Retrieves a patient resource from the FHIR server based on phone number."""
        try:
            self.logger.debug(f"Searching for patient with phone number: {phone_number}")
            
            search_params = [
                {"telecom": f"phone|{urllib.parse.quote(phone_number)}"},
                {"telecom": phone_number}
            ]

            for params in search_params:
                try:
                    # Construct search query
                    query_string = '&'.join(f'{k}={v}' for k, v in params.items())
                    path = f"Patient?{query_string}"
                    result = self.fhir_client.request_json(path)
                    
                    if result and 'entry' in result and result['entry']:
                        patient = result['entry'][0]['resource']
                        self.logger.debug(f"Found patient: {patient}")
                        return patient
                except Exception as search_error:
                    self.logger.debug(f"Search attempt failed: {str(search_error)}")
                    continue

            self.logger.debug("No patient found with the given phone number.")
            return None

        except Exception as e:
            self.logger.error(f"Error retrieving patient by phone: {e}")
            return None

    def get_practitioner_for_patient(self, patient):
        """Retrieves the practitioner's information linked to the patient."""
        try:
            general_practitioners = patient.get('generalPractitioner', [])
            if general_practitioners:
                practitioner_ref = general_practitioners[0].get('reference')
                if practitioner_ref:
                    practitioner_id = practitioner_ref.split('/')[-1]
                    practitioner = self.fhir_client.read("Practitioner", practitioner_id)
                    if practitioner:
                        self.logger.debug(f"Practitioner found: {practitioner.get('id')}")
                        return practitioner
            self.logger.debug("No practitioner linked to the patient.")
            return None
        except Exception as e:
            self.logger.error(f"Error retrieving practitioner for patient: {str(e)}")
            return None

    async def get_user_appointments(self, patient_id, timezone='America/New_York'):
        """Get user appointments with detailed logging"""
        self.logger.debug(f"Starting get_user_appointments for patient {patient_id}")
        self.logger.debug(f"Using timezone: {timezone}")
        
        try:
            search_params = {
                'patient': f'Patient/{patient_id}',
                'status': 'booked,arrived,fulfilled'
            }
            self.logger.debug(f"Search parameters: {search_params}")
            
            appointments = await self.search('Appointment', search_params)
            self.logger.debug(f"Raw appointments response: {appointments}")
            
            if not appointments:
                self.logger.debug("No appointments found")
                return []

            formatted_appointments = []
            for entry in appointments.get('entry', []):
                appt = entry.get('resource', {})
                
                try:
                    # Get appointment details
                    start_time = datetime.fromisoformat(appt.get('start').replace('Z', '+00:00'))
                    local_time = start_time.astimezone(ZoneInfo(timezone))
                    
                    # Get practitioner details
                    practitioner_ref = None
                    for participant in appt.get('participant', []):
                        actor = participant.get('actor', {})
                        if actor.get('type') == 'Practitioner' or 'Practitioner/' in actor.get('reference', ''):
                            practitioner_ref = actor.get('reference')
                            break
                    
                    practitioner_name = "Unknown Provider"
                    if practitioner_ref:
                        practitioner_id = practitioner_ref.split('/')[-1]
                        practitioner = await self.read("Practitioner", practitioner_id)
                        if practitioner:
                            name = self.get_practitioner_name(practitioner)
                            specialty = self.get_practitioner_specialty(practitioner)
                            practitioner_name = f"{name} ({specialty})" if specialty != 'Unknown specialty' else name
                    
                    formatted_appointments.append({
                        'datetime': local_time.strftime("%A, %B %d%S at %I:%M %p"),
                        'practitioner': practitioner_name,
                        'status': appt.get('status', 'unknown'),
                        'id': appt.get('id'),
                        'description': appt.get('description', 'General appointment')
                    })
                except Exception as e:
                    self.logger.error(f"Error formatting appointment: {e}")
                    continue
                
            return sorted(formatted_appointments, key=lambda x: x['datetime'])
            
        except Exception as e:
            self.logger.error(f"Error getting appointments: {e}")
            return []

    async def get_patient_immunizations(self, patient_id):
        """
        Retrieves immunization history for a patient from the FHIR server.
        
        :param patient_id: The patient's FHIR resource ID
        :return: List of immunization resources or empty list if none found
        """
        try:
            self.logger.debug(f"Retrieving immunizations for patient ID: {patient_id}")
            
            # Search for Immunization resources
            search_params = {
                "patient": f"Patient/{patient_id}",
                "_sort": "-date"  # Sort by date in descending order
            }
            
            immunization_result = await self.search("Immunization", search_params)
            
            if immunization_result and 'entry' in immunization_result:
                immunizations = []
                for entry in immunization_result['entry']:
                    immunization = entry['resource']
                    
                    # Format each immunization with relevant information
                    formatted_immunization = {
                        'vaccineCode': {
                            'text': immunization.get('vaccineCode', {}).get('text') or 
                                   immunization.get('vaccineCode', {}).get('coding', [{}])[0].get('display', 'Unknown vaccine')
                        },
                        'occurrenceDateTime': immunization.get('occurrenceDateTime', ''),
                        'status': immunization.get('status', 'unknown'),
                        'doseNumber': immunization.get('protocolApplied', [{}])[0].get('doseNumber', ''),
                        'seriesDoses': immunization.get('protocolApplied', [{}])[0].get('seriesDoses', ''),
                        'manufacturer': immunization.get('manufacturer', {}).get('display', ''),
                        'lotNumber': immunization.get('lotNumber', ''),
                        'performer': [
                            {
                                'actor': {
                                    'display': perf.get('actor', {}).get('display', 'Unknown provider')
                                }
                            } for perf in immunization.get('performer', [])
                        ],
                        'note': [
                            {'text': note.get('text', '')} 
                            for note in immunization.get('note', [])
                        ]
                    }
                    
                    immunizations.append(formatted_immunization)
                
                self.logger.debug(f"Found {len(immunizations)} immunizations for patient")
                return immunizations
            
            self.logger.debug("No immunizations found for patient")
            return []
            
        except Exception as e:
            self.logger.error(f"Error retrieving patient immunizations: {e}")
            return []

    def get_patient_name(self, patient_resource):
        """Extracts patient's full name"""
        try:
            names = patient_resource.get('name', [])
            if not names:
                return "Patient"
            name = names[0]
            given = ' '.join(name.get('given', []))
            family = name.get('family', '')
            full_name = f"{given} {family}".strip()
            return full_name if full_name else "Patient"
        except Exception as e:
            self.logger.error(f"Error extracting patient name: {e}")
            return "Patient"

    async def get_patient_conditions(self, patient_id):
        """
        Retrieves active conditions for a patient from the FHIR server and formats them.
        
        Args:
            patient_id (str): The patient's FHIR resource ID
            
        Returns:
            list: List of formatted condition strings
        """
        try:
            self.logger.debug(f"Retrieving conditions for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "clinical-status": "active",
                "_sort": "-recorded-date"  # Sort by most recently recorded first
            }
            
            conditions = await self.search("Condition", search_params)
            
            if not conditions or 'entry' not in conditions:
                self.logger.debug(f"No conditions found for patient {patient_id}")
                return ["No current medical conditions found."]
                
            formatted_conditions = ["Current Medical Conditions:"]
            for entry in conditions['entry']:
                condition = entry['resource']
                try:
                    # Extract condition details
                    name = condition.get('code', {}).get('text') or \
                           (condition.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown condition')
                    
                    clinical_status_obj = condition.get('clinicalStatus', {})
                    clinical_status = clinical_status_obj.get('text') or \
                                      (clinical_status_obj.get('coding', [{}])[0].get('display') or 'Unknown status')
                    
                    verification_obj = condition.get('verificationStatus', {})
                    verification_status = verification_obj.get('text') or \
                                          (verification_obj.get('coding', [{}])[0].get('display') or 'Unknown verification')
                    
                    onset_date = condition.get('onsetDateTime') or condition.get('onsetPeriod', {}).get('start') or condition.get('onsetString', 'Unknown onset')
                    onset_date = onset_date.split('T')[0] if isinstance(onset_date, str) else 'Unknown onset'
                    
                    condition_line = f"- {name} (Status: {clinical_status}, Verification: {verification_status}, Onset: {onset_date})"
                    
                    # Add condition notes if available
                    notes = condition.get('note', [])
                    for note in notes:
                        note_text = note.get('text', '')
                        if note_text:
                            condition_line += f"\n  Note: {note_text}"
                    
                    formatted_conditions.append(condition_line)
                except Exception as e:
                    self.logger.error(f"Error formatting condition: {e}")
                    continue
            
            return formatted_conditions
                
        except Exception as e:
            self.logger.error(f"Error fetching conditions: {e}", exc_info=True)
            return ["Error retrieving medical conditions."]

    async def get_patient_medications(self, patient_id):
        """Retrieves active medications for the given patient and formats them."""
        try:
            self.logger.debug(f"Retrieving medications for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "status": "active"
            }
            
            medication_statements = await self.search("MedicationStatement", search_params)
            medication_requests = await self.search("MedicationRequest", search_params)
            
            medications = []
            
            # Process MedicationStatements
            if medication_statements and 'entry' in medication_statements:
                for entry in medication_statements['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text') or \
                           (med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or 'Unknown medication')
                    dosage = med.get('dosage', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")
            
            # Process MedicationRequests
            if medication_requests and 'entry' in medication_requests:
                for entry in medication_requests['entry']:
                    med = entry['resource']
                    name = med.get('medicationCodeableConcept', {}).get('text') or \
                           (med.get('medicationCodeableConcept', {}).get('coding', [{}])[0].get('display') or 'Unknown medication')
                    dosage = med.get('dosageInstruction', [{}])[0].get('text', 'No dosage information')
                    medications.append(f"- {name} ({dosage})")
            
            if medications:
                formatted_meds = ["Current Medications:"]
                formatted_meds.extend(medications)
                return formatted_meds
            
            self.logger.debug("No active medications found for patient.")
            return ["No active medications found."]
                
        except Exception as e:
            self.logger.error(f"Error fetching medications: {e}", exc_info=True)
            return ["Error retrieving medications."]

    async def get_patient_allergies(self, patient_id):
        """
        Retrieves allergy information for a patient from the FHIR server and formats it.
        
        :param patient_id: The patient's FHIR resource ID
        :return: List of formatted allergy strings or a message if none found
        """
        try:
            self.logger.debug(f"Retrieving allergies for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "clinical-status": "active"
            }
            
            allergy_result = await self.search("AllergyIntolerance", search_params)
            
            if allergy_result and 'entry' in allergy_result:
                allergies = []
                for entry in allergy_result['entry']:
                    allergy = entry['resource']
                    try:
                        # Extract allergy details
                        code = allergy.get('code', {}).get('text') or \
                               (allergy.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown substance')
                        
                        reactions = allergy.get('reaction', [])
                        reaction_details = []
                        for reaction in reactions:
                            manifestation = reaction.get('manifestation', [{}])[0].get('text') or \
                                            (reaction.get('manifestation', [{}])[0].get('coding', [{}])[0].get('display') or 'Unknown reaction')
                            severity = reaction.get('severity', 'unknown')
                            reaction_details.append(f"{manifestation} (Severity: {severity})")
                        
                        reaction_str = '; '.join(reaction_details) if reaction_details else 'No reaction details'
                        
                        allergy_line = f"- {code}: {reaction_str}"
                        
                        # Add allergy notes if available
                        notes = allergy.get('note', [])
                        for note in notes:
                            note_text = note.get('text', '')
                            if note_text:
                                allergy_line += f"\n  Note: {note_text}"
                        
                        allergies.append(allergy_line)
                    except Exception as e:
                        self.logger.error(f"Error formatting allergy: {e}")
                        continue
                
                formatted_allergies = ["Active Allergies:"]
                formatted_allergies.extend(allergies)
                return formatted_allergies
            
            self.logger.debug("No active allergies found for patient.")
            return ["No active allergies found."]
                
        except Exception as e:
            self.logger.error(f"Error retrieving patient allergies: {e}", exc_info=True)
            return ["Error retrieving allergies."]

    async def get_patient_procedures(self, patient_id):
        """Retrieves past procedures for the patient and formats them."""
        try:
            self.logger.debug(f"Retrieving procedures for patient ID: {patient_id}")
            
            search_params = {
                "patient": f"Patient/{patient_id}",
                "status": "completed",
                "_sort": "-recorded-date"  # Sort by most recently recorded first
            }
            
            procedures = await self.search("Procedure", search_params)
            
            if not procedures or 'entry' not in procedures:
                self.logger.debug("No procedures found for patient.")
                return ["No past procedures found."]
            
            formatted_procedures = ["Past Procedures:"]
            for entry in procedures['entry']:
                procedure = entry['resource']
                try:
                    # Extract procedure details
                    name = procedure.get('code', {}).get('text') or \
                           (procedure.get('code', {}).get('coding', [{}])[0].get('display') or 'Unknown procedure')
                    
                    date = procedure.get('performedDateTime') or procedure.get('performedPeriod', {}).get('start') or 'Unknown date'
                    date = date.split('T')[0] if isinstance(date, str) else 'Unknown date'
                    
                    status = procedure.get('status', 'unknown')
                    
                    procedure_line = f"- {name} on {date} (Status: {status})"
                    
                    # Add procedure notes if available
                    notes = procedure.get('note', [])
                    for note in notes:
                        note_text = note.get('text', '')
                        if note_text:
                            procedure_line += f"\n  Note: {note_text}"
                    
                    formatted_procedures.append(procedure_line)
                except Exception as e:
                    self.logger.error(f"Error formatting procedure: {e}")
                    continue
            
            return formatted_procedures
                
        except Exception as e:
            self.logger.error(f"Error fetching procedures: {e}", exc_info=True)
            return ["Error retrieving procedures."]
        
    async def read(self, resource_type, resource_id):
        """Async wrapper for FHIR read"""
        try:
            path = f"{resource_type}/{resource_id}"
            request_json_async = sync_to_async(
                self.fhir_client.request_json,
                thread_sensitive=False
            )
            result = await request_json_async(path)
            return result
        except Exception as e:
            self.logger.error(f"FHIR read error for {resource_type}/{resource_id}: {str(e)}")
            return None

    async def get_available_practitioners(self):
        """Get list of available practitioners"""
        self.logger.debug("Starting get_available_practitioners")
        try:
            self.logger.debug("Attempting to search for practitioners")
            practitioners = await self.search('Practitioner', {})
            self.logger.debug(f"Raw practitioners response: {practitioners}")
            
            if practitioners and 'entry' in practitioners:
                available_practitioners = []
                self.logger.debug(f"Found {len(practitioners['entry'])} practitioners")
                
                for entry in practitioners['entry']:
                    self.logger.debug(f"Processing practitioner entry: {entry}")
                    practitioner = entry['resource']
                    
                    # Log practitioner details
                    self.logger.debug(f"Practitioner ID: {practitioner.get('id')}")
                    self.logger.debug(f"Practitioner resource: {practitioner}")
                    
                    # Get practitioner role and specialty from extensions
                    role = None
                    specialty = None
                    for extension in practitioner.get('extension', []):
                        if extension['url'].endswith('practitioner-role'):
                            role = extension.get('valueString')
                        elif extension['url'].endswith('practitioner-specialty'):
                            specialty = extension.get('valueString')
                    
                    name = self.get_practitioner_name(practitioner)
                    available_practitioners.append({
                        'id': practitioner['id'],
                        'name': name,
                        'role': role or 'General Practitioner',
                        'specialty': specialty or 'General Practice'
                    })
                
                self.logger.debug(f"Final available practitioners: {available_practitioners}")
                return available_practitioners
            
            self.logger.debug("No practitioners found in response")
            return []
            
        except Exception as e:
            self.logger.error(f"Error in get_available_practitioners: {str(e)}")
            self.logger.error("Full error details:", exc_info=True)
            self.logger.error(f"FHIR client state: {self.fhir_client}")
            return []

    async def get_user_appointments_direct(self, patient_id, timezone='America/New_York'):
        """Alternative method to get user appointments directly"""
        return await self.get_user_appointments(patient_id, timezone)

    async def get_complete_medical_record(self, patient_id):
        """Fetches and formats the complete medical record for a patient."""
        try:
            self.logger.debug(f"Fetching complete medical record for patient ID: {patient_id}")
            
            # Personal Information
            patient = await self.read("Patient", patient_id)
            if not patient:
                self.logger.error("Patient record not found.")
                return None
            
            record = []
            record.append("BASIC INFORMATION:")
            name = self.get_patient_name(patient)
            record.append(f"Name: {name}")
            record.append(f"Gender: {patient.get('gender', 'Not specified')}")
            record.append(f"Birth Date: {patient.get('birthDate', 'Not specified')}")
            
            # Contact Information
            record.append("\nCONTACT INFORMATION:")
            for telecom in patient.get('telecom', []):
                system = telecom.get('system', '').title()
                value = telecom.get('value', '')
                record.append(f"{system}: {value}")
            
            # Address
            if patient.get('address'):
                address = patient['address'][0]
                address_str = ', '.join(filter(None, [
                    ', '.join(address.get('line', [])),
                    address.get('city', ''),
                    address.get('state', ''),
                    address.get('postalCode', ''),
                    address.get('country', '')
                ]))
                record.append(f"Address: {address_str}")
            
            # Health Metrics
            record.append("\nHEALTH METRICS:")
            for extension in patient.get('extension', []):
                if extension['url'].endswith('height'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Height: {value.get('value')} {value.get('unit')}")
                elif extension['url'].endswith('weight'):
                    value = extension.get('valueQuantity', {})
                    record.append(f"Weight: {value.get('value')} {value.get('unit')}")
            
            # Medical Conditions
            conditions = await self.get_patient_conditions(patient_id)
            record.extend(conditions)
            
            # Medications
            medications = await self.get_patient_medications(patient_id)
            record.extend(medications)
            
            # Past Procedures
            procedures = await self.get_patient_procedures(patient_id)
            record.extend(procedures)
            
            # Immunizations
            immunizations = await self.get_patient_immunizations(patient_id)
            if immunizations:
                record.append("\nIMMUNIZATIONS:")
                for imm in immunizations:
                    imm_line = f"- {imm['vaccineCode']['text']} on {imm['occurrenceDateTime']} (Status: {imm['status']})"
                    if imm.get('note'):
                        for note in imm['note']:
                            if note.get('text'):
                                imm_line += f"\n  Note: {note['text']}"
                    record.append(imm_line)
            else:
                record.append("\nIMMUNIZATIONS:")
                record.append("No immunization records found.")
            
            self.logger.debug("Complete medical record fetched successfully.")
            return "\n".join(record)
                
        except Exception as e:
            self.logger.error(f"Error fetching complete medical record: {e}", exc_info=True)
            return None

    async def get_user_appointments_formatted(self, patient_id, timezone='America/New_York'):
        """Fetches and formats user appointments for display."""
        try:
            appointments = await self.get_user_appointments(patient_id, timezone)
            if not appointments:
                return ["You don't have any upcoming appointments scheduled."]
            
            messages = ["Here are your upcoming appointments:"]
            for appt in appointments:
                messages.append(f"- {appt['datetime']} with {appt['practitioner']} ({appt['description']})")
            
            return messages
        except Exception as e:
            self.logger.error(f"Error formatting user appointments: {e}", exc_info=True)
            return ["Error retrieving appointments."]

    async def get_diagnostic_reports(self, search_params):
        """Get diagnostic reports (lab results) for a patient"""
        try:
            result = await self.search('DiagnosticReport', search_params)
            
            if result and 'entry' in result:
                return result['entry']
            return []
            
        except Exception as e:
            self.logger.error(f"Error getting diagnostic reports: {str(e)}")
            return []

    async def get_lab_results(self, patient_id):
        """Fetch lab results for a patient"""
        try:
            # Try multiple category codes that might represent lab results
            categories = ['laboratory', 'LAB', 'lab']
            results = None
            
            for category in categories:
                # Build the FHIR query for DiagnosticReport
                query = (
                    f"/DiagnosticReport?patient={patient_id}"
                    f"&category={category}"
                    "&_sort=-date"
                    "&_include=DiagnosticReport:result"
                    "&_include=DiagnosticReport:subject"
                )
                
                # Make the request
                response = await self._make_request('GET', query)
                logger.debug(f"FHIR response for category {category}: {response.status_code}")
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('total', 0) > 0:
                        results = data
                        break
            
            # If no results found through categories, try without category filter
            if not results:
                query = (
                    f"/DiagnosticReport?patient={patient_id}"
                    "&_sort=-date"
                    "&_include=DiagnosticReport:result"
                    "&_include=DiagnosticReport:subject"
                )
                response = await self._make_request('GET', query)
                if response.status_code == 200:
                    results = response.json()
            
            return results
                
        except Exception as e:
            logger.error(f"Error in get_lab_results: {str(e)}")
            return None

    async def get_lab_reference_ranges(self, test_code):
        """Get reference ranges for a specific lab test"""
        try:
            params = {
                'code': test_code,
                'category': 'laboratory'
            }
            return await self.search('ObservationDefinition', params)
        except Exception as e:
            self.logger.error(f"Error fetching reference ranges: {str(e)}")
            raise

print ("23")

================
File: Django_app/chatbot/views/services/intent_service.py
================
from collections.abc import Coroutine
import logging
import json
import re
from datetime import datetime
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional

from openai import AsyncOpenAI
from django.conf import settings
from asgiref.sync import sync_to_async

# FHIR and Language Imports
from fhirclient.client import FHIRClient
from chatbot.views.config import config  # Assuming this contains FHIR server settings
from chatbot.views.services.language_service import LanguageService

# Load your OpenAI model name from a constants file or environment
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
print ("23.5")
# Global fallback cache for GPT fallback responses (to reduce redundant API calls)
FALLBACK_CACHE = {}

# ============================================
#   FHIR Client Initialization (async)
# ============================================

def get_async_fhir_client():
    """
    Asynchronously get a configured FHIR client instance.
    Ensures that FHIR server methods are available as async functions.
    """
    settings_dict = {
        'app_id': 'anna_chatbot',
        'api_base': settings.FHIR_SERVER_URL
    }
    try:
        fhir_client = FHIRClient(settings=settings_dict)
        # Convert blocking methods to async versions
        fhir_client.server.request_json = sync_to_async(fhir_client.server.request_json, thread_sensitive=False)
        fhir_client.server.update = sync_to_async(fhir_client.server.update, thread_sensitive=False)
        fhir_client.server.create = sync_to_async(fhir_client.server.create, thread_sensitive=False)
        fhir_client.server.delete = sync_to_async(fhir_client.server.delete, thread_sensitive=False)
        fhir_client.server.perform_request = sync_to_async(fhir_client.server.perform_request, thread_sensitive=False)
        logger.info("Asynchronous FHIR client initialized successfully")
        return fhir_client
    except Exception as e:
        logger.error(f"Failed to initialize asynchronous FHIR client: {e}")
        raise

# ============================================
#   OpenAI Client Initialization
# ============================================

client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
language_service = LanguageService()

# ============================================
#   Intent Enumeration and Data Class
# ============================================

class Intent(Enum):
    SET_APPOINTMENT = 'set_appointment'
    SHOW_APPOINTMENTS = 'show_appointments'
    MEDICAL_RECORD_QUERY = 'medical_record_query'
    MEDICAL_INFO_QUERY = 'medical_info_query'
    SYMPTOM_REPORT = 'symptom_report'
    LAB_RESULTS_QUERY = 'lab_results_query'
    LAB_RESULTS = 'lab_results'
    CAPABILITIES = 'capabilities'
    EXPLANATION_QUERY = 'explanation_query'
    EMAIL_VERIFICATION = 'email_verification'
    RESET_CONTEXT = 'reset_context'
    DELETE_CONTEXT = 'delete_context'
    GREETING = 'greeting'
    CONDITION_QUERY = 'condition_query'
    MENTAL_HEALTH_QUERY = 'mental_health_query'
    SCREENING = 'screening'
    UNKNOWN = 'unknown'

@dataclass
class IntentData:
    """
    A structured container for intent detection results.
    """
    intent: Intent
    confidence: float
    entities: Dict[str, str]
    original_text: str = None
    context_type: str = None

# ============================================
#   Pre-compiled Regex Patterns
# ============================================

# --- Appointment Patterns ---
APPOINTMENT_KEYWORDS = (
    r"(?:book|schedule|make|arrange|reserve|organize|plan|fix|request|create|initiate|set(?:\s*up)?|secure|hold|slot|enroll|register|put\s+down)"
)
APPOINTMENT_PATTERNS_RAW = [
    fr"{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"(?:i|we|would like to|i'd like to|i need to|i want to)\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"need\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)",
    fr"want\s+to\s+{APPOINTMENT_KEYWORDS}\s+(?:an|a)?\s+(?:appointment|visit|check[-\s]*up)"
]
COMPILED_APPOINTMENT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_PATTERNS_RAW]

APPOINTMENT_VIEW_PATTERNS_RAW = [
    r'(?:show|view|see|check|list|get|display|pull\s+up|fetch|retrieve)\s+(?:my|all|any|upcoming)?\s+appointments?',
    r'what\s+(?:appointments?|bookings?)\s+do\s+i\s+have(?:\s+scheduled)?',
    r'(?:my|all|upcoming|scheduled)\s+appointments?'
]
COMPILED_APPOINTMENT_VIEW_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in APPOINTMENT_VIEW_PATTERNS_RAW]

# --- Symptom Patterns ---
SYMPTOM_PATTERNS_RAW = {
    'pain': [r'hurts?', r'aching?', r'pain(?:ful)?', r'sore', r'tender', r'burning',
             r'sharp\s+pain', r'dull\s+pain', r'throbbing', r'joint', r'joints',
             r'ankle', r'elbow', r'knee', r'leg\s+pain', r'foot\s+pain', r'back\s+ache'],
    'respiratory': [r'cough(?:ing)?', r'breathing', r'short\s+of\s+breath', r'wheez(?:e|ing)',
                    r'chest\s+tight(?:ness)?', r"can't\s+breathe", r'difficulty\s+breathing',
                    r'asthma', r'lung\s+pain'],
    'gastrointestinal': [r'stomach', r'nausea(?:ted)?', r'vomiting', r'diarrhea', r'constipation',
                         r'abdominal\s+pain', r'indigestion', r'cramps?', r'gastro'],
    'neurological': [r'headache', r'dizzy', r'migraine', r'faint(?:ing)?', r'numbness',
                     r'tingling', r'balance', r'vision', r'hearing', r'seizure', r'epilepsy'],
    'general': [r'fever(?:ish)?', r'tired(?:ness)?', r'fatigue', r'weak(?:ness)?', r'exhausted',
                r'not\s+feeling\s+well', r'unwell', r'sick', r'ill'],
    'musculoskeletal': [r'joint\s+pain', r'muscle\s+pain', r'stiffness', r'swelling',
                        r'limited\s+movement', r'difficulty\s+moving', r'arthritis',
                        r'sprain', r'strain', r'inflammation']
}
COMPILED_SYMPTOM_PATTERNS = {}
for category, patterns in SYMPTOM_PATTERNS_RAW.items():
    COMPILED_SYMPTOM_PATTERNS[category] = [re.compile(p, flags=re.IGNORECASE) for p in patterns]

# --- Medical Record Patterns ---
MEDICAL_RECORD_PATTERNS_RAW = [
    r'(?:show|view|see|access|get|pull\s+up|retrieve)\s+(?:my|all)?\s+(?:medical|health)?\s+records?',
    r'(?:my|full|complete)\s+(?:medical|health)?\s+records?',
    r'history',
    r'(?:my|the)\s+(?:chart|ehr|patient\s*portal|medical\s*file)'
]
COMPILED_MEDICAL_RECORD_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_RECORD_PATTERNS_RAW]

# --- Medical Info Patterns ---
MEDICAL_INFO_PATTERNS_RAW = [
    r'what\s+is', r'tell\s+me\s+about', r'explain', r'information\s+about',
    r'learn\s+about', r'understand', r'how\s+do\s+i\s+know\s+if', r'how\s+can\s+i\s+tell\s+if',
    r'what\s+are\s+the\s+signs\s+of', r'how\s+do\s+you\s+know\s+if', r'how\s+to\s+tell\s+if',
    r'can\s+you\s+provide\s+info', r'give\s+me\s+information', r'differences?\s+between'
]
COMPILED_MEDICAL_INFO_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MEDICAL_INFO_PATTERNS_RAW]

# --- Mental Health Patterns ---
MENTAL_HEALTH_PATTERNS_RAW = [
    r'depression', r'anxiety', r'(?:mental|emotional)\s+health', r'sad(?:ness)?',
    r'unhappy', r'stress(?:ed)?', r'mood', r'therap(?:y|ist)', r'psychological',
    r'crying', r'hopeless(?:ness)?', r'worthless(?:ness)?', r'panic', r'insomnia',
    r'burnout', r'trauma', r'ptsd', r'bipolar', r'schizophrenia', r'suicid(?:e|al)',
    r'self[-\s]*harm', r'counseling'
]
COMPILED_MENTAL_HEALTH_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in MENTAL_HEALTH_PATTERNS_RAW]

# --- Condition Patterns ---
CONDITION_PATTERNS_RAW = [
    r'(?:my|current|existing)\s+conditions?', r'medical\s+conditions?',
    r'what\s+(?:conditions?|illnesses?)\s+do\s+i\s+have', r'what\s+am\s+i\s+diagnosed\s+with',
    r'health\s+conditions?', r'ongoing\s+diagnoses?', r'active\s+conditions?'
]
COMPILED_CONDITION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CONDITION_PATTERNS_RAW]

# --- Screening Patterns ---
SCREENING_PATTERNS_RAW = [
    r'screenings?', r'health\s+check(?:-up|up)?', r'medical\s+(?:test|exam)',
    r'what\s+screenings\s+should\s+i\s+get', r'preventive\s+care',
    r'preventative\s+exams?', r'health\s+preventive\s+measures?'
]
COMPILED_SCREENING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in SCREENING_PATTERNS_RAW]

# --- Lab Result Patterns ---
LAB_RESULT_PATTERNS_RAW = [
    r".*\b(?:cholesterol|glucose|hdl|ldl|triglycerides|potassium|sodium|chloride|bicarbonate|bun|creatinine|calcium|protein|albumin|bilirubin|ast|alt|alkaline\s+phosphatase|ggt|tsh|t4|t3|cortisol|testosterone|estradiol|progesterone|psa|uric\s+acid|crp|esr|inr|pt|aptt|d-dimer|troponin|ck|ldh|amylase|lipase|magnesium|phosphorus|iron|ferritin|transferrin|vitamin\s?b12|folate|vitamin\s?d|platelets|hemoglobin|leukocytes).*(?:high|low|normal|level|range|result|test|value|number).*",
    r".*\bwhat.*\b(?:do|does|about|concerning).*\b(?:my|these|those)?.*\b(?:test|result|level|value|number).*",
    r".*\b(?:my|the|latest|recent|previous|past).*\b(?:test|result|level|value|number).*\b(?:high|low|normal|range).*",
    r".*\b(?:test|result|level|value|number).*(?:okay|ok|good|bad|normal|abnormal|concerning|worrying).*",
    r"(?:what|how|why|when|where|which)\s+(?:is|are|do|does|can|could|should|would)?\s+.*?\s+(?:about|concerning|regarding|related\s+to|pertaining\s+to|mean|levels?|values?|numbers?|results?|tests?|readings?|measurements?)\b",
    r".*\b(?:lab|test|result|level|value|number)\b.*(?:from|on|in|at|for|during)\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|\d{1,2}/\d{1,2}/\d{4}|\d{4}-\d{2}-\d{2})",
    r"(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+\d{1,2}(?:st|nd|rd|th)?(?:,?|\s+in)?\s*(?:\d{4}|\d{2})?",
    r"\d{4}-\d{2}-\d{2}",
    r"\d{1,2}/\d{1,2}/\d{2,4}",
]
COMPILED_LAB_RESULT_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in LAB_RESULT_PATTERNS_RAW]

ADDITIONAL_LAB_PATTERNS_RAW = [
    r".*(?:lab|labs?|test|tests?)\s+results?.*",
    r".*(?:blood|urine)\s+test.*",
    r".*my\s+(?:recent|latest|last)\s+results.*",
    r".*results?\s+for.*",
    r".*my\s+levels.*"
]
COMPILED_ADDITIONAL_LAB_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in ADDITIONAL_LAB_PATTERNS_RAW]

# --- Capability Patterns ---
CAPABILITY_PATTERNS_RAW = [
    r"(?:what\s+can\s+you\s+do|what\s+are\s+your\s+capabilities|what\s+do\s+you\s+do|help|how\s+can\s+you\s+help\s+me|what\s+are\s+you\s+able\s+to\s+do|show\s+me\s+what\s+you\s+can\s+do|list\s+capabilities|list\s+functions|what\s+features\s+do\s+you\s+have)"
]
COMPILED_CAPABILITY_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in CAPABILITY_PATTERNS_RAW]

# --- Explanation Patterns ---
EXPLANATION_PATTERNS_RAW = [
    r"(?:how\s+do\s+you\s+explain|can\s+you\s+explain|what\s+does\s+.*?\s+mean|explain\s+.*?\s+to\s+me|help\s+me\s+understand|what\s+is\s+the\s+meaning\s+of|could\s+you\s+clarify|what\s+are|how\s+do\s+.*?\s+work|explain\s+the\s+difference)"
]
COMPILED_EXPLANATION_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in EXPLANATION_PATTERNS_RAW]

# --- Greeting Patterns ---
GREETING_PATTERNS_RAW = [
    r'\b(?:hi|hello|hey|hii|heyy|yo|hiya|greetings?|wassup|what\'s\s*up|sup|good\s+(?:morning|afternoon|evening|day))\b'
]
COMPILED_GREETING_PATTERNS = [re.compile(p, flags=re.IGNORECASE) for p in GREETING_PATTERNS_RAW]

# ============================================
#   Helper Function to Extract Medical Topic
# ============================================
def extract_medical_topic(message: str) -> str:
    """
    Removes common prompt phrases so that the core topic is isolated.
    """
    patterns_to_remove = [
        'what is', 'tell me about', 'explain', 'information about',
        'learn about', 'understand', 'differences? between'
    ]
    cleaned_message = message
    for pattern in patterns_to_remove:
        cleaned_message = re.sub(pattern, '', cleaned_message, flags=re.IGNORECASE).strip()
    return cleaned_message

# ============================================
#   Main Intent Detection Function (Improved)
# ============================================
async def detect_intent(
    user_input: str,
    conversation_context: Optional[dict] = None,
    last_intent: Optional[str] = None
) -> Dict[str, any]:
    """
    Determines the user's intent using a layered approach:
      1. Special-case handling (digit input, email verification, context deletion/reset)
      2. Regex-based matching using precompiled patterns.
      3. Context-aware handling for short or anaphoric queries.
      4. A GPT fallback with few-shot examples and caching.
    """
    logger.info("=== STARTING INTENT DETECTION ===")
    logger.info(f"Input message: {user_input!r}")

    if not user_input or not isinstance(user_input, str):
        logger.error("Invalid user input: either None or not a string.")
        return {
            "intent": Intent.UNKNOWN.value,
            "confidence": 0.1,
            "entities": {},
            "original_text": str(user_input)
        }

    original_message = user_input.lower().strip()
    logger.debug(f"Processed message: {original_message!r}")

    # --- 1. Special Cases ---
    # 1a. Digit input during booking state
    if conversation_context and original_message.isdigit() and conversation_context.get('booking_state'):
        logger.info("Special case: Digit input during booking state detected.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 1.0,
            "entities": {"selection": original_message, "original_text": user_input, "context": "booking_flow"}
        }

    # 1b. Email Verification
    try:
        email_pattern = re.compile(r'[\w\.-]+@[\w\.-]+\.\w+', flags=re.IGNORECASE)
        if '@' in original_message:
            match_result = email_pattern.match(original_message)
            if match_result:
                matched_email = match_result.group(0)
                logger.info("Special case: Email verification match detected.")
                return {
                    "intent": Intent.EMAIL_VERIFICATION.value,
                    "confidence": 1.0,
                    "entities": {"email": matched_email, "original_text": user_input,
                                 "action": "verify", "context_type": "authentication"}
                }
    except Exception as e:
        logger.error(f"Error in email verification block: {e}")

    # 1c. Delete Context
    delete_commands = ["delete context", "clear context", "reset all", "delete contxt", "remove context", "erase context", "forget everything"]
    if any(cmd in original_message for cmd in delete_commands):
        logger.info("Special case: Delete context command recognized.")
        return {
            "intent": Intent.DELETE_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"action": "delete", "topic": "system", "original_text": user_input}
        }

    # 1d. Reset Context
    reset_patterns = [re.compile(p, flags=re.IGNORECASE) for p in [
        r"(?:i\s+)?(?:am\s+)?not\s+talking\s+about",
        r"(?:i\s+)?don'?t\s+mean",
        r"different\s+(?:topic|subject)",
        r"something\s+else",
        r"forget\s+the\s+previous\s+topic"
    ]]
    if any(pattern.search(original_message) for pattern in reset_patterns):
        excluded_topic_match = re.search(r"(?:about|mean)\s+(\w+)", original_message)
        excluded_topic = excluded_topic_match.group(1) if excluded_topic_match else None
        logger.info("Special case: Reset context command recognized.")
        return {
            "intent": Intent.RESET_CONTEXT.value,
            "confidence": 1.0,
            "entities": {"original_text": user_input, "excluded_topic": excluded_topic}
        }

    # --- 2. Regex-Based Detection ---
    # 2.1 Greeting
    if any(pattern.search(original_message) for pattern in COMPILED_GREETING_PATTERNS):
        logger.info("Regex detection: Greeting pattern matched.")
        return {
            "intent": Intent.GREETING.value,
            "confidence": 1.0,
            "entities": {},
            "original_text": user_input
        }

    # 2.2 Appointment Booking
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_PATTERNS):
        logger.info("Regex detection: Appointment booking pattern matched.")
        return {
            "intent": Intent.SET_APPOINTMENT.value,
            "confidence": 0.95,
            "entities": {"topic": original_message, "original_text": user_input}
        }

    # 2.3 Appointment Viewing
    if any(pattern.search(original_message) for pattern in COMPILED_APPOINTMENT_VIEW_PATTERNS):
        logger.info("Regex detection: Appointment viewing pattern matched.")
        return {
            "intent": Intent.SHOW_APPOINTMENTS.value,
            "confidence": 0.95,
            "entities": {"action": "view", "original_text": user_input}
        }

    # 2.4 Symptom Report
    for category, patterns in COMPILED_SYMPTOM_PATTERNS.items():
        if any(pattern.search(original_message) for pattern in patterns):
            logger.info(f"Regex detection: Symptom report pattern matched for category {category}.")
            return {
                "intent": Intent.SYMPTOM_REPORT.value,
                "confidence": 0.95,
                "entities": {"symptom_category": category, "symptom_description": original_message, "original_text": user_input}
            }

    # 2.5 Anaphora / Short Query Handling
    anaphora_patterns = {
        'it': re.compile(r'\b(it|this|that|these|those)\b', flags=re.IGNORECASE),
        'levels': re.compile(r'\b(levels|values|numbers|results)\b', flags=re.IGNORECASE),
        'change': re.compile(r'\b(increase|decrease|improve|change|modify)\b', flags=re.IGNORECASE)
    }
    if any(pattern.search(original_message) for pattern in anaphora_patterns.values()) and conversation_context and conversation_context.get('current_topic'):
        current_topic = conversation_context['current_topic']
        if current_topic.get('type') == 'lab_result':
            logger.info("Anaphora resolution: Lab result context detected in conversation context.")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "followup", "topic": current_topic.get('name'),
                             "original_text": user_input, "reference_range": current_topic.get('reference_range'),
                             "last_value": current_topic.get('last_value'), "context_type": "anaphora_resolution"}
            }

    # 2.6 Additional AI-based short query check for very short messages (<= 5 words)
    if len(original_message.split()) <= 5:
        context_prompt = f"\nPrevious topic: {conversation_context['current_topic'].get('name')}" if conversation_context and conversation_context.get('current_topic') else ""
        cache_key = f"short_query::{original_message}{context_prompt}"
        if cache_key in FALLBACK_CACHE:
            logger.info("Using cached GPT fallback for short query.")
            return FALLBACK_CACHE[cache_key]
        try:
            response = await client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": (
                        "You are analyzing if this short user message is a follow-up to a previous topic or "
                        "a standalone query. Return a JSON object:\n"
                        "{\n"
                        '  "is_followup": boolean,\n'
                        '  "confidence": float,\n'
                        '  "related_intent": "lab_results_query" or "show_appointments" or ...,\n'
                        '  "reasoning": "string"\n'
                        "}"
                    )},
                    {"role": "user", "content": f"Message: {user_input}{context_prompt}"}
                ],
                temperature=0.1
            )
            if isinstance(response, Coroutine):
                print("DEBUG: GPT response is a coroutine, forcing await.")
                response = await response
            analysis = json.loads(response.choices[0].message.content)
            if analysis.get('is_followup') is True and analysis.get('confidence', 0) > 0.7:
                related_intent = analysis.get('related_intent')
                if related_intent == 'lab_results_query':
                    result = {
                        "intent": Intent.LAB_RESULTS_QUERY.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "followup", "topic": conversation_context.get('current_topic', {}).get('name', 'unknown'),
                                     "original_text": user_input, "context_type": "semantic_analysis"}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
                elif related_intent == 'show_appointments':
                    result = {
                        "intent": Intent.SHOW_APPOINTMENTS.value,
                        "confidence": analysis['confidence'],
                        "entities": {"action": "view", "original_text": user_input}
                    }
                    FALLBACK_CACHE[cache_key] = result
                    return result
        except Exception as e:
            logger.error(f"Error in AI-enhanced short query analysis: {e}")

    # 2.7 Lab Result Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_LAB_RESULT_PATTERNS):
        logger.info("Regex detection: Lab result pattern matched.")
        return {
            "intent": Intent.LAB_RESULTS_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": original_message, "original_text": user_input}
        }
    if any(pattern.search(original_message) for pattern in COMPILED_ADDITIONAL_LAB_PATTERNS):
        if re.search(r"(?:show|get|view|see)\s+.*results.*", original_message):
            logger.info("Regex detection: Additional lab pattern matched for viewing results.")
            return {
                "intent": Intent.LAB_RESULTS.value,
                "confidence": 0.9,
                "entities": {"action": "view", "original_text": user_input}
            }
        else:
            logger.info("Regex detection: Additional lab pattern matched for querying results.")
            return {
                "intent": Intent.LAB_RESULTS_QUERY.value,
                "confidence": 0.9,
                "entities": {"action": "query", "topic": original_message, "original_text": user_input}
            }

    # 2.8 Screening Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_SCREENING_PATTERNS):
        logger.info("Regex detection: Screening pattern matched.")
        return {
            "intent": Intent.SCREENING.value,
            "confidence": 0.9,
            "entities": {"action": "recommend", "original_text": user_input}
        }

    # 2.9 Medical Record Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_RECORD_PATTERNS):
        logger.info("Regex detection: Medical record pattern matched.")
        return {
            "intent": Intent.MEDICAL_RECORD_QUERY.value,
            "confidence": 0.9,
            "entities": {"record_type": "full", "original_text": user_input}
        }

    # 2.10 Medical Info Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MEDICAL_INFO_PATTERNS):
        topic_cleaned = extract_medical_topic(original_message)
        logger.info("Regex detection: Medical info pattern matched.")
        return {
            "intent": Intent.MEDICAL_INFO_QUERY.value,
            "confidence": 0.85,
            "entities": {"topic": topic_cleaned, "original_text": user_input}
        }

    # 2.11 Mental Health Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_MENTAL_HEALTH_PATTERNS):
        logger.info("Regex detection: Mental health pattern matched.")
        return {
            "intent": Intent.MENTAL_HEALTH_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "mental_health", "original_text": user_input}
        }

    # 2.12 Condition Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CONDITION_PATTERNS):
        logger.info("Regex detection: Condition pattern matched.")
        return {
            "intent": Intent.CONDITION_QUERY.value,
            "confidence": 0.9,
            "entities": {"topic": "conditions", "original_text": user_input}
        }

    # 2.13 Capability Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_CAPABILITY_PATTERNS):
        logger.info("Regex detection: Capability pattern matched.")
        return {
            "intent": Intent.CAPABILITIES.value,
            "confidence": 1.0,
            "entities": {"topic": "capabilities", "original_text": user_input}
        }

    # 2.14 Explanation Patterns
    if any(pattern.search(original_message) for pattern in COMPILED_EXPLANATION_PATTERNS):
        logger.info("Regex detection: Explanation pattern matched.")
        return {
            "intent": Intent.EXPLANATION_QUERY.value,
            "confidence": 1.0,
            "entities": {"topic": user_input, "original_text": user_input}
        }

    # --- 3. GPT Fallback ---
    fallback_prompt = """
You are a powerful medical chatbot assistant. Classify the user's intent from this list:
- set_appointment
- show_appointments
- medical_record_query
- medical_info_query
- symptom_report
- lab_results
- lab_results_query
- capabilities
- explanation_query
- email_verification
- reset_context
- delete_context
- greeting
- condition_query
- mental_health_query
- screening
- unknown

Return strict JSON:
{
  "intent": "<one of the above>",
  "confidence": 0.95,
  "entities": { ... }
}
"""
    context_info = conversation_context if conversation_context else {}
    gpt_messages = [
        {"role": "system", "content": fallback_prompt},
        {"role": "user", "content": f"Utterance: {user_input}\nContext: {json.dumps(context_info)}\nLast Intent: {last_intent}"},

        # Few-shot examples:
        {"role": "assistant", "content": '{"intent": "set_appointment", "confidence": 0.95, "entities": {}}'},
        {"role": "user", "content": "i want to set an appointment"},
        {"role": "assistant", "content": '{"intent": "set_appointment", "confidence": 0.95, "entities": {}}'},

        {"role": "assistant", "content": '{"intent": "set_appointment", "confidence": 0.95, "entities": {}}'},
        {"role": "user", "content": "I need to schedule a check-up"},
        {"role": "assistant", "content": '{"intent": "set_appointment", "confidence": 0.95, "entities": {}}'},

        {"role": "user", "content": "What are my upcoming appointments?"},
        {"role": "assistant", "content": '{"intent": "show_appointments", "confidence": 0.9, "entities": {}}'},

        {"role": "user", "content": "What was my potassium level on my last lab test?"},
        {"role": "assistant", "content": '{"intent": "lab_results_query", "confidence": 0.85, "entities": {"test_name": "potassium"}}'},

        {"role": "user", "content": "Can you show me my allergies?"},
        {"role": "assistant", "content": '{"intent": "medical_record_query", "confidence": 0.9, "entities": {"record_type": "allergies"}}'},

        {"role": "user", "content": "hello"},
        {"role": "assistant", "content": '{"intent": "greeting", "confidence": 1.0, "entities": {}}'},

        {"role": "user", "content": "I feel depressed and can't sleep"},
        {"role": "assistant", "content": '{"intent": "mental_health_query", "confidence": 0.9, "entities": {"topic": "mental_health"}}'},

        {"role": "user", "content": "I want to see my lab results from last month"},
        {"role": "assistant", "content": '{"intent": "lab_results_query", "confidence": 0.9, "entities": {"action": "query"}}'},

        {"role": "user", "content": "Let's delete context now"},
        {"role": "assistant", "content": '{"intent": "delete_context", "confidence": 1.0, "entities": {"action": "delete"}}'},

        {"role": "user", "content": "I have a headache and a fever"},
        {"role": "assistant", "content": '{"intent": "symptom_report", "confidence": 0.95, "entities": {"symptom_category": "general"}}'},

        {"role": "user", "content": "What screenings should I get?"},
        {"role": "assistant", "content": '{"intent": "screening", "confidence": 0.9, "entities": {"action": "recommend"}}'}
    ]
    cache_key = f"gpt_fallback::{original_message}::{json.dumps(context_info)}::{last_intent}"
    if cache_key in FALLBACK_CACHE:
        logger.info("Using cached GPT fallback response.")
        return FALLBACK_CACHE[cache_key]

    try:
        response = await client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=gpt_messages,
            temperature=0.2,
            max_tokens=150
        )
        if isinstance(response, Coroutine):
            print("DEBUG: GPT response is a coroutine, forcing await.")
            response = await response
        if not response or not response.choices:
            logger.error("Empty response from OpenAI fallback.")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        response_content = response.choices[0].message.content
        logger.debug(f"GPT Fallback raw response: {response_content}")
        try:
            intent_data = json.loads(response_content)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse GPT fallback response as JSON: {e}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        if not isinstance(intent_data, dict) or not all(k in intent_data for k in ["intent", "confidence"]):
            logger.error(f"GPT fallback response is invalid: {intent_data}")
            return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}
        try:
            recognized_intent = Intent(intent_data["intent"]).value
        except (ValueError, KeyError):
            logger.warning(f"Invalid intent in GPT fallback response: {intent_data.get('intent')}")
            recognized_intent = Intent.UNKNOWN.value
        result = {
            "intent": recognized_intent,
            "confidence": float(intent_data.get("confidence", 0.1)),
            "entities": intent_data.get("entities", {}),
            "original_text": user_input
        }
        FALLBACK_CACHE[cache_key] = result
        return result
    except Exception as e:
        logger.error(f"Unexpected error in GPT fallback: {e}", exc_info=True)
        return {"intent": Intent.UNKNOWN.value, "confidence": 0.1, "entities": {}, "original_text": user_input}

# ============================================
#   Symptom & Condition Analysis (async)
# ============================================
async def analyze_symptom_and_conditions_with_ai(
    patient_id: str,
    user_message: str,
    conversation_history: Optional[list] = None,
    current_topic: Optional[dict] = None
) -> str:
    """
    Analyze symptoms and conditions with advanced AI using FHIR data.
    Detects language, retrieves the patient resource, and returns a triage response.
    """
    try:
        fhir_client =  get_async_fhir_client()
        detected_lang = await language_service.detect_language(user_message)
        emergency_text = language_service.get_localized_message('emergency_text', detected_lang)
        disclaimer = language_service.get_localized_message('disclaimer', detected_lang)
        patient = await fhir_client.server.perform_request('GET', f"Patient/{patient_id}")

        SEVERITY_LEVELS = {
            'EMERGENCY': {
                'prefix': ' EMERGENCY MEDICAL ATTENTION NEEDED',
                'action': 'Please call emergency services (e.g. 112) immediately or go to the nearest ER.',
                'followup': 'Do not delay seeking help.'
            },
            'URGENT': {
                'prefix': ' URGENT MEDICAL ATTENTION ADVISED',
                'action': 'Please seek urgent medical care or contact your healthcare provider right away.',
                'followup': 'If symptoms worsen, call emergency services.'
            },
            'MODERATE': {
                'prefix': ' MEDICAL ATTENTION RECOMMENDED',
                'action': 'Schedule an appointment with your provider soon.',
                'followup': 'Monitor symptoms and seek urgent care if they worsen.'
            },
            'LOW': {
                'prefix': ' GENERAL HEALTH ADVICE',
                'action': 'Monitor your symptoms and practice self-care at home.',
                'followup': 'Schedule a routine appointment if symptoms persist.'
            }
        }

        response = await client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": (
                    "You are a medical triage assistant focusing on patient safety. Always err on the side of caution. "
                    "Return structured JSON with severity and recommended steps."
                )},
                {"role": "user", "content": f"""
Analyze this health concern with severity:

Patient Message: {user_message}

Return JSON with:
{{
    "severity_level": "EMERGENCY|URGENT|MODERATE|LOW",
    "primary_symptoms": [list of main symptoms],
    "related_conditions": [possible related conditions],
    "immediate_actions": [actions to take],
    "reasoning": "brief explanation",
    "requires_emergency": boolean,
    "followup_recommendation": "specific followup advice"
}}
"""}
            ],
            temperature=0.3,
            max_tokens=500
        )
        analysis = json.loads(response.choices[0].message.content)
        severity = analysis.get('severity_level', 'MODERATE')
        severity_info = SEVERITY_LEVELS.get(severity, SEVERITY_LEVELS['MODERATE'])
        primary_symptoms = analysis.get('primary_symptoms', [])
        symptom_list = ", ".join(primary_symptoms) if primary_symptoms else "None"
        response_text = [
            f"{severity_info['prefix']}",
            "",
            f"Symptoms identified: {symptom_list}",
            "",
            f"RECOMMENDATION: {severity_info['action']}",
            "",
            f"Important: {severity_info['followup']}"
        ]
        if analysis.get('requires_emergency', False):
            response_text.append("\n EMERGENCY NUMBERS:")
            response_text.append("General Emergency: 112 (Europe), 911 (US), or local equivalent.")
            response_text.append("If in doubt, call emergency services immediately.")
        if disclaimer:
            response_text.append(f"\n{disclaimer}")
        else:
            response_text.append("\nPlease note this does not replace professional medical advice.")
        return "\n".join(response_text)
    except Exception as e:
        logger.error(f"Error in symptom analysis: {str(e)}", exc_info=True)
        return (
            "For your safety, please seek medical attention or contact emergency services "
            "if you're concerned about any symptoms."
        )
print ("24")

================
File: Django_app/chatbot/views/services/language_service.py
================
# chatbot/views/services/language_service.py
import logging
import json
from langdetect import detect, DetectorFactory
from django.conf import settings
from openai import AsyncOpenAI  # Changed to AsyncOpenAI
import re
from ..utils.constants import OPENAI_MODEL
print ("25")
logger = logging.getLogger('chatbot')

class LanguageService:
    def __init__(self):
        DetectorFactory.seed = 0
        self.supported_languages = {
            'en': {'name': 'English', 'code': 'en'},
            'es': {'name': 'Spanish', 'code': 'es'}
        }
        self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)  # Changed to AsyncOpenAI
    
    async def detect_language(self, text):
        """Detect the language of the input text"""
        try:
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a language detector. Return JSON with language and translation if not English."},
                    {"role": "user", "content": f"Analyze: {text}\nReturn: " + '{"language": "en|es", "translated": "English translation if not English"}'}
                ]
            )
            try:
                result = json.loads(response.choices[0].message.content)
                return result.get('language', 'en').split('|')[0]
            except json.JSONDecodeError:
                logger.error("Failed to parse language detection response")
                return 'en'
        except Exception as e:
            logger.error(f"Error detecting language: {str(e)}")
            return 'en'
    
    def get_localized_message(self, message_key, lang_code='en'):
        """Get localized version of a message"""
        messages = {
            'emergency_text': {
                'en': ' EMERGENCY: Seek immediate medical attention',
                'es': ' EMERGENCIA: Busque atencin mdica inmediata'
            },
            'disclaimer': {
                'en': 'This is an automated assessment. Always consult a healthcare professional.',
                'es': 'Esta es una evaluacin automatizada. Siempre consulte a un profesional de la salud.'
            }
        }
        return messages.get(message_key, {}).get(lang_code, messages[message_key]['en'])
    
    async def translate_text(self, text, target_lang='en'):
        """Translate text using OpenAI"""
        if not text or target_lang == 'en':
            return text

        try:
            response = await self.openai_client.chat.completions.create(  # Added await
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": f"You are a translator. Translate the following text to {self.supported_languages[target_lang]['name']}, maintaining the same tone and meaning:"},
                    {"role": "user", "content": text}
                ],
                temperature=0.3
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"Translation error: {str(e)}")
            return text

class LanguageHandler:
    def __init__(self):
        self.language_service = LanguageService()
    
    async def process_multilingual(self, text):
        try:
            detected_lang = await self.language_service.detect_language(text)
            needs_translation = detected_lang != 'en'
            
            if needs_translation:
                english_text = await self.language_service.translate_text(text, 'en')
            else:
                english_text = text
                
            return english_text, needs_translation
        except Exception as e:
            logger.error(f"Error in process_multilingual: {str(e)}")
            return text, False
            
    async def translate_response(self, response, needs_translation, target_lang):
        """Translate the response if needed"""
        try:
            if not needs_translation or target_lang == 'en':
                return response

            if isinstance(response, str):
                return await self.language_service.translate_text(response, target_lang)
                
            if isinstance(response, dict) and 'messages' in response:
                translated_messages = []
                for message in response['messages']:
                    try:
                        translated_text = await self.language_service.translate_text(
                            message, 
                            target_lang
                        )
                        translated_messages.append(translated_text)
                    except Exception as e:
                        logger.error(f"Error translating message: {str(e)}")
                        translated_messages.append(message)
                    
                response['messages'] = translated_messages
                
            return response
            
        except Exception as e:
            logger.error(f"Error in translate_response: {str(e)}")
            return response
    async def translate_to_english(self, text):
      """Translate text to English"""
      if not text:
          return text

      try:
          _, needs_translation = await self.process_multilingual(text)
          if needs_translation:
              return await self.language_service.translate_text(text, 'en')
          return text
      except Exception as e:
          logger.error(f"Error translating to English: {str(e)}")
          return text
            
print ("26")

================
File: Django_app/chatbot/views/services/medication_service.py
================
#!/usr/bin/env python
"""
medication_adherence_reminder_service.py

A production-ready implementation for the Medication Adherence and Refill Reminder Service for Anna.
This module:
  - Retrieves active MedicationRequest resources from a FHIR server.
  - Parses complex dosage instructions (ignoring PRN instructions) to calculate the next due dose time.
  - Checks for refill needs by examining the latest MedicationDispense's daysSupply.
  - Sends SMS reminders via an integrated notification service.
  - Checks for patient confirmations via a persistent store (stubbed here).
  - Respects patient opt-out preferences.
  
IMPORTANT:
  - Replace FHIR endpoint settings and codes with your production values.
  - Integrate send_sms() with your actual SMS provider (e.g., Twilio).
  - Implement has_confirmed_intake() with real confirmation tracking.
  - In production, run this service on a scheduled basis (via Celery, cron, etc.) to avoid duplicate reminders.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.medicationrequest as fhir_medreq
import fhirclient.models.medicationdispense as fhir_meddisp
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("MedicationAdherenceReminders")
logger.setLevel(logging.INFO)
print ("27")
# ----------------------------------------------------------------------
# Production FHIR client and SMS integration
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient instance.
    Replace the api_base and add OAuth credentials if needed.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your FHIR endpoint
        # Add additional OAuth settings if required.
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS using your SMS provider.
    Replace this stub with your actual SMS provider integration.
    """
    try:
        # Example using Twilio (replace with real implementation):
        # from twilio.rest import Client as TwilioClient
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(body=message, from_=settings.TWILIO_PHONE_NUMBER, to=to_number)
        logger.info(f"Sending SMS to {to_number}: {message}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS: {e}")
        return False

# Stub for confirmation tracking.
# In production, replace this with a database query or message queue check.
def has_confirmed_intake(patient_id, med_req_id, dose_due_time):
    """
    Check if the patient has confirmed taking their dose.
    This function should query a persistent store keyed by (patient_id, med_req_id, dose_due_time).
    For demonstration, returns False.
    """
    # TODO: Integrate with your confirmation tracking database.
    return False

# ----------------------------------------------------------------------
# Medication Adherence and Refill Reminder Service
# ----------------------------------------------------------------------
class MedicationAdherenceReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        self.refill_threshold_days = 3  # Send refill reminder if <= 3 days remain
    


    def get_due_reminders(self, current_time):
        """
        Returns a list of due medication reminders for the current time.
        Each reminder is a dictionary with patient_id, medication_name, phone_number.
        """
        due_reminders = []
        med_requests = self._get_all_active_medication_requests()

        for med_req in med_requests:
            patient_id = self._extract_patient_id(med_req)
            if not patient_id:
                continue

            phone_number = self._get_patient_phone_number(patient_id)
            if not phone_number:
                logger.warning(f"No phone number for patient {patient_id}; skipping reminder.")
                continue

            medication_name = self._get_medication_name(med_req) or "your medication"

            # Determine next due dose time
            next_due_time = self._get_next_due_dose_time(med_req)

            if next_due_time and current_time >= next_due_time:
                due_reminders.append({
                    "patient_id": patient_id,
                    "medication_name": medication_name,
                    "phone_number": phone_number,
                    "due_time": next_due_time.isoformat()
                })

        return due_reminders

    def process_medication_reminders(self):
        """
        Main function: retrieves due reminders and sends SMS messages.
        """
        current_time = datetime.now()
        due_reminders = self.get_due_reminders(current_time)

        for reminder in due_reminders:
            self.send_reminder(reminder)

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for the given medication.
        """
        message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
        success = self.notification_service(reminder["phone_number"], message)

        if success:
            logger.info(f"Reminder sent to patient {reminder['patient_id']} for {reminder['medication_name']}")
        else:
            logger.error(f"Failed to send reminder to patient {reminder['patient_id']}")


    # ------------------------------------------------------------------
    # FHIR Data Retrieval Methods
    # ------------------------------------------------------------------
    def _get_all_active_medication_requests(self):
        med_reqs = []
        try:
            search = fhir_medreq.MedicationRequest.where({'status': 'active'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for req in bundle:
                    if isinstance(req, fhir_medreq.MedicationRequest):
                        med_reqs.append(req)
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving active MedicationRequests: {e}")
        return med_reqs

    def _extract_patient_id(self, med_req):
        if not med_req.subject or not med_req.subject.reference:
            return None
        return med_req.subject.reference.split('/')[-1]

    def _get_patient_phone_number(self, patient_id):
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient and patient.telecom:
                for telecom in patient.telecom:
                    if telecom.system == 'phone' and telecom.value:
                        return telecom.value
        except Exception as e:
            logger.error(f"Error retrieving phone number for patient {patient_id}: {e}")
        return None

    def _get_patient_preferred_language(self, patient_id):
        """
        Retrieves the preferred language from the Patient resource.
        For demonstration, returns 'en'.
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.communication and len(patient.communication) > 0:
                comm = patient.communication[0]
                if hasattr(comm, 'language') and comm.language and comm.language.text:
                    return comm.language.text.lower()
        except Exception as e:
            logger.error(f"Error retrieving preferred language for patient {patient_id}: {e}")
        return 'en'

    def _get_medication_name(self, med_req):
        if med_req.medicationCodeableConcept:
            if med_req.medicationCodeableConcept.text:
                return med_req.medicationCodeableConcept.text
            if med_req.medicationCodeableConcept.coding:
                return med_req.medicationCodeableConcept.coding[0].display
        return None

    def _patient_has_opted_out(self, patient_id):
        """
        Checks the Patient resource for an opt-out flag.
        Assumes an extension at "http://example.org/fhir/StructureDefinition/optOut".
        """
        try:
            patient = fhir_patient.Patient.read(patient_id, self.fhir_client.server)
            if patient.extension:
                for ext in patient.extension:
                    if ext.url == "http://example.org/fhir/StructureDefinition/optOut" and getattr(ext, 'valueBoolean', False):
                        return True
        except Exception as e:
            logger.error(f"Error checking opt-out for patient {patient_id}: {e}")
        return False

    # ------------------------------------------------------------------
    # Dosage Instruction Parsing & Dose Reminder Logic
    # ------------------------------------------------------------------
    def _get_next_due_dose_time(self, med_req):
        """
        Iterates over all dosageInstruction entries (ignoring those marked as "as needed")
        and computes the next due dose time based on dosing frequency.
        Returns the earliest next due datetime among the instructions, or None.
        """
        next_due_times = []
        now = datetime.now()

        if not med_req.dosageInstruction:
            return None

        for dose_inst in med_req.dosageInstruction:
            # Skip PRN instructions (if asNeeded is True or specified via asNeededCodeableConcept)
            if hasattr(dose_inst, 'asNeededBoolean') and dose_inst.asNeededBoolean:
                continue
            if hasattr(dose_inst, 'asNeededCodeableConcept') and dose_inst.asNeededCodeableConcept:
                continue

            frequency, period_hours = self._extract_frequency_and_period(dose_inst)
            if frequency is None or period_hours is None:
                continue

            # Compute the dose interval (in hours)
            interval_hours = period_hours / frequency

            # Retrieve the last dose time from MedicationDispense
            last_dispense = self._get_last_dispense_date(med_req)
            if last_dispense:
                next_due = last_dispense + timedelta(hours=interval_hours)
            else:
                # If no dispense record, assume the dose is due immediately
                next_due = now

            next_due_times.append(next_due)

        if next_due_times:
            return min(next_due_times)
        return None

    def _extract_frequency_and_period(self, dose_inst):
        """
        Extracts frequency and period (in hours) from dose_inst.timing.repeat.
        Returns (frequency, period_hours) or (None, None) if extraction fails.
        """
        try:
            repeat = dose_inst.timing.repeat
            frequency = getattr(repeat, 'frequency', None)
            period = getattr(repeat, 'period', None)
            period_unit = getattr(repeat, 'periodUnit', None)
            if not (frequency and period and period_unit):
                return (None, None)
            hours_map = {
                's': 1/3600,
                'min': 1/60,
                'h': 1,
                'd': 24,
                'wk': 24*7,
                'mo': 24*30,
                'a': 24*365,
            }
            if period_unit not in hours_map:
                return (None, None)
            period_hours = period * hours_map[period_unit]
            return (frequency, period_hours)
        except Exception as e:
            logger.error(f"Error extracting frequency/period: {e}")
            return (None, None)

    def _get_last_dispense_date(self, med_req):
        """
        Retrieves the most recent dispense datetime from MedicationDispense resources
        referencing this MedicationRequest.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        last_date = None
        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    if disp_dt and (not last_date or disp_dt > last_date):
                        last_date = disp_dt
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving MedicationDispense for MedicationRequest/{med_req_id}: {e}")
        return last_date

    def _extract_dispense_datetime(self, disp):
        """
        Extracts a datetime from MedicationDispense.whenHandedOver or whenPrepared.
        """
        for attr in ['whenHandedOver', 'whenPrepared']:
            dt_str = getattr(disp, attr, None)
            if dt_str:
                dt = self._parse_date_str(dt_str)
                if dt:
                    return dt
        return None

    def _parse_date_str(self, date_str):
        """
        Parses an ISO8601 date string into a datetime object.
        """
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except Exception as e:
            logger.warning(f"Error parsing date string '{date_str}': {e}")
            return None

    # ------------------------------------------------------------------
    # Refill Reminder Logic
    # ------------------------------------------------------------------
    def _is_refill_due(self, med_req, now):
        """
        Determines if a refill reminder should be sent based on the latest MedicationDispense's
        daysSupply and the elapsed days since that dispense.
        """
        dispense_info = self._get_latest_dispense_info(med_req)
        if not dispense_info:
            return False

        dispense_date = dispense_info.get('dispense_date')
        days_supply = dispense_info.get('days_supply')
        if not dispense_date or days_supply is None:
            return False

        elapsed_days = (now.date() - dispense_date.date()).days
        remaining_days = days_supply - elapsed_days
        return remaining_days <= self.refill_threshold_days

    def _get_latest_dispense_info(self, med_req):
        """
        Retrieves the most recent MedicationDispense info for this MedicationRequest,
        returning a dict with keys 'dispense_date' and 'days_supply'.
        Note: For complex scenarios (partial refills, overlapping prescriptions), you may need to
        sum or aggregate multiple dispenses.
        """
        med_req_id = getattr(med_req, 'id', None)
        if not med_req_id:
            return None

        latest_date = None
        latest_supply = None

        try:
            search = fhir_meddisp.MedicationDispense.where({
                'prescription': f'MedicationRequest/{med_req_id}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for disp in bundle:
                    if not isinstance(disp, fhir_meddisp.MedicationDispense):
                        continue
                    disp_dt = self._extract_dispense_datetime(disp)
                    supply = self._extract_days_supply(disp)
                    if disp_dt and supply is not None and (not latest_date or disp_dt > latest_date):
                        latest_date = disp_dt
                        latest_supply = supply
                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving dispense info for MedicationRequest/{med_req_id}: {e}")
            return None

        if latest_date:
            return {'dispense_date': latest_date, 'days_supply': latest_supply}
        return None

    def _extract_days_supply(self, disp):
        """
        Extracts the daysSupply value from a MedicationDispense.
        """
        if hasattr(disp, 'daysSupply') and disp.daysSupply and disp.daysSupply.value is not None:
            try:
                return float(disp.daysSupply.value)
            except Exception as e:
                logger.error(f"Error extracting daysSupply: {e}")
        return None

    # ------------------------------------------------------------------
    # End of Service Class
    # ------------------------------------------------------------------

# ----------------------------------------------------------------------
# Script Entry Point (for scheduled execution)
# ----------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        reminder_service = MedicationAdherenceReminderService(fhir_client, send_sms)
        reminder_service.process_medication_reminders()
    except Exception as e:
        logger.error(f"Critical error processing medication reminders: {e}")
print ("28")

================
File: Django_app/chatbot/views/services/personalized_medical_advice_service.py
================
#!/usr/bin/env python
"""
personalized_medical_advice_service.py

A production-ready, asynchronous module for generating personalized medical advice.
This service combines:
  - Patient-specific data from your FHIR server (via FHIRService from your codebase)
  - Recent conversation context (via your session/conversation manager)
  - Evidence-based guidelines from MedlinePlus Connect (queried via HTTP)
into a comprehensive prompt for GPT-4. The final advice always includes a prominent disclaimer.

Before deploying:
  - Ensure that your FHIR server (settings.FHIR_SERVER_URL) and credentials (from .env) are correct.
  - Verify that the MedlinePlus Connect query parameters match your requirements.
  - Confirm that your conversation manager functions are correctly integrated.
"""

import logging
import asyncio
from datetime import datetime
from typing import List, Dict
import requests
import xml.etree.ElementTree as ET
import openai

from django.conf import settings
from chatbot.views.services.fhir_service import FHIRService

# Configure logging
logger = logging.getLogger("PersonalizedMedicalAdvice")
logger.setLevel(logging.INFO)

# ------------------------------------------------------------------------------
# Evidence-Based Guidelines via MedlinePlus Connect
# ------------------------------------------------------------------------------
print ("29")
# Mapping from condition names to MedlinePlus Connect codes.
CONDITION_CODE_MAPPING = {
    "diabetes": "44054006",      # Example SNOMED code for Type 2 diabetes
    "hypertension": "38341003",  # Example SNOMED code for hypertension
    # Expand as needed
}

def get_medlineplus_guidelines(condition: str) -> str:
    """
    Query MedlinePlus Connect for guideline text for the given condition.
    Returns guideline text or None.
    """
    code = CONDITION_CODE_MAPPING.get(condition.lower())
    if not code:
        logger.warning(f"No mapping found for condition: {condition}")
        return None

    base_url = "https://connect.medlineplus.gov/service"
    params = {
        "mainSearchCriteria.v.c": code,
        "informationRecipient.language": "en"
    }
    try:
        response = requests.get(base_url, params=params, timeout=10)
        if response.status_code == 200:
            root = ET.fromstring(response.text)
            guideline_text = None
            for desc in root.iter('description'):
                if desc.text:
                    guideline_text = desc.text.strip()
                    break
            if guideline_text:
                logger.info(f"Retrieved guideline for {condition}")
                return guideline_text
            else:
                logger.warning(f"No description found for {condition}")
                return None
        else:
            logger.error(f"MedlinePlus error {response.status_code} for condition {condition}")
            return None
    except Exception as e:
        logger.error(f"Error querying MedlinePlus for {condition}: {e}")
        return None

def get_evidence_based_guidelines(conditions: List[str]) -> Dict[str, str]:
    """
    For each condition in the list, query MedlinePlus Connect and return a mapping.
    """
    guidelines = {}
    for cond in conditions:
        text = get_medlineplus_guidelines(cond)
        if text:
            guidelines[cond] = text
    return guidelines

# ------------------------------------------------------------------------------
# Asynchronous Summarization of Conversation Context
# ------------------------------------------------------------------------------
def redact_sensitive_info(text: str) -> str:
    """
    Stub for redacting sensitive information. Replace with real redaction as needed.
    """
    return text

async def summarize_messages(messages: List[str], openai_client: "AsyncGPT4Client") -> str:
    """
    Uses GPT-4-turbo to generate a concise bullet-point summary of conversation context.
    Redacts sensitive data before summarization.
    """
    if not messages:
        return ""
    joined_messages = "\n".join(f"User: {redact_sensitive_info(m)}" for m in messages)
    system_prompt = (
        "You are an assistant that summarizes conversation context. "
        "Return a concise bullet list (max ~100 tokens) capturing key user info "
        "(symptoms, conditions, preferences) without including any sensitive data."
    )
    prompt_messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Conversation so far:\n{joined_messages}"}
    ]
    try:
        response = await openai_client.chat_completions_create(
            model="gpt-4-turbo",
            messages=prompt_messages,
            temperature=0.7,
            max_tokens=150
        )
        summary_text = response.choices[0].message.content.strip()
        return summary_text
    except Exception as e:
        logger.error(f"Error summarizing messages: {e}", exc_info=True)
        return ""

# ------------------------------------------------------------------------------
# Asynchronous GPT-4 Client Using OpenAI's Async API
# ------------------------------------------------------------------------------
class AsyncGPT4Client:
    def __init__(self, api_key: str):
        self.api_key = api_key
        openai.api_key = api_key

    async def chat_completions_create(self, model: str, messages: List[dict],
                                        temperature: float = 0.7,
                                        max_tokens: int = 300) -> dict:
        """
        Calls the OpenAI async ChatCompletion API.
        """
        try:
            response = await openai.ChatCompletion.acreate(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            return response
        except Exception as e:
            logger.error(f"Error generating GPT-4 response: {e}")
            raise

    async def generate_advice(self, prompt: str) -> str:
        messages = [{"role": "user", "content": prompt}]
        response = await self.chat_completions_create(
            model="gpt-4-turbo",
            messages=messages,
            temperature=0.7,
            max_tokens=300
        )
        return response.choices[0].message.content.strip()

# ------------------------------------------------------------------------------
# Conversation Context Retrieval (Replace with your real conversation/session management)
# ------------------------------------------------------------------------------
def get_conversation_context(patient_id: str) -> Dict[str, any]:
    """
    Retrieve recent conversation context for a patient.
    Replace this with your actual session/conversation manager call.
    """
    return {
        "recent_messages": [
            "I have been worried about my blood sugar levels.",
            "Last week I asked how to control my diabetes."
        ],
        "user_facts": {"diabetes": True}
    }

# ------------------------------------------------------------------------------
# Personalized Medical Advice Service (Hybrid Approach, Async)
# ------------------------------------------------------------------------------
class PersonalizedMedicalAdviceService:
    def __init__(self, gpt_client: AsyncGPT4Client):
        self.gpt_client = gpt_client
        # Use your actual FHIRService from your codebase
        self.fhir_service = FHIRService()

    async def get_personalized_advice(self, patient_id: str, user_query: str) -> str:
        """
        Combines patient data, conversation context, and evidence-based guidelines
        into a prompt for GPT-4, and returns personalized medical advice.
        """
        # Retrieve patient data via your FHIRService (using your real FHIR query)
        patient_resource = await asyncio.to_thread(self.fhir_service.get_patient, patient_id)
        if not patient_resource:
            return "Error: Patient data not found."

        patient_data = self._extract_patient_data(patient_resource)
        context = get_conversation_context(patient_id)
        recent_msgs = context.get("recent_messages", [])
        context_summary = await summarize_messages(recent_msgs, self.gpt_client)

        conditions = patient_data.get("conditions", [])
        guidelines = get_evidence_based_guidelines(conditions)

        prompt = self._build_prompt(user_query, patient_data, context_summary, guidelines)
        logger.info("Constructed prompt for GPT-4:")
        logger.info(prompt)

        advice = await self.gpt_client.generate_advice(prompt)
        advice = self._ensure_disclaimer(advice)
        return advice

    def _extract_patient_data(self, patient_resource: dict) -> dict:
        """
        Extracts relevant patient data from the FHIR Patient resource.
        Adjust extraction logic according to your actual FHIR resource structure.
        """
        data = {}
        birth_date_str = getattr(patient_resource, "birthDate", None)
        data["age"] = self._calculate_age(birth_date_str) if birth_date_str else "Unknown"
        # Replace these with your actual extraction calls, e.g., using self.fhir_service.get_patient_conditions
        data["conditions"] = ["diabetes", "hypertension"]
        data["medications"] = ["Metformin", "Lisinopril"]
        return data

    def _calculate_age(self, birth_date_str: str) -> int:
        try:
            birth_date = datetime.strptime(birth_date_str, "%Y-%m-%d").date()
            today = datetime.today().date()
            return today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
        except Exception as e:
            logger.error(f"Error calculating age from {birth_date_str}: {e}")
            return 0

    def _build_prompt(self, user_query: str, patient_data: dict,
                      context_summary: str, guidelines: dict) -> str:
        system_message = (
            "You are a clinically accurate medical assistant providing personalized advice based on evidence-based guidelines. "
            "Always include this disclaimer at the end: 'This information is for educational purposes only and is not a substitute for professional medical advice.'"
        )
        prompt_lines = [system_message, "\nPatient Data:"]
        for key, value in patient_data.items():
            prompt_lines.append(f"- {key}: {value}")
        prompt_lines.append("\nEvidence-Based Guidelines:")
        if guidelines:
            for condition, rec in guidelines.items():
                prompt_lines.append(f"- {condition}: {rec}")
        else:
            prompt_lines.append("- None available")
        prompt_lines.append("\nConversation Context Summary:")
        prompt_lines.append(context_summary if context_summary else "No significant context.")
        prompt_lines.append("\nUser Query:")
        prompt_lines.append(user_query)
        return "\n".join(prompt_lines)

    def _ensure_disclaimer(self, advice_text: str) -> str:
        disclaimer = "This information is for educational purposes only and is not a substitute for professional medical advice."
        if disclaimer.lower() not in advice_text.lower():
            advice_text += "\n\n" + disclaimer
        return advice_text

# ------------------------------------------------------------------------------
# Stand-Alone Async Script Entry Point for Testing
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)

    async def main():
        gpt_client = AsyncGPT4Client(api_key=settings.OPENAI_API_KEY)
        advice_service = PersonalizedMedicalAdviceService(gpt_client)
        example_patient_id = "12345"  # Replace with a valid patient ID from your FHIR server
        user_query = "How should I manage my diabetes effectively?"
        advice = await advice_service.get_personalized_advice(example_patient_id, user_query)
        print("Personalized Medical Advice:")
        print(advice)

    asyncio.run(main())
print ("30")

================
File: Django_app/chatbot/views/services/post_appointment_checkin_service.py
================
#!/usr/bin/env python
"""
post_appointment_checkin_service.py

A production-ready example of the Post-Appointment Check-In Service for Anna.
This script retrieves recently completed Appointments from a FHIR server (e.g., those
that ended ~24 hours ago), checks patient details, composes a follow-up SMS message,
and sends the message via an SMS provider (e.g., Twilio). It also contains stubs for
handling patient responses and escalating concerns.

FEATURES:
  1. Appointment Retrieval: Fetches Appointment resources with status='finished' (or 'completed')
     and filters them by end time to approximate a 24-hour post-appointment window.
  2. Patient Data Lookup: Retrieves the Patient resource for each appointment, pulling phone number,
     name, and preferred language.
  3. Personalized Follow-Up Message: Composes a message referencing the patient's appointment details
     and prompts them to respond if they have questions or concerns.
  4. SMS Sending: Integrates with your notification service (send_sms); in production, connect this
     to Twilio or another SMS provider.
  5. Logging & Tracking: Logs all sent messages. Includes a stub for storing these logs in a database
     if desired.
  6. Response Handling: Provides methods for processing inbound patient responses and escalating care
     team follow-up when certain keywords (e.g., "pain", "confused") appear.
  7. Internationalization (Optional): Illustrates a `_translate_message` stub, letting you integrate
     a translation API for patients whose preferred language is not English.

USAGE:
  - Schedule this script (e.g., via Celery or a cron job) to run periodically (daily or hourly),
    ensuring it checks which appointments ended ~24 hours ago.
  - Adjust the follow-up window, codes, and search parameters for your organization's needs.
  - Replace the placeholders in get_fhir_client() and send_sms() with real credentials
    and integration code.
  - Fully implement the response handling in a persistent store or inbound message queue.

IMPORTANT:
  - Thoroughly test in your staging environment before deploying to production.
  - Secure any PHI in logs, databases, and transmissions as required by HIPAA or relevant regulations.
"""

import logging
from datetime import datetime, timedelta

# fhirclient imports (install via `pip install fhirclient`)
from fhirclient import client
import fhirclient.models.appointment as fhir_appointment
import fhirclient.models.patient as fhir_patient

logger = logging.getLogger("PostAppointmentCheckInService")
logger.setLevel(logging.INFO)

# ---------------------------------------------------------------------------------
# Production FHIR client and SMS notification integration
# ---------------------------------------------------------------------------------
print ("31")
def get_fhir_client():
    """
    Configure and return a FHIRClient instance pointed at your FHIR server.
    Update 'api_base' and any OAuth settings as required for production.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://fhirserver.example.com',  # Replace with your actual endpoint
        # Uncomment/modify if OAuth is required:
        # 'client_id': 'YOUR_CLIENT_ID',
        # 'client_secret': 'YOUR_CLIENT_SECRET',
        # 'authorize_uri': 'https://fhirserver.example.com/auth',
        # 'redirect_uri': 'https://yourapp.example.com/redirect',
    }
    try:
        fhir_client = client.FHIRClient(settings=settings)
        logger.info("FHIR client initialized successfully.")
        return fhir_client
    except Exception as e:
        logger.error(f"Error initializing FHIR client: {e}")
        raise

def send_sms(to_number, message):
    """
    Sends an SMS message via your SMS provider.
    Replace the contents of this function with your actual integration code (e.g., Twilio).
    """
    try:
        logger.info(f"Sending SMS to {to_number}: {message}")
        # Example Twilio usage (pseudo-code):
        # from twilio.rest import Client as TwilioClient
        # import settings  # or use environment variables
        #
        # twilio_client = TwilioClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        # twilio_client.messages.create(
        #     body=message,
        #     from_=settings.TWILIO_PHONE_NUMBER,
        #     to=to_number
        # )
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {e}")
        return False

# ---------------------------------------------------------------------------------
# Post-Appointment Check-In Service
# ---------------------------------------------------------------------------------
class PostAppointmentCheckInService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service
        
        # How long after an appointment ends before sending a check-in (24h is typical)
        self.followup_delay = timedelta(hours=24)
        # A small tolerance window (in hours) around the exact follow-up time to decide
        # if it's "due now." This helps manage slight scheduling offsets.
        self.followup_tolerance = timedelta(hours=2)

    def process_checkins(self):
        """
        Main entry point:
          1. Retrieves 'finished' Appointments that ended ~24 hours ago.
          2. For each Appointment, fetches the associated Patient, composes an SMS,
             and sends the check-in message.
          3. Logs each successful check-in or any failures.
        """
        now = datetime.now()
        appointments = self._get_appointments_due_for_checkin(now)
        logger.info(f"Found {len(appointments)} appointments due for check-in at {now.isoformat()}")

        for appt in appointments:
            patient_id = self._extract_patient_id_from_appointment(appt)
            if not patient_id:
                logger.warning(f"No patient ID found in Appointment/{appt.id}, skipping check-in.")
                continue

            patient = self._get_patient_resource(patient_id)
            if not patient:
                logger.warning(f"Could not retrieve Patient/{patient_id}, skipping check-in.")
                continue

            phone = self._get_patient_phone_number(patient)
            if not phone:
                logger.warning(f"Patient {patient_id} has no phone number; skipping check-in.")
                continue

            patient_name = self._get_patient_name(patient)
            preferred_lang = self._get_patient_preferred_language(patient)

            message = self._compose_checkin_message(appt, patient_name)
            message = self._translate_message(message, preferred_lang)

            # Send the SMS check-in
            if self.notification_service(phone, message):
                logger.info(
                    f"Sent post-appointment check-in to patient {patient_id} for Appointment/{appt.id}"
                )
                self._log_checkin_sent(patient_id, appt.id, message)
            else:
                logger.error(f"Failed to send post-appointment check-in for Patient/{patient_id}")

    # ------------------------------------------------------------------
    # Appointment Retrieval & Filtering
    # ------------------------------------------------------------------
    def _get_appointments_due_for_checkin(self, now):
        """
        Retrieves Appointment resources whose status is 'finished' (or 'completed'),
        and whose 'end' time is about 'followup_delay' hours ago, within a tolerance window.
        
        For example, if followup_delay = 24h, we look for appointments that ended between
        (now - 24h - tolerance) and (now - 24h + tolerance).
        """
        # Calculate the time window in which appointments must have ended
        lower_bound = (now - self.followup_delay - self.followup_tolerance)
        upper_bound = (now - self.followup_delay + self.followup_tolerance)

        # We'll build a date filter that your FHIR server might accept. For instance,
        # some servers allow searching by 'date=lt' or 'end=lt'. Check your FHIR server's
        # documentation. Here we assume 'date' can refer to Appointment.start or end time,
        # or we might try a custom param:
        #
        #   'date=ge{lower_bound.isoformat()},le{upper_bound.isoformat()}'
        # 
        # but many servers differ. We'll keep it simple, then manually filter below.
        appointments = []
        try:
            search = fhir_appointment.Appointment.where({'status': 'finished'})
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for appt in bundle:
                    if not isinstance(appt, fhir_appointment.Appointment):
                        continue
                    end_time = self._get_appointment_end_time(appt)
                    if end_time and lower_bound <= end_time <= upper_bound:
                        appointments.append(appt)

                try:
                    bundle = bundle.next_bundle()
                except Exception:
                    break
        except Exception as e:
            logger.error(f"Error retrieving finished Appointments from FHIR: {e}")

        return appointments

    def _get_appointment_end_time(self, appt):
        """
        Extracts the 'end' time from the Appointment resource. 
        Appointment.end is an ISO8601 string. e.g. '2023-07-05T14:30:00Z'.
        """
        if hasattr(appt, 'end') and appt.end:
            try:
                return datetime.fromisoformat(appt.end.replace('Z', '+00:00'))
            except Exception as e:
                logger.warning(f"Error parsing appointment end time for Appointment/{appt.id}: {e}")
        return None

    # ------------------------------------------------------------------
    # Patient Data Retrieval
    # ------------------------------------------------------------------
    def _extract_patient_id_from_appointment(self, appt):
        """
        Extracts the Patient ID from Appointment.subject.reference (e.g. 'Patient/123').
        """
        if not appt.subject or not appt.subject.reference:
            return None
        parts = appt.subject.reference.split('/')
        return parts[-1] if len(parts) > 1 else None

    def _get_patient_resource(self, patient_id):
        """
        Retrieves a FHIR Patient resource by ID.
        """
        try:
            return fhir_patient.Patient.read(patient_id, self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient/{patient_id}: {e}")
            return None

    def _get_patient_phone_number(self, patient):
        """
        Searches Patient.telecom for a phone number to send SMS messages.
        """
        if patient.telecom:
            for telecom in patient.telecom:
                if telecom.system == 'phone' and telecom.value:
                    return telecom.value
        return None

    def _get_patient_name(self, patient):
        """
        Returns a readable patient name from patient.name.
        """
        if patient.name and len(patient.name) > 0:
            name = patient.name[0]
            given = " ".join(name.given) if name.given else ""
            family = name.family if name.family else ""
            full_name = f"{given} {family}".strip()
            return full_name if full_name else "Patient"
        return "Patient"

    def _get_patient_preferred_language(self, patient):
        """
        Tries to retrieve the patient's preferred language code from patient.communication.
        Returns 'en' if not found.
        """
        if patient.communication and len(patient.communication) > 0:
            comm = patient.communication[0]
            if hasattr(comm, 'language') and comm.language and comm.language.text:
                return comm.language.text.lower()  # e.g. 'en', 'es', etc.
        return 'en'

    # ------------------------------------------------------------------
    # Composing & Translating the Check-In Message
    # ------------------------------------------------------------------
    def _compose_checkin_message(self, appt, patient_name):
        """
        Builds a personalized message for the patient referencing their appointment.
        You can extract appointment date/time, provider name, or other relevant details.
        """
        provider_name = self._get_appointment_provider(appt) or "your provider"
        appt_start_str = self._format_appointment_time(appt)
        message = (
            f"Hello {patient_name},\n\n"
            f"We hope your appointment with {provider_name} on {appt_start_str} went well. "
            "Please reply with any questions you have or type 'OK' if everything is clear. "
            "If you are experiencing any issues (e.g., pain, confusion about instructions), reply 'HELP'."
        )
        return message

    def _get_appointment_provider(self, appt):
        """
        Example method to extract the provider's name (or org name) from the Appointment participants.
        In real usage, you'd look for the participant with role='primary performer' or similar,
        then read their display name or reference (e.g., Practitioner/123).
        """
        if not appt.participant:
            return None
        for participant in appt.participant:
            # Check if participant is a Practitioner or Organization with a display
            if participant.actor and participant.actor.display:
                return participant.actor.display
        return None

    def _format_appointment_time(self, appt):
        """
        Formats the appointment start time as a human-readable string.
        """
        if hasattr(appt, 'start') and appt.start:
            try:
                start_dt = datetime.fromisoformat(appt.start.replace('Z', '+00:00'))
                # Format as, e.g., 'July 5 at 2:30 PM'
                return start_dt.strftime("%B %d at %I:%M %p")
            except Exception as e:
                logger.warning(f"Error parsing appointment start time for Appointment/{appt.id}: {e}")
        return "your recent appointment"

    def _translate_message(self, message, target_language):
        """
        Stub for translating a message into another language.
        Integrate a real translation API (e.g., Google Cloud Translate) in production.
        """
        if target_language.lower() == 'en':
            return message
        # Example: prefix with language code for demonstration
        # In production, call your actual translation service here
        return f"[{target_language.upper()} Translation Placeholder] {message}"

    # ------------------------------------------------------------------
    # Logging & Response Handling
    # ------------------------------------------------------------------
    def _log_checkin_sent(self, patient_id, appointment_id, message):
        """
        Logs that we sent a check-in. In production, consider storing in a database
        for historical tracking.
        """
        logger.info(
            f"Check-in message recorded for Patient/{patient_id} Appointment/{appointment_id}: {message}"
        )

    def process_response(self, patient_id, appointment_id, response_text):
        """
        Example method to handle inbound responses from patients.
        In production, you'd call this from an SMS webhook or a queue.
        Checks for concerning keywords to decide if escalation is necessary.
        """
        self._log_patient_response(patient_id, appointment_id, response_text)
        if self._detect_concerning_keywords(response_text):
            self._escalate_issue(patient_id, appointment_id, response_text)

    def _log_patient_response(self, patient_id, appointment_id, response_text):
        """
        Logs the patient response. Again, store in a database if you want
        persistent records of inbound messages.
        """
        logger.info(
            f"Received response from Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )

    def _detect_concerning_keywords(self, response_text):
        """
        Very simple check for words that indicate patient distress or confusion.
        Expand with your own synonyms or logic as needed.
        """
        keywords = ['confused', 'side effect', 'pain', 'problem', 'worry', 'help']
        lower_text = response_text.lower()
        return any(keyword in lower_text for keyword in keywords)

    def _escalate_issue(self, patient_id, appointment_id, response_text):
        """
        Example of escalating a concerning response. In production, you might:
          - Notify a care coordinator via email or SMS
          - Generate a task in your EHR or ticket system
          - Prompt a telehealth nurse to call the patient
        """
        logger.warning(
            f"Escalation triggered for Patient/{patient_id} Appointment/{appointment_id}: {response_text}"
        )
        # Implement your actual escalation workflow (alerts, tasks, etc.)

# ---------------------------------------------------------------------------------
# Script Entry Point (Scheduling / Cron / Celery)
# ---------------------------------------------------------------------------------
if __name__ == "__main__":
    import sys
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    try:
        fhir_client = get_fhir_client()
        checkin_service = PostAppointmentCheckInService(fhir_client, send_sms)
        checkin_service.process_checkins()
    except Exception as e:
        logger.error(f"Critical error in processing post-appointment check-ins: {e}")
print ("32")

================
File: Django_app/chatbot/views/services/post_discharge_service.py
================
# chatbot/views/services/post_discharge_service.py
from celery import shared_task
from django.conf import settings
from twilio.rest import Client
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import logging
from chatbot.views.services.fhir_service import FHIRService  # Adjust import as per your project structure
print ("33")
logger = logging.getLogger('chatbot')
 
@shared_task
async def send_post_discharge_reminders():
    """
    Identifies patients discharged 72 hours ago and sends reminders.
    """
    try:
        fhir_service = FHIRService()
        current_time = datetime.now(ZoneInfo("UTC"))
        reminder_time = current_time - timedelta(hours=72)
        reminder_time_iso = reminder_time.isoformat()
 
        # Search for Encounters that have ended 72 hours ago
        encounters = await fhir_service.search(
            resource_type='Encounter',
            params={
                'status': 'finished',
                'end': f"eq{reminder_time_iso}",
                '_sort': '-end'
            }
        )
 
        if not encounters or 'entry' not in encounters:
            logger.info("No discharged patients found for reminder.")
            return
 
        for entry in encounters['entry']:
            encounter = entry['resource']
            patient_ref = encounter.get('subject', {}).get('reference', '')
            patient_id = patient_ref.split('/')[-1] if '/' in patient_ref else None
 
            if not patient_id:
                logger.warning("Encounter without patient reference.")
                continue
 
            # Retrieve patient details
            patient = await fhir_service.read('Patient', patient_id)
            if not patient:
                logger.warning(f"Patient {patient_id} not found.")
                continue
 
            patient_phone = fhir_service.get_patient_phone(patient)
            if not patient_phone:
                logger.warning(f"No phone number for patient {patient_id}.")
                continue
 
            patient_name = fhir_service.get_patient_name(patient)
 
            # Send SMS reminder
            success = await send_sms_reminder(patient_phone, patient_name)
            if success:
                logger.info(f"Reminder sent to patient {patient_id} for encounter {encounter['id']}.")
            else:
                logger.error(f"Failed to send reminder to patient {patient_id} for encounter {encounter['id']}.")
 
    except Exception as e:
        logger.error(f"Error in send_post_discharge_reminders: {str(e)}", exc_info=True)
        
async def send_sms_reminder(to_number, patient_name):
    """
    Sends an SMS reminder via Twilio.
    """
    try:
        client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
        message_body = (
            f"Hello {patient_name},\n\n"
            "We hope you're recovering well after your recent discharge. "
            "Please reply with how you're feeling today, or type 'help' if you have any concerns.\n\n"
            "Your Healthcare Team"
        )
        message = client.messages.create(
            body=message_body,
            from_=settings.TWILIO_PHONE_NUMBER,
            to=to_number
        )
        logger.info(f"Sent SMS to {to_number}: {message.sid}")
        return True
    except Exception as e:
        logger.error(f"Error sending SMS to {to_number}: {str(e)}", exc_info=True)
        return False
print ("34")

================
File: Django_app/chatbot/views/services/preventive_care_reminder_service.py
================
#!/usr/bin/env python
"""
preventive_care_reminder_service.py

A fully implemented example for the Preventive Care Reminder Service in Anna,
using the fhirclient library for querying a FHIR server. This script checks
patients' ages, risk factors (via Condition/Observation), and their latest
screening/Procedure dates to determine if they need various preventive services.
It then sends SMS reminders (via a Twilio-like function).

NOTES:
1. You must install fhirclient (e.g., `pip install fhirclient`) and have a valid
   FHIR endpoint (OAuth or basic auth, as configured in get_fhir_client()).
2. Replace the codes, URLs, and logic to suit your environment. This script
   demonstrates a typical approach but won't work out of the box without
   your actual codes and FHIR server configuration.
3. For real production usage, you may need pagination, concurrency, more refined
   search parameters, and handling of incomplete data or multiple payers.

Preventive Services Covered:
  - Colonoscopy (every 10 years starting at 45)
  - Mammogram (every 18 months starting at 50, or annually if high risk)
  - Diabetes Screening (every 3 years if at risk)
  - Hypertension Check (annually if borderline, every 2 years if normal)
  - Lipid Panel (every 5 years if at risk)
  - Osteoporosis Screening (every 2 years for postmenopausal women)
  - Vision & Hearing Screening (every 2 years)
  - Cervical Cancer Screening (Pap every 3 years from age 21+)
  - Prostate Cancer Screening (not automatically scheduled; discussion-based)
  - Lung Cancer Screening (annual for 5580 with smoking history)
  - Shingles Vaccine (once at age 50+ if not previously immunized)

If a patient had ANY preventive service in the last 18 months, you may skip sending
some reminders. This logic is handled by `_had_recent_preventive_care()`.

Risk Factor Determination is done by:
  - Checking Conditions or Observations for relevant codes (e.g., obesity, hypertension).
  - Checking the last BP Observation to decide if its borderline/elevated.

Robust Error Handling:
  - Each FHIR query is wrapped in try/except blocks to log and handle errors gracefully.
  - If a query fails, we skip that check and continue with other patients.

(c) Example only. Not guaranteed for production.
"""

import logging
from datetime import datetime, timedelta, date

# fhirclient library
from fhirclient import client
import fhirclient.models.patient as fhir_patient
import fhirclient.models.condition as fhir_condition
import fhirclient.models.observation as fhir_observation
import fhirclient.models.procedure as fhir_procedure
import fhirclient.models.immunization as fhir_immunization

# Logging setup
logger = logging.getLogger("PreventiveCareReminders")
logger.setLevel(logging.INFO)
print ("34")
# ----------------------------------------------------------------------
# REPLACE THESE WITH REAL CREDENTIALS / ENDPOINTS / OAUTH CONFIG
# ----------------------------------------------------------------------
def get_fhir_client():
    """
    Configure and return a FHIRClient pointed at your FHIR server.
    This example uses a public test server. Replace with your details.
    """
    settings = {
        'app_id': 'AnnaApp',
        'api_base': 'https://server.fire.ly/r4',  # Example test server - change to your endpoint
        # If you have OAuth, you'll need 'authorize_uri', 'redirect_uri', 'client_id', etc.
    }
    return client.FHIRClient(settings=settings)

def send_sms(to_number, message):
    """
    Example of an SMS sending function (Twilio-like).
    Replace with actual integration in production.
    """
    logger.info(f"Sending SMS to {to_number}: {message}")
    # e.g.:
    # twilio_client.messages.create(to=to_number, from_="YourShortCode", body=message)
    return True

# ----------------------------------------------------------------------
# Preventive Care Service Implementation
# ----------------------------------------------------------------------
class PreventiveCareReminderService:
    def __init__(self, fhir_client, notification_service):
        self.fhir_client = fhir_client
        self.notification_service = notification_service

        # Intervals in days
        self.interval_18_months = 18 * 30  # 540 days
        self.colonoscopy_interval = 10 * 365
        self.mammogram_interval = 18 * 30
        self.mammogram_interval_highrisk = 365  # 1 year if high risk
        self.diabetes_interval = 3 * 365
        self.hypertension_interval_normal = 2 * 365
        self.hypertension_interval_elevated = 365
        self.lipid_interval = 5 * 365
        self.osteoporosis_interval = 2 * 365
        self.vision_hearing_interval = 2 * 365
        self.cervical_interval_pap = 3 * 365
        # For co-testing every 5 years, you could define self.cervical_interval_cotesting
        self.lung_interval = 365
        # Prostate screening is discussion-based
        # Shingles vaccine once after 50

    def process_reminders(self):
        """
        Main entry point: gets due reminders and sends them.
        """
        reminders = self.get_due_reminders()
        for reminder in reminders:
            self.send_reminder(reminder)

    def get_due_reminders(self):
        """
        Retrieves all Patients, checks each for needed services, returns a list of reminders.
        """
        reminders = []
        patients = self._get_all_patients()
        now = datetime.now()

        for patient in patients:
            if not patient.id:
                continue

            # Check opt-out
            if self._patient_has_opted_out(patient):
                continue

            phone_number = self._get_patient_phone_number(patient)
            if not phone_number:
                continue

            birth_date = self._get_birth_date(patient)
            if not birth_date:
                continue

            age = self._calculate_age(birth_date, now)

            # We'll collect potential reminders in a local list, then check if we skip some
            patient_reminders = []

            # Check each preventive service
            # 1. Colonoscopy
            if age >= 45:
                if self._needs_colonoscopy(patient.id, now):
                    patient_reminders.append(("Colonoscopy", now.isoformat()))

            # 2. Mammogram for women age >= 50, or high-risk 40+
            if self._is_female(patient):
                if age >= 50:
                    if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval):
                        patient_reminders.append(("Mammogram", now.isoformat()))
                else:
                    # If <50 but high-risk (BRCA, family history, etc.)
                    if age >= 40 and self._is_high_risk_breast_cancer(patient):
                        if self._needs_mammogram(patient.id, now, interval=self.mammogram_interval_highrisk):
                            patient_reminders.append(("Mammogram (High-Risk)", now.isoformat()))

            # 3. Diabetes screening if at risk, every 3 years
            if self._is_at_risk_for_diabetes(patient):
                if self._needs_diabetes_screening(patient.id, now):
                    patient_reminders.append(("Diabetes Screening", now.isoformat()))

            # 4. Hypertension check
            if age >= 18:
                bp_interval = self.hypertension_interval_elevated if self._has_borderline_bp(patient) else self.hypertension_interval_normal
                if self._needs_blood_pressure_check(patient.id, now, bp_interval):
                    patient_reminders.append(("Hypertension Check", now.isoformat()))

            # 5. Lipid panel if at risk
            if self._is_at_risk_for_cardio(patient):
                if self._needs_lipid_panel(patient.id, now):
                    patient_reminders.append(("Cholesterol/Lipid Panel", now.isoformat()))

            # 6. Osteoporosis screening for postmenopausal women
            if self._is_female(patient) and self._is_postmenopausal(age, patient):
                if self._needs_osteoporosis_screening(patient.id, now):
                    patient_reminders.append(("Osteoporosis Screening", now.isoformat()))

            # 7. Vision & Hearing
            if self._needs_vision_hearing_screening(patient.id, now):
                patient_reminders.append(("Vision and Hearing Screening", now.isoformat()))

            # 8. Cervical screening for women 21+
            if self._is_female(patient) and age >= 21:
                if self._needs_cervical_screening(patient.id, now, age):
                    patient_reminders.append(("Cervical Cancer Screening", now.isoformat()))

            # 9. Lung cancer screening for 5580 with smoking history
            if 55 <= age <= 80 and self._is_eligible_for_lung_screening(patient):
                if self._needs_lung_screening(patient.id, now):
                    patient_reminders.append(("Lung Cancer Screening", now.isoformat()))

            # 10. Shingles vaccine at 50+
            if age >= 50:
                if self._needs_shingles_vaccine(patient.id):
                    patient_reminders.append(("Shingles Vaccine", now.isoformat()))

            # Skip sending if patient had any preventive care in last 18 months
            if patient_reminders and not self._had_recent_preventive_care(patient.id, now, self.interval_18_months):
                for service_name, due_date in patient_reminders:
                    reminders.append({
                        "patient_id": patient.id,
                        "service": service_name,
                        "due_date": due_date,
                        "phone_number": phone_number
                    })

        return reminders

    def send_reminder(self, reminder):
        """
        Sends an SMS reminder for a particular service.
        """
        message = (
            f"Hello! You are due for {reminder['service']}. "
            "Please call or visit us online to schedule your appointment."
        )
        try:
            self.notification_service(reminder['phone_number'], message)
            logger.info(f"Sent {reminder['service']} reminder to patient {reminder['patient_id']}")
        except Exception as e:
            logger.error(f"Error sending reminder to patient {reminder['patient_id']}: {e}")

    # -------------------------------------------------------------
    # PATIENT / DEMOGRAPHIC QUERIES
    # -------------------------------------------------------------
    def _get_all_patients(self):
        """
        Retrieves all Patient records from FHIR. Includes basic
        pagination handling for demonstration. Adjust as needed.
        """
        results = []
        search = fhir_patient.Patient.where({})
        try:
            bundle = search.perform_resources(self.fhir_client.server)
        except Exception as e:
            logger.error(f"Error retrieving Patient resources: {e}")
            return results  # Return empty list on error

        while bundle:
            for resource in bundle:
                if isinstance(resource, fhir_patient.Patient):
                    results.append(resource)
            # Attempt next page
            next_bundle = None
            try:
                next_bundle = bundle.next_bundle()
            except Exception:
                pass
            bundle = next_bundle

        return results

    def _get_patient_phone_number(self, patient):
        """
        Extracts phone number from the Patient.telecom array.
        """
        if not patient.telecom:
            return None
        for telecom in patient.telecom:
            if telecom.system == 'phone' and telecom.value:
                return telecom.value
        return None

    def _get_birth_date(self, patient):
        """
        Returns birth date as a date object, or None.
        """
        if not patient.birthDate:
            return None
        try:
            return datetime.strptime(patient.birthDate, '%Y-%m-%d').date()
        except ValueError:
            return None

    def _calculate_age(self, birth_date, now):
        """
        Returns integer age in years.
        """
        if not birth_date:
            return 0
        return now.year - birth_date.year - ((now.month, now.day) < (birth_date.month, birth_date.day))

    def _patient_has_opted_out(self, patient):
        """
        Example: checks a custom extension for an opt-out flag.
        Replace with how your system stores opt-out data.
        """
        # Suppose there's an extension with url "http://example.org/fhir/StructureDefinition/optOut"
        if not patient.extension:
            return False
        for ext in patient.extension:
            if ext.url == "http://example.org/fhir/StructureDefinition/optOut":
                if hasattr(ext, 'valueBoolean') and ext.valueBoolean is True:
                    return True
        return False

    def _is_female(self, patient):
        return (patient.gender or "").lower() == "female"

    def _is_postmenopausal(self, age, patient):
        """
        A simplistic assumption: age >= 50 -> postmenopausal.
        Replace with logic for actual Observations or Conditions.
        """
        return age >= 50

    # -------------------------------------------------------------
    # RISK FACTOR CHECKS: Real FHIR Queries for Conditions/Obs
    # -------------------------------------------------------------
    def _is_high_risk_breast_cancer(self, patient):
        """
        Example: checks for Conditions indicating a BRCA mutation or strong family history.
        (Using hypothetical SNOMED/ICD codes.)
        """
        high_risk_codes = [
            "195967001",  # SNOMED for BRCA1 mutation
            "254632001",  # Family history of breast cancer
        ]
        return self._has_any_condition(patient.id, high_risk_codes)

    def _is_at_risk_for_diabetes(self, patient):
        """
        Checks if patient has diabetes or is obese (BMI >30), or has a condition indicating
        prediabetes/family history.
        """
        # Condition codes for diabetes/prediabetes
        diabetes_codes = [
            "44054006",   # Diabetes mellitus type 2
            "15777000",   # Diabetes mellitus type 1
            "42954007",   # Prediabetes
            "73211009",   # Family history of diabetes
        ]
        if self._has_any_condition(patient.id, diabetes_codes):
            return True

        # Check Observations for obesity via last BMI
        bmi = self._get_latest_bmi(patient.id)
        if bmi and bmi >= 30.0:
            return True

        return False

    def _is_at_risk_for_cardio(self, patient):
        """
        Example: checks for existing hyperlipidemia condition or smoking status observation.
        """
        hyperlipidemia_codes = [
            "13644009",  # SNOMED: Hyperlipidemia
        ]
        if self._has_any_condition(patient.id, hyperlipidemia_codes):
            return True

        # Check if patient is a current smoker (Observation of tobacco use = 'current')
        if self._is_current_smoker(patient.id):
            return True

        return False

    def _has_borderline_bp(self, patient):
        """
        Check the last BP reading from Observations.
        Consider borderline if systolic 120129 or diastolic <80, or mild hypertension codes.
        """
        bp = self._get_latest_blood_pressure(patient.id)
        if not bp:
            return False

        systolic = bp.get('systolic')
        diastolic = bp.get('diastolic')

        # Example borderline criteria:
        # Systolic between 120129, diastolic <80 => borderline
        if systolic is not None and diastolic is not None:
            if 120 <= systolic <= 129 and diastolic < 80:
                return True

        # Alternatively, if they have a Condition for borderline hypertension:
        borderline_codes = ["60423000"]  # SNOMED for borderline hypertension
        if self._has_any_condition(patient.id, borderline_codes):
            return True

        return False

    def _is_eligible_for_lung_screening(self, patient):
        """
        Check if patient has a heavy smoking history (Condition or Observation).
        Example code for 'heavy tobacco smoker' or pack-year data.
        """
        # If patient has Condition "266919005" (Heavy tobacco smoker)
        heavy_smoker_codes = ["266919005"]
        if self._has_any_condition(patient.id, heavy_smoker_codes):
            return True
        # Could also parse Observations for pack-year calculations
        return False

    def _has_any_condition(self, patient_id, code_list):
        """
        Returns True if the patient has ANY Condition with a code in `code_list`.
        """
        for code in code_list:
            # We do partial or exact matches. In real usage, you may want a more robust approach
            found = self._search_condition_by_code(patient_id, code)
            if found:
                return True
        return False

    def _is_current_smoker(self, patient_id):
        """
        Checks Observations for a tobacco use code that indicates current smoker.
        Example SNOMED code for 'Current smoker' = 77176002
        LOINC code for Tobacco smoking status = 72166-2 (which might store a coded value).
        """
        # In real usage, you'd parse the valueCodeableConcept for 'current every day smoker', etc.
        return self._search_observation_value_code(patient_id, "72166-2", ["449868002", "77176002"])

    # -------------------------------------------------------------
    # CONDITION / OBSERVATION QUERIES
    # -------------------------------------------------------------
    def _search_condition_by_code(self, patient_id, code):
        """
        Searches Condition for a given SNOMED or ICD code.
        Returns True if found, False otherwise.
        """
        try:
            search = fhir_condition.Condition.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error searching Condition for code {code}, patient {patient_id}: {e}")
        return False

    def _search_observation_value_code(self, patient_id, loinc_code, answer_codes):
        """
        Example: searches Observations with code=loinc_code and a specific coded value
        in Observation.valueCodeableConcept. If any match an 'answer_code' that indicates
        current smoker, returns True.
        """
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': loinc_code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    valcc = getattr(obs, 'valueCodeableConcept', None)
                    if valcc and valcc.coding:
                        for coding in valcc.coding:
                            if coding.code in answer_codes:
                                return True
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Observations for code {loinc_code}, patient {patient_id}: {e}")
        return False

    def _get_latest_bmi(self, patient_id):
        """
        Returns the latest BMI value from Observations (LOINC 39156-5 or 60832-3).
        """
        bmi_codes = ["39156-5", "60832-3"]  # LOINC for Body Mass Index
        latest_date = None
        latest_bmi = None

        for code in bmi_codes:
            try:
                search = fhir_observation.Observation.where({
                    'subject': f'Patient/{patient_id}',
                    'code': code
                })
                bundle = search.perform_resources(self.fhir_client.server)
                while bundle:
                    for obs in bundle:
                        if isinstance(obs, fhir_observation.Observation):
                            obs_date = self._extract_obs_effective_date(obs)
                            value = self._extract_quantity_value(obs)
                            if obs_date and value is not None:
                                if not latest_date or obs_date > latest_date:
                                    latest_date = obs_date
                                    latest_bmi = value
                    bundle = bundle.next_bundle()
            except Exception as e:
                logger.error(f"Error retrieving BMI Observations for patient {patient_id}: {e}")

        return latest_bmi

    def _get_latest_blood_pressure(self, patient_id):
        """
        Returns a dict with 'systolic' and 'diastolic' from the latest BP observation
        (LOINC code 85354-9: Blood pressure panel).
        """
        code = "85354-9"
        bp_data = {}
        latest_date = None
        try:
            search = fhir_observation.Observation.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for obs in bundle:
                    if not isinstance(obs, fhir_observation.Observation):
                        continue
                    obs_date = self._extract_obs_effective_date(obs)
                    if obs_date and (not latest_date or obs_date > latest_date):
                        # Extract components for systolic (8480-6) & diastolic (8462-4)
                        components = getattr(obs, 'component', [])
                        s_val, d_val = None, None
                        for comp in components:
                            coding_list = getattr(comp.code, 'coding', None)
                            if not coding_list:
                                continue
                            for c in coding_list:
                                if c.code == "8480-6":  # Systolic
                                    s_val = self._extract_quantity_value(comp)
                                elif c.code == "8462-4":  # Diastolic
                                    d_val = self._extract_quantity_value(comp)
                        bp_data = {'systolic': s_val, 'diastolic': d_val}
                        latest_date = obs_date
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error retrieving Blood Pressure for patient {patient_id}: {e}")
        return bp_data

    # -------------------------------------------------------------
    # NEEDS-* CHECKS: LOOK FOR LAST SERVICE DATE OR IMMUNIZATION
    # -------------------------------------------------------------
    def _needs_colonoscopy(self, patient_id, now):
        last_date = self._get_last_procedure_date(patient_id, ["73761001"])  # SNOMED for colonoscopy
        if not last_date:
            return True
        return (now.date() - last_date).days > self.colonoscopy_interval

    def _needs_mammogram(self, patient_id, now, interval):
        codes = ["72313002"]  # SNOMED for screening mammogram
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_diabetes_screening(self, patient_id, now):
        # E.g. LOINC for A1c or Glucose Tolerance
        codes = ["4548-4", "6298-4"]  # Some LOINC placeholders
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.diabetes_interval

    def _needs_blood_pressure_check(self, patient_id, now, interval):
        # If no BP reading coded as a Procedure, or if it's older than interval
        # Some places record BP as Observations only, but let's assume you might have a
        # "vitals check" procedure code. We'll just re-use the "85354-9" LOINC for demonstration.
        last_date = self._get_last_procedure_date(patient_id, ["85354-9"])
        if not last_date:
            return True
        return (now.date() - last_date).days > interval

    def _needs_lipid_panel(self, patient_id, now):
        # LOINC for Lipid panel = "24331-1", etc.
        codes = ["24331-1"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lipid_interval

    def _needs_osteoporosis_screening(self, patient_id, now):
        # SNOMED for DXA = "398181004"
        codes = ["398181004"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.osteoporosis_interval

    def _needs_vision_hearing_screening(self, patient_id, now):
        # SNOMED example code = "424732000"
        codes = ["424732000"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.vision_hearing_interval

    def _needs_cervical_screening(self, patient_id, now, age):
        # Pap test code example: "19762-4" (LOINC) or "Pap" as SNOMED
        # We'll just pick one LOINC for demonstration
        codes = ["19762-4"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.cervical_interval_pap

    def _needs_lung_screening(self, patient_id, now):
        # SNOMED: "168537006" for low-dose CT
        codes = ["168537006"]
        last_date = self._get_last_procedure_date(patient_id, codes)
        if not last_date:
            return True
        return (now.date() - last_date).days > self.lung_interval

    def _needs_shingles_vaccine(self, patient_id):
        # Check if we have an Immunization with relevant code
        # Example: SNOMED for zoster vaccination is "212527006"
        immun_code = ["212527006"]
        last_date = self._get_last_immunization_date(patient_id, immun_code)
        return (last_date is None)

    def _had_recent_preventive_care(self, patient_id, now, interval_days):
        """
        Returns True if the patient had ANY preventive procedure in the last `interval_days`.
        We'll define a broad list of codes for all the services we consider "preventive."
        """
        codes = [
            "73761001",   # Colonoscopy
            "72313002",   # Mammogram
            "4548-4", "6298-4",  # Diabetes screening
            "85354-9",    # BP check
            "24331-1",    # Lipid panel
            "398181004",  # DXA
            "424732000",  # Vision/hearing
            "19762-4",    # Pap
            "168537006",  # Lung screening
        ]
        cutoff = now.date() - timedelta(days=interval_days)

        for code in codes:
            recent = self._has_procedure_after(patient_id, code, cutoff)
            if recent:
                return True

        return False

    # -------------------------------------------------------------
    # FHIR Procedure & Immunization queries
    # -------------------------------------------------------------
    def _get_last_procedure_date(self, patient_id, codes):
        """
        Searches Procedure for any of the given codes, returns the latest date.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_procedure_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_procedure_latest(self, patient_id, code):
        """
        Returns the most recent procedure date for `code`.
        """
        latest_date = None
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for proc in bundle:
                    if not isinstance(proc, fhir_procedure.Procedure):
                        continue
                    dt = self._extract_procedure_date(proc)
                    if dt and (not latest_date or dt > latest_date):
                        latest_date = dt
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Procedure for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _extract_procedure_date(self, procedure):
        """
        Extracts a date from procedure.performedDateTime or procedure.performedPeriod.
        Returns a date object or None.
        """
        pdt = getattr(procedure, 'performedDateTime', None)
        pperiod = getattr(procedure, 'performedPeriod', None)

        # performedDateTime is typically an ISO8601 string
        if pdt:
            return self._parse_date_str(pdt)
        if pperiod:
            if pperiod.end:
                return self._parse_date_str(pperiod.end)
            if pperiod.start:
                return self._parse_date_str(pperiod.start)
        return None

    def _get_last_immunization_date(self, patient_id, codes):
        """
        Returns the most recent immunization date for any code in `codes`.
        """
        latest_date = None
        for c in codes:
            date_candidate = self._search_immunization_latest(patient_id, c)
            if date_candidate and (not latest_date or date_candidate > latest_date):
                latest_date = date_candidate
        return latest_date

    def _search_immunization_latest(self, patient_id, code):
        """
        Returns the most recent Immunization date for a code.
        """
        latest_date = None
        try:
            search = fhir_immunization.Immunization.where({
                'patient': f'Patient/{patient_id}',
                'vaccine-code': code
            })
            bundle = search.perform_resources(self.fhir_client.server)
            while bundle:
                for imm in bundle:
                    if not isinstance(imm, fhir_immunization.Immunization):
                        continue
                    dt = getattr(imm, 'occurrenceDateTime', None)
                    if dt:
                        d = self._parse_date_str(dt)
                        if d and (not latest_date or d > latest_date):
                            latest_date = d
                bundle = bundle.next_bundle()
        except Exception as e:
            logger.error(f"Error searching Immunization for code {code}, patient {patient_id}: {e}")
        return latest_date

    def _has_procedure_after(self, patient_id, code, cutoff_date):
        """
        Returns True if there's a Procedure with `code` after `cutoff_date`.
        """
        try:
            search = fhir_procedure.Procedure.where({
                'subject': f'Patient/{patient_id}',
                'code': code,
                'date': f'ge{cutoff_date.isoformat()}'
            })
            bundle = search.perform_resources(self.fhir_client.server)
            if bundle and len(bundle) > 0:
                return True
        except Exception as e:
            logger.error(f"Error checking recent Procedure for code {code}, patient {patient_id}: {e}")
        return False

    # -------------------------------------------------------------
    # OBSERVATION UTILS
    # -------------------------------------------------------------
    def _extract_obs_effective_date(self, obs):
        """
        Extracts the date from Observation.effectiveDateTime or Observation.effectivePeriod.
        """
        edt = getattr(obs, 'effectiveDateTime', None)
        epd = getattr(obs, 'effectivePeriod', None)
        if edt:
            return self._parse_date_str(edt)
        if epd:
            if epd.end:
                return self._parse_date_str(epd.end)
            if epd.start:
                return self._parse_date_str(epd.start)
        return None

    def _extract_quantity_value(self, obj):
        """
        If the Observation or component has a valueQuantity, return the .value as a float.
        """
        valQ = getattr(obj, 'valueQuantity', None)
        if valQ and valQ.value is not None:
            return float(valQ.value)
        return None

    # -------------------------------------------------------------
    # DATE PARSING
    # -------------------------------------------------------------
    def _parse_date_str(self, date_str):
        """
        Attempts to parse a date/time string to a datetime.date.
        """
        if not date_str:
            return None
        try:
            dt = datetime.fromisoformat(date_str)
            return dt.date()
        except ValueError:
            # Possibly just YYYY-MM-DD
            try:
                return datetime.strptime(date_str, "%Y-%m-%d").date()
            except ValueError:
                logger.warning(f"Unable to parse date string: {date_str}")
                return None


# ----------------------------------------------------------------------
# SCRIPT ENTRY POINT
# ----------------------------------------------------------------------
if __name__ == "__main__":
    # Configure logging to console
    logging.basicConfig(level=logging.INFO)

    # Initialize FHIR client and the reminder service
    fhir = get_fhir_client()
    reminder_service = PreventiveCareReminderService(fhir, send_sms)

    # Option 1: Generate a list of due reminders
    # reminders = reminder_service.get_due_reminders()
    # for r in reminders:
    #     print(r)

    # Option 2: Directly process (send) all reminders
    reminder_service.process_reminders()
print ("35")

================
File: Django_app/chatbot/views/services/scheduler.py
================
from datetime import datetime, time, timedelta, timezone
from zoneinfo import ZoneInfo
from chatbot.views.utils.shared import get_resource_name 
import dateparser
from django.conf import settings
from ..config import config as app_config
import logging
import openai
from celery import shared_task
from celery.schedules import crontab
from .medication_service import MedicationAdherenceReminderService
from ..utils.datetime_utils import get_current_time
openai.api_key = settings.OPENAI_API_KEY

fhir_client = app_config.get_fhir_client()
# Configure logging
logger = logging.getLogger('chatbot')

# Initialize FHIR Client


# Initialize OpenAI client
client = settings.OPENAI_API_KEY

print ("36")

class ScheduleManager:
    def __init__(self, fhir_client, logger=None):
        self.fhir_client = fhir_client
        self.logger = logger or logging.getLogger(__name__)

    def create_unlimited_schedule(self, practitioner_id):
        """Creates a schedule with an extended planning horizon"""
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": "2024-01-01T00:00:00Z",
                "end": "2050-12-31T23:59:59Z"
            }
        }
        return self.fhir_client.create("Schedule", schedule)

    def update_all_schedules(self):
        """Updates all existing schedules with unlimited planning horizon"""
        results = {"success": 0, "failed": 0}
        schedules = self.fhir_client.search("Schedule", {})
        
        if not schedules or 'entry' not in schedules:
            self.logger.warning("No schedules found to update")
            return results

        for entry in schedules.get('entry', []):
            schedule = entry.get('resource', {})
            schedule_id = schedule.get('id')
            try:
                schedule['planningHorizon'] = {
                    "start": "2024-01-01T00:00:00Z",
                    "end": "2050-12-31T23:59:59Z"
                }
                if self.fhir_client.update("Schedule", schedule_id, schedule):
                    results["success"] += 1
                else:
                    results["failed"] += 1
            except Exception as e:
                results["failed"] += 1
                self.logger.error(f"Error updating schedule {schedule_id}: {str(e)}")

        return results

    def create_slots(self, schedule_id, start_date="2024-01-01", end_date="2050-12-31"):
        """Creates slots for a given schedule between start and end dates"""
        try:
            start = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            end = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            current = start
            
            while current < end:
                if 9 <= current.hour < 17:  # Business hours
                    slot = {
                        "resourceType": "Slot",
                        "schedule": {"reference": f"Schedule/{schedule_id}"},
                        "status": "free",
                        "start": current.isoformat() + 'Z',
                        "end": (current + timedelta(minutes=30)).isoformat() + 'Z'
                    }
                    self.fhir_client.create("Slot", slot)
                
                current += timedelta(minutes=30)
                
            return {"status": "success", "message": "Slots created successfully"}
        except Exception as e:
            self.logger.error(f"Error creating slots: {str(e)}")
            return {"status": "error", "message": str(e)}

# Initialize Schedule Manager
def search_available_slots(practitioner_id, datetime_requested):
    """Search for available slots for a practitioner at a specific time"""
    try:
        logger.info(f"Searching for slots for practitioner {practitioner_id} at {datetime_requested}")
        
        fhir_client = app_config.get_fhir_client()
        if not fhir_client:
            logger.error("FHIR client is None")
            return []
            
        # First, get or create the schedule
        schedule_search = fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_search or 'entry' not in schedule_search or not schedule_search['entry']:
            logger.info(f"No schedule found for practitioner {practitioner_id}, creating new schedule")
            schedule = create_practitioner_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return []
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_search['entry'][0]['resource']['id']
        
        # Ensure slots exist for the requested date
        create_slots_if_needed(schedule_id, datetime_requested)
        
        # Search for specific slot
        start_time = datetime_requested
        start_range = start_time - timedelta(minutes=30)
        end_range = start_time + timedelta(minutes=30)
        
        slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_range.isoformat()}&le{end_range.isoformat()}",
            "status": "free"
        })
        
        if not slots or 'entry' not in slots:
            logger.info(f"No slots found for time {start_time}")
            return []
            
        return slots['entry']

    except Exception as e:
        logger.error(f"Error searching for slots: {str(e)}", exc_info=True)
        return []

def create_slots_if_needed(schedule_id, target_datetime):
    """Create slots for a specific date if they don't exist"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        # Convert to start of day
        start_of_day = target_datetime.replace(hour=9, minute=0, second=0, microsecond=0)
        end_of_day = target_datetime.replace(hour=17, minute=0, second=0, microsecond=0)
        
        # Check if slots already exist
        existing_slots = fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}&le{end_of_day.isoformat()}"
        })
        
        if not existing_slots or 'entry' not in existing_slots or not existing_slots['entry']:
            logger.info(f"Creating slots for {start_of_day.date()}")
            current_time = start_of_day
            
            while current_time < end_of_day:
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current_time.isoformat(),
                    "end": (current_time + timedelta(minutes=30)).isoformat()
                }
                
                try:
                    fhir_client.create("Slot", slot)
                    logger.debug(f"Created slot for {current_time.isoformat()}")
                except Exception as e:
                    logger.error(f"Failed to create slot for {current_time.isoformat()}: {str(e)}")
                
                current_time += timedelta(minutes=30)
            
            return True
        
        return True
        
    except Exception as e:
        logger.error(f"Error creating slots: {str(e)}", exc_info=True)
        return False
    

schedule_manager = ScheduleManager(fhir_client, logger)
def get_appointment_schedule(practitioner_id):
    """Retrieve the appointment schedule for a practitioner."""
    return fhir_client.search("Schedule", {"actor": f"Practitioner/{practitioner_id}"})


def create_practitioner_schedule(practitioner_id):
    """Creates a new schedule for a practitioner"""
    try:
        fhir_client = app_config.get_fhir_client()
        
        schedule = {
            "resourceType": "Schedule",
            "active": True,
            "serviceCategory": [{"text": "Consultation"}],
            "serviceType": [{"text": "Primary Care Physician"}],
            "actor": [{
                "reference": f"Practitioner/{practitioner_id}",
                "type": "Practitioner"
            }],
            "planningHorizon": {
                "start": datetime.now(ZoneInfo("UTC")).isoformat(),
                "end": (datetime.now(ZoneInfo("UTC")) + timedelta(days=90)).isoformat()
            }
        }
        
        return fhir_client.create("Schedule", schedule)
        
    except Exception as e:
        logger.error(f"Error creating schedule: {str(e)}", exc_info=True)
        return None

def create_slots_for_date(schedule_id, date):
    """
    Creates slots for a specific date only.
    """
    try:
        # Convert to clinic timezone if not already
        clinic_tz = ZoneInfo("America/New_York")
        if isinstance(date, str):
            date = datetime.fromisoformat(date.replace('Z', '+00:00'))
        date = date.astimezone(clinic_tz)
        
        # Start and end times in clinic timezone
        current = datetime.combine(date.date(), time(9, 0), tzinfo=clinic_tz)
        end_time = datetime.combine(date.date(), time(17, 0), tzinfo=clinic_tz)
        
        created_slots = []
        while current < end_time:
            if current.weekday() < 5:  # Weekdays only
                slot = {
                    "resourceType": "Slot",
                    "schedule": {"reference": f"Schedule/{schedule_id}"},
                    "status": "free",
                    "start": current.isoformat(),
                    "end": (current + timedelta(minutes=30)).isoformat()
                }
                created = fhir_client.create("Slot", slot)
                if created:
                    created_slots.append(created)
            current += timedelta(minutes=30)
            
        logger.info(f"Created {len(created_slots)} slots for date {date.date()}")
        return True
    except Exception as e:
        logger.error(f"Error creating slots: {e}", exc_info=True)
        return False
    
def ensure_extended_schedule(practitioner_id, requested_date):
    """
    Ensures schedule exists and has slots for the requested date.
    Creates schedule and slots if needed.
    """
    try:
        schedule_manager = ScheduleManager(app_config.get_fhir_client(), logger)
        
        # Search for existing schedule
        schedule_results = schedule_manager.fhir_client.search("Schedule", {
            "actor": f"Practitioner/{practitioner_id}"
        })
        
        if not schedule_results or 'entry' not in schedule_results:
            # Create new schedule
            schedule = schedule_manager.create_unlimited_schedule(practitioner_id)
            if not schedule:
                logger.error("Failed to create schedule")
                return False
            schedule_id = schedule['id']
        else:
            schedule_id = schedule_results['entry'][0]['resource']['id']
        
        # Create slots for the date if they don't exist
        start_of_day = requested_date.replace(hour=9, minute=0, second=0, microsecond=0)
        slots = schedule_manager.fhir_client.search("Slot", {
            "schedule": f"Schedule/{schedule_id}",
            "start": f"ge{start_of_day.isoformat()}"
        })
        
        if not slots or 'entry' not in slots:
            return create_slots_for_date(schedule_id, requested_date)
            
        return True
        
    except Exception as e:
        logger.error(f"Error ensuring schedule: {str(e)}", exc_info=True)
        return False
def find_next_available_slots(practitioner_id, from_datetime, limit=5):
    """
    Finds the next available slots, checking for existing appointments.
    """
    try:
        logger.debug(f"Finding next available slots for practitioner {practitioner_id} from {from_datetime}")
        
        # Convert input datetime
        from_dt = datetime.fromisoformat(from_datetime.replace('Z', '+00:00'))
        end_dt = from_dt + timedelta(days=30)  # Look ahead 30 days
        
        # Get all existing appointments within the date range
        appointment_params = {
            'practitioner': f"Practitioner/{practitioner_id}",
            'date': f"ge{from_dt.isoformat()}&le{end_dt.isoformat()}",
            'status': 'booked,pending'
        }
        existing_appointments = fhir_client.search('Appointment', appointment_params)
        booked_times = set()
        
        if existing_appointments and 'entry' in existing_appointments:
            for appt in existing_appointments['entry']:
                start_time = appt['resource'].get('start')
                if start_time:
                    booked_times.add(start_time)
        
        available_slots = []
        current = from_dt
        
        while current <= end_dt and len(available_slots) < limit:
            # Skip weekends
            if current.weekday() >= 5:
                current += timedelta(days=1)
                continue
                
            # Check each time slot during business hours
            day_start = current.replace(hour=9, minute=0, second=0, microsecond=0)
            day_end = current.replace(hour=17, minute=0, second=0, microsecond=0)
            
            slot_time = day_start
            while slot_time < day_end:
                # Skip if slot is already booked
                if slot_time.isoformat() not in booked_times:
                    available_slots.append(slot_time.strftime("%A, %B %d, %Y at %I:%M %p"))
                    if len(available_slots) >= limit:
                        break
                slot_time += timedelta(minutes=30)
                
            current += timedelta(days=1)
        
        return available_slots
        
    except Exception as e:
        logger.error(f"Error in find_next_available_slots: {str(e)}")
        return []
    
def get_patient_appointments(patient_id):
    """Get all upcoming appointments for a patient"""
    try:
        fhir_client = app_config.get_fhir_client()
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        
        response = fhir_client.search("Appointment", {
            "patient": f"Patient/{patient_id}",
            "date": f"ge{current_time}",
            "_sort": "date",
            "_count": 10
        })
        
        if not response or 'entry' not in response:
            return []
            
        return response['entry']
        
    except Exception as e:
        logger.error(f"Error getting patient appointments: {str(e)}", exc_info=True)
        return []
    
@shared_task
def process_medication_reminders():
    """Process all due medication reminders."""
    reminder_service = MedicationAdherenceReminderService()
    current_time = get_current_time()
    
    try:
        due_reminders = reminder_service.get_due_reminders(current_time)
        
        for reminder in due_reminders:
            try:
                send_reminder(reminder)
            except Exception as e:
                logger.error(f"Failed to send reminder for patient {reminder['patient_id']}: {str(e)}")
                
    except Exception as e:
        logger.error(f"Failed to process medication reminders: {str(e)}")
        raise

async def send_reminder(reminder):
    """Send individual reminder message."""
    from ..handlers.chat_handler import ChatHandler
    
    chat_handler = ChatHandler(session_data={}, user_message="", user_id=None)
    message = f"Time to take your {reminder['medication_name']}. Reply 'TAKEN' when done."
    
    await chat_handler.send_message(
        to_number=reminder["phone_number"], 
        message=message
    )

# Add to your CELERYBEAT_SCHEDULE in settings or scheduler config
CELERYBEAT_SCHEDULE = {
    # ... your existing scheduled tasks ...
    'morning-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=9, minute=0)
    },
    'afternoon-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=14, minute=0)
    },
    'evening-medication-reminders': {
        'task': 'views.services.scheduler.process_medication_reminders',
        'schedule': crontab(hour=20, minute=0)
    }
}
print ("37")

================
File: Django_app/chatbot/views/services/session.py
================
import logging
import json
from datetime import datetime, timezone, timedelta
import asyncio
from redis import asyncio as aioredis
from contextlib import asynccontextmanager
from django.conf import settings
from .fhir_service import FHIRService
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)
print ("38")
class SessionManager:
    def __init__(self):
        self._redis_client = None
        self._lock = None  # Initialize in async context
        self.session_timeout = timedelta(minutes=30)
        self.fhir_service = FHIRService()  # Using existing FHIRService
        self.redis_url = getattr(settings, 'REDIS_URL', 'redis://localhost:6379/0')

    def _get_session_key(self, session_id: str) -> str:
        """Get consistent session key format"""
        return f"chat_session:{session_id}"

    async def initialize(self):
        """Initialize session manager for ASGI application"""
        self._lock = asyncio.Lock()
        await self._initialize_redis()

    async def _initialize_redis(self):
        """Initialize Redis connection"""
        try:
            if self._redis_client is None:
                self._redis_client = await aioredis.from_url(
                    self.redis_url,
                    encoding='utf-8',
                    decode_responses=True
                )
        except Exception as e:
            logger.error(f"Redis initialization failed: {e}")
            self._redis_client = None

    async def cleanup(self):
        """Cleanup session manager resources"""
        if self._redis_client:
            await self._redis_client.close()
            self._redis_client = None

    @asynccontextmanager
    async def get_redis(self):
        """Get Redis connection with proper error handling"""
        if self._redis_client is None:
            try:
                async with self._lock:
                    if self._redis_client is None:
                        await self._initialize_redis()
            except Exception as e:
                logger.error(f"Redis connection failed: {e}")
                self._redis_client = None
        
        if self._redis_client is not None:
            try:
                yield self._redis_client
            except Exception as e:
                logger.error(f"Redis operation failed: {e}")
                self._redis_client = None
                raise  # Re-raise to ensure proper error handling
        else:
            yield None

    async def get_session(self, session_id: str) -> Dict[str, Any]:
        """Get existing session or create new one"""
        try:
            # Check in-memory sessions first
            if session_id in SessionManager._memory_sessions:
                logger.info(f"Using in-memory session for {session_id}")
                return SessionManager._memory_sessions[session_id]
        
            async with self.get_redis() as redis:
                if redis is None:
                    logger.warning("Redis connection not available, using in-memory fallback")
                    # Check again for memory sessions
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    # No session found, create default
                    new_session = await self._create_or_verify_session(session_id)
                    SessionManager._memory_sessions[session_id] = new_session
                    return new_session
                
                session_key = self._get_session_key(session_id)
                try:
                    session_data = await redis.get(session_key)
                    if session_data:
                        parsed_session = json.loads(session_data)
                        # Store in memory for faster access
                        SessionManager._memory_sessions[session_id] = parsed_session
                        return parsed_session
                except Exception as e:
                    logger.error(f"Error reading session: {e}")
                    # Check memory fallback
                    if session_id in SessionManager._memory_sessions:
                        return SessionManager._memory_sessions[session_id]
                    raise
                
                # Create new session
                new_session = await self._create_or_verify_session(session_id)
                try:
                    await redis.set(
                        session_key,
                        json.dumps(new_session),
                        ex=int(self.session_timeout.total_seconds())
                    )
                    # Store in memory too
                    SessionManager._memory_sessions[session_id] = new_session
                except Exception as e:
                    logger.error(f"Error saving new session: {e}")
                    # Still store in memory
                    SessionManager._memory_sessions[session_id] = new_session
                return new_session
                
        except Exception as e:
            logger.error(f"Session operation failed: {e}")
            raise

    # In-memory session fallback storage
    _memory_sessions = {}
    
    async def update_session(self, session_id: str, session_data: Dict[str, Any]) -> None:
        """Update existing session"""
        try:
            # Update last interaction time
            session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
            
            async with self.get_redis() as redis:
                if redis is None:
                    # Redis not available, use in-memory storage
                    logger.warning("Redis connection not available, using in-memory storage")
                    # Store in memory
                    SessionManager._memory_sessions[session_id] = session_data
                    return
                
                # Store updated session using consistent key format
                session_key = self._get_session_key(session_id)
                await redis.set(
                    session_key,
                    json.dumps(session_data),
                    ex=int(self.session_timeout.total_seconds())
                )
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            # Fall back to in-memory storage
            SessionManager._memory_sessions[session_id] = session_data

    async def reset_session(self, session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
        """Reset session while optionally preserving patient data"""
        try:
            current_session = await self.get_session(session_id)
            patient_data = current_session.get('patient') if preserve_patient else None
            
            new_session = self._create_default_session(session_id)
            if patient_data:
                new_session['patient'] = patient_data
            
            await self.save_session(session_id, new_session)
            return new_session
            
        except Exception as e:
            logger.error(f"Error resetting session: {e}")
            return self._create_default_session(session_id)

    async def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """Save complete session data"""
        try:
            async with self.get_redis() as redis:
                if redis is None:
                    return False
                
                session_data['last_interaction'] = datetime.now(timezone.utc).isoformat()
                await redis.setex(
                    f"chat_session:{session_id}",
                    int(self.session_timeout.total_seconds()),
                    json.dumps(session_data)
                )
                return True
                
        except aioredis.RedisError as e:
            logger.error(f"Redis error saving session: {e}")
            return False
        except Exception as e:
            logger.error(f"Error saving session: {e}")
            return False

    async def _create_or_verify_session(self, session_id: str) -> Dict[str, Any]:
        """Creates a new session and verifies patient data if email provided"""
        session = self._create_default_session(session_id)
        
        # Verify patient if session_id looks like an email
        if '@' in session_id:
            try:
                patient_data = await self.fhir_service.get_patient_by_email(session_id)
                if patient_data:
                    logger.info(f"Found patient data for {session_id}")
                    session['patient'] = patient_data
            except Exception as e:
                logger.error(f"Error verifying patient: {e}")
        
        return session

    def _create_default_session(self, session_id: str) -> Dict[str, Any]:
        """Create a default session with all required fields"""
        return {
            'id': session_id,
            'greeted': False,
            'booking_state': None,
            'cancellation_options': None,
            'requested_datetime': None,
            'last_interaction': datetime.now(timezone.utc).isoformat(),
            'verified': False,
            'patient': None
        }

    async def _verify_patient(self, session_id):
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                return patient_data
            return None
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return None

    async def verify_patient(self, session_id: str) -> bool:
        """Verify patient exists in FHIR"""
        try:
            patient_data = await self.fhir_service.get_patient_by_email(session_id)
            if patient_data:
                self.session['patient'] = patient_data
                self.session['verified'] = True
                return True
            return False
        except Exception as e:
            logger.error(f"Error verifying patient: {str(e)}")
            return False

# Global instance
session_manager = SessionManager()

# For backwards compatibility with existing imports
async def get_session(session_id: str) -> Dict[str, Any]:
    return await session_manager.get_session(session_id)

async def update_session(session_id: str, updates: Dict[str, Any]) -> bool:
    return await session_manager.update_session(session_id, updates)

async def reset_session(session_id: str, preserve_patient: bool = True) -> Dict[str, Any]:
    return await session_manager.reset_session(session_id, preserve_patient)

async def save_session(session_id: str, session_data: Dict[str, Any]) -> bool:
    return await session_manager.save_session(session_id, session_data)
print ("39")

================
File: Django_app/chatbot/views/services/symptom_guidance_service.py
================
# chatbot/views/services/symptom_guidance_service.py

import logging
from django.conf import settings
import json
from ..utils.formatters import format_message
from .fhir_service import FHIRService
import openai
from datetime import datetime
from asgiref.sync import sync_to_async
from openai import AsyncOpenAI
from ..utils.constants import OPENAI_MODEL

logger = logging.getLogger('chatbot')
class SymptomGuidanceService:
    def __init__(self):
        self.fhir_service = FHIRService()
        self.openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        
        # Define red flag symptoms
        self.RED_FLAGS = {
            'chest_pain': [
                'chest pain', 'chest tightness', 'crushing pain',
                'heart attack', 'cardiac', 'heart pain'
            ],
            'breathing': [
                'cannot breathe', 'difficulty breathing', 'shortness of breath',
                'struggling to breathe', 'gasping', 'choking'
            ],
            'stroke': [
                'face drooping', 'arm weakness', 'speech difficulty',
                'numbness one side', 'sudden confusion', 'sudden dizziness'
            ],
            'consciousness': [
                'unconscious', 'passed out', 'fainting',
                'not responding', 'lost consciousness'
            ],
            'bleeding': [
                'severe bleeding', 'heavy bleeding', 'uncontrolled bleeding',
                'bleeding heavily', 'blood loss'
            ],
            'allergic': [
                'anaphylaxis', 'allergic reaction', 'throat swelling',
                'cannot swallow', 'severe allergy'
            ]
        }
        
        # Risk levels with their descriptions
        self.RISK_LEVELS = {
            'EMERGENCY': {
                'level': 4,
                'action': 'CALL EMERGENCY SERVICES IMMEDIATELY (112 or 999)',
                'urgency': 'Immediate emergency attention required'
            },
            'HIGH': {
                'level': 3,
                'action': 'Seek immediate medical attention or go to the nearest urgent care center',
                'urgency': 'Urgent medical attention recommended'
            },
            'MEDIUM': {
                'level': 2,
                'action': 'Consider visiting urgent care or booking an urgent appointment',
                'urgency': 'Prompt medical attention advised'
            },
            'LOW': {
                'level': 1,
                'action': 'Schedule a routine appointment with your healthcare provider',
                'urgency': 'Non-urgent medical attention'
            }
        }

    async def red_flag_checker(self, symptom_description):
        """
        Check for red flag symptoms that require immediate emergency attention
        Returns: tuple (bool, list of matched red flags)
        """
        try:
            symptom_description = symptom_description.lower()
            matched_flags = []

            for category, phrases in self.RED_FLAGS.items():
                if any(phrase in symptom_description for phrase in phrases):
                    matched_flags.append(category)
                    await sync_to_async(logger.warning)(f"Red flag detected: {category} in symptom: {symptom_description}")

            return bool(matched_flags), matched_flags

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in red flag checking: {str(e)}")
            return True, ['error_defaulting_to_emergency']  # Err on side of caution

    async def symptom_analyzer(self, symptom_description, patient_data=None):
        """
        Analyze symptoms using OpenAI for severity assessment
        Returns: dict with analysis results
        """
        try:
            prompt = await sync_to_async(self._build_analysis_prompt)(symptom_description, patient_data)
            
            response = await self.openai_client.chat.completions.create(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a medical triage assistant. Always err on the side of caution."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3
            )

            analysis = json.loads(response.choices[0].message.content)
            await sync_to_async(logger.info)(f"Symptom analysis completed: {analysis}")
            return analysis

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in symptom analysis: {str(e)}")
            return {
                'severity': 'HIGH',
                'confidence': 0.0,
                'recommendation': 'Due to analysis error, recommending careful evaluation',
                'error': str(e)
            }

    async def risk_level_determiner(self, symptom_analysis, red_flags=None):
        """
        Determine risk level based on symptom analysis and red flags
        Returns: dict with risk assessment
        """
        try:
            if red_flags:
                return {
                    'level': 'EMERGENCY',
                    'action': self.RISK_LEVELS['EMERGENCY']['action'],
                    'urgency': self.RISK_LEVELS['EMERGENCY']['urgency'],
                    'red_flags': red_flags,
                    'timestamp': datetime.utcnow().isoformat()
                }

            # Map severity to risk level
            severity_mapping = {
                'MILD': 'LOW',
                'MODERATE': 'MEDIUM',
                'SEVERE': 'HIGH',
                'CRITICAL': 'EMERGENCY'
            }

            assessed_level = severity_mapping.get(
                symptom_analysis.get('severity', 'SEVERE'),  # Default to SEVERE if unclear
                'HIGH'  # Default to HIGH if mapping fails
            )

            return {
                'level': assessed_level,
                'action': self.RISK_LEVELS[assessed_level]['action'],
                'urgency': self.RISK_LEVELS[assessed_level]['urgency'],
                'confidence': symptom_analysis.get('confidence', 0.0),
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in risk level determination: {str(e)}")
            return {
                'level': 'HIGH',
                'action': self.RISK_LEVELS['HIGH']['action'],
                'urgency': 'Due to assessment error, recommending urgent evaluation',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    async def response_formatter(self, risk_assessment, patient_data=None):
        """
        Format the response based on risk assessment
        Returns: dict with formatted response messages
        """
        try:
            # Standard disclaimer
            disclaimer = (
                "IMPORTANT: This is an automated guidance system and not a medical diagnosis. "
                "If you're unsure or your condition worsens, please seek immediate medical attention."
            )

            # Emergency message template
            if risk_assessment['level'] == 'EMERGENCY':
                messages = [
                    " EMERGENCY MEDICAL ATTENTION RECOMMENDED ",
                    f"ACTION NEEDED: {risk_assessment['action']}",
                    "Key points:",
                    "- Call emergency services (112 or 999) immediately",
                    "- Do not delay seeking help",
                    "- Stay calm and find a safe location",
                    "",
                    disclaimer
                ]

            # High risk message template
            elif risk_assessment['level'] == 'HIGH':
                messages = [
                    " URGENT MEDICAL ATTENTION ADVISED ",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Next steps:",
                    "- Visit your nearest urgent care center",
                    "- If symptoms worsen, call emergency services",
                    "- Keep someone informed of your condition",
                    "",
                    disclaimer
                ]

            # Medium risk message template
            elif risk_assessment['level'] == 'MEDIUM':
                messages = [
                    " MEDICAL ATTENTION RECOMMENDED",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Options:",
                    "- Visit an urgent care center",
                    "- Book an urgent appointment with your doctor",
                    "- Monitor your symptoms closely",
                    "",
                    disclaimer
                ]

            # Low risk message template
            else:
                messages = [
                    " MEDICAL GUIDANCE",
                    f"RECOMMENDATION: {risk_assessment['action']}",
                    "Suggested steps:",
                    "- Book a routine appointment",
                    "- Monitor your symptoms",
                    "- If condition worsens, seek urgent care",
                    "",
                    disclaimer
                ]

            # Add local emergency numbers if available
            if patient_data and 'address' in patient_data:
                country = patient_data['address'][0].get('country', 'Unknown')
                messages.append(f"\nLocal emergency numbers for {country}:")
                if country == "Italy":
                    messages.append("Emergency: 112")
                    messages.append("Medical Emergency: 118")
                elif country == "United Kingdom":
                    messages.append("Emergency: 999 or 112")
                    messages.append("NHS Non-emergency: 111")

            return {
                'messages': messages,
                'risk_level': risk_assessment['level'],
                'timestamp': datetime.utcnow().isoformat()
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error formatting response: {str(e)}")
            return {
                'messages': [
                    " ERROR IN PROCESSING",
                    "For your safety, please seek medical attention or call emergency services if you're concerned.",
                    "",
                    disclaimer
                ],
                'risk_level': 'ERROR',
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat()
            }

    def _build_analysis_prompt(self, symptom_description, patient_data):
        """Helper method to build the analysis prompt"""
        base_prompt = f"""
        Analyze the following symptoms and provide a severity assessment.
        Symptoms: {symptom_description}
        
        Respond in the following JSON format:
        {{
            "severity": "MILD|MODERATE|SEVERE|CRITICAL",
            "confidence": <float 0-1>,
            "recommendation": <string>,
            "key_symptoms": [<list of key symptoms identified>],
            "reasoning": <string explaining assessment>
        }}
        
        Always err on the side of caution. If in doubt, rate severity higher.
        """

        if patient_data:
            # Add relevant patient information to the prompt
            age = None
            if 'birthDate' in patient_data:
                birth_date = datetime.strptime(patient_data['birthDate'], '%Y-%m-%d')
                age = (datetime.now() - birth_date).days // 365

            additional_context = f"""
            Patient Context:
            - Age: {age if age else 'Unknown'} years
            - Gender: {patient_data.get('gender', 'Unknown')}
            """
            base_prompt += additional_context

        return base_prompt

    async def provide_specific_info(self, user_query):
        """
        Provide detailed information addressing the user's specific query.
        Uses OpenAI to generate a structured and informative response.
        """
        try:
            prompt = f"""
            You are a medical information assistant. Provide a detailed, accurate, and easy-to-understand answer to the following question:

            "{user_query}"

            Structure your response with numbered points, covering the following aspects:
            1. Explanation of the condition: what it is, what causes it, how it's transmitted, etc.
            2. Common symptoms.
            3. Diagnostic methods.
            4. Treatment options.
            5. When to seek medical attention.

            Include a disclaimer at the end stating that this information is for educational purposes only and should not replace professional medical advice.
            """

            response = await openai.ChatCompletion.acreate(
                model=OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": "You are a helpful and accurate medical information assistant."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=500
            )

            detailed_info = response.choices[0].message.content.strip()

            return {
                'messages': [detailed_info]
            }

        except Exception as e:
            await sync_to_async(logger.error)(f"Error in provide_specific_info: {str(e)}")
            return {
                'messages': ["I'm sorry, I couldn't retrieve detailed information at this time."]
            }
print ("41")

================
File: Django_app/chatbot/views/utils/constants.py
================
# project/utils/constants.py
from datetime import timedelta

# Business Hours and Time Settings
BUSINESS_HOURS_START = 9
BUSINESS_HOURS_END = 17
DEFAULT_TIMEZONE = "America/New_York"
MAX_FUTURE_BOOKING_DAYS = 90
SLOT_DURATION_MINUTES = 30
SCHEDULE_HORIZON_START = "2024-01-01T00:00:00Z"
SCHEDULE_HORIZON_END = "2050-12-31T23:59:59Z"

# Session Settings
SESSION_EXPIRY_SECONDS = 1800  # 30 minutes
SESSION_KEY_PREFIX = "session:"
SESSION_STORAGE_DAYS = 1  # Store sessions for 1 day

# Appointment Settings
APPOINTMENT_STATUS = {
    'BOOKED': 'booked',
    'PENDING': 'pending',
    'CANCELLED': 'cancelled',
    'COMPLETED': 'completed'
}

APPOINTMENT_TYPES = {
    '1': 'GP',
    '2': 'Nurse',
    '3': 'Specialist'
}

# FHIR Resource Types
RESOURCE_TYPES = {
    'PATIENT': 'Patient',
    'PRACTITIONER': 'Practitioner',
    'APPOINTMENT': 'Appointment',
    'SCHEDULE': 'Schedule',
    'SLOT': 'Slot',
    'CONDITION': 'Condition',
    'MEDICATION': 'MedicationStatement',
    'PROCEDURE': 'Procedure',
    'IMMUNIZATION': 'Immunization',
    'ALLERGY': 'AllergyIntolerance'
}

# Response Messages
MESSAGES = {
    'NO_APPOINTMENTS': "You don't have any upcoming appointments scheduled.",
    'BOOKING_CANCELLED': "Booking cancelled. Is there anything else I can help you with?",
    'VERIFY_IDENTITY': "Please verify your identity first by providing your email address.",
    'INVALID_EMAIL': "I couldn't find your record. Please verify your email address.",
    'SESSION_ERROR': "There was an error with your session. Please try again.",
    'BOOKING_ERROR': "There was an error with your booking. Please try again.",
    'WEEKEND_ERROR': "We are closed on weekends. Please select a weekday.",
    'HOURS_ERROR': "Our hours are 9 AM to 5 PM. Please select a time during business hours.",
    'PAST_DATE_ERROR': "Please select a future date and time.",
    'DATETIME_FORMAT_ERROR': """Could not understand the date/time format. Please try:
        - 'tomorrow at 2pm'
        - 'October 31st at 2pm'
        - 'next Tuesday at 2pm'"""
}

# Search Parameters
SEARCH_ATTEMPTS = [
    {'telecom': "email|{email}"},
    {'email': "{email}"},
    {'telecom': "{email}"},
    {'telecom:contains': "{email}"},
    {'telecom:exact': "email|{email}"}
]

# Intent Detection Settings
INTENT_CONFIDENCE_THRESHOLD = 0.7
MAX_TOKENS = 500
TEMPERATURE = 0

# Logging Settings
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
LOG_LEVEL = 'DEBUG'

# API Settings
OPENAI_MODEL = "gpt-4o-mini"
OPENAI_MAX_RETRIES = 3
OPENAI_TIMEOUT = 30

# Default Mock Patient Data (for testing)
DEFAULT_MOCK_PATIENT = {
    "extension": [
        {
            "url": "http://example.org/fhir/StructureDefinition/height",
            "valueQuantity": {
                "value": 170,
                "unit": "cm"
            }
        },
        {
            "url": "http://example.org/fhir/StructureDefinition/weight",
            "valueQuantity": {
                "value": 70,
                "unit": "kg"
            }
        }
    ]
}

================
File: Django_app/chatbot/views/utils/datetime_utils.py
================
from datetime import datetime, timedelta
from chatbot.views.config import config as app_config
from zoneinfo import ZoneInfo
import re
import dateparser
from datetime import datetime, timedelta, time
import logging
from django.conf import settings
import openai
openai.api_key = settings.OPENAI_API_KEY
# Configure logging
logger = logging.getLogger('chatbot')

from chatbot.views.config import config as app_config

fhir_client = app_config.fhir_client

# Initialize OpenAI client
client = settings.OPENAI_API_KEY


def parse_datetime(text):
    """
    Parse date and time from natural language text.
    Returns tuple of (datetime object, confidence level)
    """
    try:
        # Clean the text
        text = text.lower().strip()
        
        # Get current time in UTC
        now = datetime.now(ZoneInfo("UTC"))
        
        # Handle "tomorrow" explicitly
        if "tomorrow" in text:
            # Start with tomorrow's date
            target_date = now.date() + timedelta(days=1)
            
            # Extract time
            time_match = re.search(r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)', text)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if time_match.group(2) else 0
                if time_match.group(3) == 'pm' and hour != 12:
                    hour += 12
                elif time_match.group(3) == 'am' and hour == 12:
                    hour = 0
                
                # Create datetime with extracted time
                parsed = datetime.combine(
                    target_date, 
                    time(hour=hour, minute=minute), 
                    tzinfo=ZoneInfo("UTC")
                )
                return parsed, 'high'
        
        # For other cases, use dateparser
        parsed = dateparser.parse(text, settings={
            'PREFER_DATES_FROM': 'future',
            'RELATIVE_BASE': now
        })
        
        if parsed:
            # Make timezone-aware if it isn't already
            if parsed.tzinfo is None:
                parsed = parsed.replace(tzinfo=ZoneInfo("UTC"))
            
            # If only date is mentioned (no time), set a default time
            if any(word in text for word in ['am', 'pm', ':']) or 'time' in text:
                return parsed, 'high'
            else:
                # Set default time to 9:00 AM
                parsed = parsed.replace(hour=9, minute=0, second=0, microsecond=0)
                return parsed, 'medium'
                
        return None, 'low'
        
    except Exception as e:
        logger.error(f"Error parsing datetime: {e}")
        return None, 'low'

def get_current_time(timezone='America/New_York'):
    """
    Get the current time in the specified timezone
    """
    try:
        current_time = datetime.now(ZoneInfo(timezone))
        logger.debug(f"Current time in {timezone}: {current_time}")
        return current_time
    except Exception as e:
        logger.error(f"Error getting current time: {e}")
        # Fallback to UTC if there's an error
        fallback_time = datetime.now(timezone.utc)
        logger.warning(f"Falling back to UTC time: {fallback_time}")
        return fallback_time


def format_datetime(datetime_str):
    """
    Converts a datetime string to a more readable format.
    """
    try:
        parsed_datetime = datetime.fromisoformat(datetime_str.rstrip('Z'))
        return parsed_datetime.strftime("%B %d, %Y at %I:%M %p")
    except Exception as e:
        logger.error(f"Error formatting datetime: {e}")
        return datetime_str


def format_datetime_for_user(dt, timezone='America/New_York'):
    """
    Formats a datetime object into a user-friendly string with validation
    """
    if not dt:
        return None
    
    try:
        # Convert to specified timezone
        local_dt = dt.astimezone(ZoneInfo(timezone))
        
        # Format date and time
        date_str = local_dt.strftime("%A, %B %d, %Y")
        time_str = local_dt.strftime("%I:%M %p").lstrip("0")
        
        return f"{date_str} at {time_str}"
    except Exception as e:
        logger.error(f"Error formatting datetime: {e}")
        return None

def format_slot_time(slot):
    """
    Formats a slot's time for display.
    """
    try:
        start_time = datetime.fromisoformat(slot['start'].replace('Z', '+00:00'))
        return start_time.strftime("%B %d, %Y at %I:%M %p")
    except Exception as e:
        logger.error(f"Error formatting slot time: {e}")
        return "Time not available"

================
File: Django_app/chatbot/views/utils/formatters.py
================
from datetime import datetime
from django.conf import settings
from django.urls import resolve
from django.http import HttpRequest
from chatbot.views.config import config as app_config
import json
import logging

logger = logging.getLogger('chatbot')

# Use app_config instead of config
fhir_client = app_config.fhir_client

def get_resource_name(resource):
    """Get the display name of a FHIR resource."""
    if not resource:
        return "Unknown"
    
    if resource.get('name'):
        names = resource['name']
        if isinstance(names, list) and names:
            name = names[0]
            if isinstance(name, dict):
                return name.get('text') or f"{name.get('given', [''])[0]} {name.get('family', '')}"
        elif isinstance(names, dict):
            return names.get('text') or f"{names.get('given', [''])[0]} {names.get('family', '')}"
    
    return f"{resource.get('resourceType', 'Unknown')} {resource.get('id', 'Unknown')}"

def format_medications(medications_entries):
    """Format medications for display"""
    formatted = []
    for entry in medications_entries:
        med = entry.get('resource', {})
        if med:
            medication_name = med.get('medicationCodeableConcept', {}).get('text', 'Unknown Medication')
            dosage = med.get('dosageInstruction', [{}])[0]
            dose = dosage.get('doseAndRate', [{}])[0].get('doseQuantity', {})
            timing = dosage.get('timing', {}).get('repeat', {})
            
            med_str = f"- {medication_name}"
            if dose:
                med_str += f" {dose.get('value', '')} {dose.get('unit', '')}"
            if timing:
                med_str += f" {timing.get('frequency', '')} times per {timing.get('period', '')} {timing.get('periodUnit', '')}"
            
            formatted.append(med_str)
    
    return "\n".join(formatted) if formatted else "No medications found"

def format_appointments(appointment_entries):
    """Format appointments for display"""
    formatted = []
    for entry in appointment_entries:
        appt = entry.get('resource', {})
        if appt and appt.get('status') in ['booked', 'pending']:
            start_time = datetime.fromisoformat(appt['start'].replace('Z', '+00:00'))
            formatted_time = start_time.strftime("%A, %B %d at %I:%M %p")
            
            practitioner_name = "Unknown Provider"
            for participant in appt.get('participant', []):
                if participant.get('actor', {}).get('resourceType') == 'Practitioner':
                    practitioner = fhir_client.read("Practitioner", participant['actor']['reference'].split('/')[-1])
                    if practitioner:
                        practitioner_name = f"Dr. {get_resource_name(practitioner)}"
                    break
            
            appt_str = f"- {formatted_time} with {practitioner_name}"
            if appt.get('description'):
                appt_str += f" ({appt['description']})"
            
            formatted.append(appt_str)
    
    return "\n".join(formatted) if formatted else "No appointments found"
# chatbot/views/utils/formatters.py

def format_message(message, **kwargs):
    """Format messages with given parameters"""
    try:
        if isinstance(message, list):
            return '\n'.join(message)
        return str(message)
    except Exception as e:
        return str(message)
def send_message(message, user_id):
    """Sends a message and retrieves the response from the chat view."""
    try:
        from django.test import RequestFactory
        
        factory = RequestFactory()
        request = factory.post(
            '/chat',
            data=json.dumps({'message': message, 'user_id': user_id}),
            content_type='application/json'
        )

        view_func = resolve('/chat').func
        response = view_func(request)
        
        response_data = json.loads(response.content)
        return response_data.get('messages', ["No response received."])[0]
    except Exception as e:
        logger.error(f"Error in send_message: {str(e)}")
        return "Sorry, I couldn't process that message."

================
File: Django_app/chatbot/views/utils/shared.py
================
# chatbot/views/utils/shared.py
def get_resource_name(resource):
    """Extracts the name from a FHIR resource."""
    if 'name' in resource and len(resource['name']) > 0:
        name_entry = resource['name'][0]
        if 'given' in name_entry and 'family' in name_entry:
            given = " ".join(name_entry.get('given', []))
            family = name_entry.get('family', '')
            return f"{given} {family}".strip()
        elif 'text' in name_entry and name_entry.get('text'):
            return name_entry.get('text').strip()
    return 'Unknown'

================
File: Django_app/chatbot/views/config.py
================
from django.conf import settings
from openai import AsyncOpenAI
from redis import Redis
from redis.asyncio import Redis as AsyncRedis
import logging
from .utils.constants import LOG_FORMAT, LOG_LEVEL, SESSION_EXPIRY_SECONDS
import openai
from fhirclient import client
from fhirclient.server import FHIRServer

# Configure logging
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format=LOG_FORMAT
)
logger = logging.getLogger('chatbot')

class Config:
    def __init__(self):
        self._fhir_client = None
        self._async_fhir_client = None
        self._redis_client = None
        self._async_redis_client = None
        self._openai_client = None
        self.initialize_clients()

    def initialize_clients(self):
        """Initialize all client connections"""
        try:
            # Initialize FHIR client
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            self._fhir_client = client.FHIRClient(settings=settings_dict)
            logger.info("FHIR client initialized successfully")

            # Initialize Redis clients - both sync and async
            self._redis_client = Redis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
            self._async_redis_client = AsyncRedis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
            self._redis_client.ping()  # Test connection
            logger.info("Redis clients initialized successfully")
            
            # Initialize OpenAI client
            self._openai_client = AsyncOpenAI(
                api_key=settings.OPENAI_API_KEY,
                timeout=60.0
            )
            logger.info("OpenAI client initialized successfully")
            
        except Exception as e:
            logger.error(f"Error initializing clients: {str(e)}")
            raise

    async def get_async_fhir_client(self):
        """Get async FHIR server with lazy initialization"""
        if not self._async_fhir_client:
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            smart = client.FHIRClient(settings=settings_dict)
            self._async_fhir_client = smart.server
        return self._async_fhir_client

    def get_fhir_client(self):
        """Get synchronous FHIR server with lazy initialization"""
        if not self._fhir_client:
            settings_dict = {
                'app_id': 'anna_chatbot',
                'api_base': settings.FHIR_SERVER_URL
            }
            smart = client.FHIRClient(settings=settings_dict)
            self._fhir_client = smart.server
        return self._fhir_client

    def get_redis_client(self):
        """Get synchronous Redis client with lazy initialization"""
        if not self._redis_client:
            self._redis_client = Redis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
        return self._redis_client

    def get_async_redis_client(self):
        """Get asynchronous Redis client with lazy initialization"""
        if not self._async_redis_client:
            self._async_redis_client = AsyncRedis(
                host=settings.REDIS_HOST,
                port=settings.REDIS_PORT,
                db=settings.REDIS_DB,
                decode_responses=True
            )
        return self._async_redis_client
        
    def get_openai_client(self):
        """Get OpenAI client with lazy initialization"""
        if not self._openai_client:
            self._openai_client = AsyncOpenAI(
                api_key=settings.OPENAI_API_KEY,
                timeout=60.0
            )
        return self._openai_client

    @property
    def fhir_client(self):
        """Property accessor for FHIR client"""
        return self.get_fhir_client()

    @property
    def redis_client(self):
        """Property accessor for Redis client"""
        return self.get_redis_client()

    @property
    def async_redis_client(self):
        """Property accessor for asynchronous Redis client"""
        return self.get_async_redis_client()

    @property
    def openai_client(self):
        """Property accessor for OpenAI client"""
        return self.get_openai_client()

    def reset_clients(self):
        """Reset all clients - useful for testing or error recovery"""
        self._fhir_client = None
        self._redis_client = None 
        self._async_redis_client = None
        self._openai_client = None
        self.initialize_clients()

# Add to existing config
INTENT_CONFIDENCE_THRESHOLDS = {
    # ... existing thresholds ...
    'lab_results': 0.8,
    'lab_query': 0.7
}

LAB_RESULT_CACHE_DURATION = 3600  # Cache lab results for 1 hour

# Create singleton instance
config = Config()

================
File: Django_app/chatbot/views/utils.py
================
# utils.py
from django.conf import settings
from openai import OpenAI
import redis
import logging

from fhir_client_module import FHIRClient

# Configure logging
logger = logging.getLogger('chatbot')

# Initialize shared clients
fhir_client = FHIRClient(base_url=settings.FHIR_SERVER_URL)
redis_client = redis.StrictRedis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=settings.REDIS_DB,
    decode_responses=True
)
openai_client = OpenAI(api_key=settings.OPENAI_API_KEY)

# Shared utility functions
def get_resource_name(resource):
    """Shared utility to extract name from FHIR resource"""
    if 'name' in resource and len(resource['name']) > 0:
        name_entry = resource['name'][0]
        if 'given' in name_entry and 'family' in name_entry:
            given = " ".join(name_entry.get('given', []))
            family = name_entry.get('family', '')
            return f"{given} {family}".strip()
        elif 'text' in name_entry and name_entry.get('text'):
            return name_entry.get('text').strip()
    return 'Unknown'

================
File: Django_app/chatbot/__init__.py
================
default_app_config = 'chatbot.apps.ChatbotConfig'

================
File: Django_app/chatbot/admin.py
================
# Admin panel configuration

================
File: Django_app/chatbot/apps.py
================
from django.apps import AppConfig

class ChatbotConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chatbot'

    # Comment out the ready method temporarily to test
    # def ready(self):
    #     try:
    #         from chatbot.views.config import config
    #         config.initialize()
    #     except Exception as e:
    #         import logging
    #         logging.error(f"Error initializing chatbot config: {e}")

================
File: Django_app/chatbot/chat_client.py
================
import requests
import json
import argparse

def send_message(message, user_id, verbose=False):
    url = "http://localhost:8000/chatbot/chat/"
    headers = {'Content-Type': 'application/json'}
    data = {'message': message, 'user_id': user_id}
    
    if verbose:
        print(f"DEBUG: Sending request with data: {data}")
    
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        
        if verbose:
            print(f"DEBUG: Response status code: {response.status_code}")
            print(f"DEBUG: Response headers: {response.headers}")
            print(f"DEBUG: Response content: {response.text}")
        
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error sending message: {e}")
        if hasattr(e, 'response') and e.response is not None and verbose:
            print(f"Server response status: {e.response.status_code}")
            print(f"Server response text: {e.response.text}")
        return {"error": "Error communicating with the server."}

def format_response(response):
    """Format the response for clean output"""
    if 'messages' in response:
        return '\n'.join(response['messages'])
    elif 'error' in response:
        return f"Error: {response['error']}"
    else:
        return str(response)

def main():
    parser = argparse.ArgumentParser(description='ANNA Healthcare Chatbot Client')
    parser.add_argument('--verbose', '-v', action='store_true', help='Enable verbose debug output')
    parser.add_argument('--user', '-u', type=str, default='test', help='User ID for the session')
    args = parser.parse_args()
    
    print("Chat with ANNA Healthcare Assistant (type 'exit' or 'quit' to stop)")
    user_id = args.user

    while True:
        user_input = input("\nYou: ").strip()
        if user_input.lower() in ('exit', 'quit'):
            break

        response = send_message(user_input, user_id, args.verbose)
        print(f"\nAnna: {format_response(response)}")

if __name__ == "__main__":
    main()

================
File: Django_app/chatbot/f&f_creation.py
================
import json
from fhirclient import client
from fhirclient.models.patient import Patient
from fhirclient.models.humanname import HumanName
from fhirclient.models.address import Address
from fhirclient.models.contactpoint import ContactPoint
from fhirclient.models.extension import Extension
from fhirclient.models.quantity import Quantity
from fhirclient.models.condition import Condition
from fhirclient.models.immunization import Immunization
from fhirclient.models.procedure import Procedure
from fhirclient.models.medicationstatement import MedicationStatement
from fhirclient.models.codeableconcept import CodeableConcept
from fhirclient.models.coding import Coding
from fhirclient.models.fhirreference import FHIRReference
from fhirclient.models.fhirdate import FHIRDate
from fhirclient.models.fhirdatetime import FHIRDateTime
from fhirclient.models.dosage import Dosage
from fhirclient.models.timing import Timing, TimingRepeat
from fhirclient.models.observation import Observation, ObservationReferenceRange


# -----------------------------
# Configuration for FHIR client
# -----------------------------

settings = {
    'app_id': 'chatbot',  # Replace with your app ID
    'api_base': 'http://localhost:8080/fhir'  # Replace with your FHIR server base URL
}

# Initialize FHIR client
smart = client.FHIRClient(settings=settings)

def create_patient():
    # -----------------------------
    # 1. Basic Patient Information
    # -----------------------------

    # Create a new Patient instance
    patient = Patient()

    # Name
    name = HumanName()
    name.given = ['Rodrigo']          # First name
    name.family = 'Agag'          # Last name
    patient.name = [name]

    # Email
    email_contact = ContactPoint()
    email_contact.system = 'email'
    email_contact.value = 'agagrodrigo@gmail.com'
    patient.telecom = [email_contact]

    # Phone Number
    phone_contact = ContactPoint()
    phone_contact.system = 'phone'
    phone_contact.value = '+44 7900 964443'
    patient.telecom.append(phone_contact)

    # Address
    address = Address()
    address.line = ['Via Arcangelo Corelli 3']  # Street address
    address.city = 'Rome'                 # City
    address.state = 'Rome'                # State
    address.postalCode = '00185'            # Postal Code
    address.country = 'Italy'                # Country
    patient.address = [address]

    # Gender
    patient.gender = 'male'

    # Birth Date
    patient.birthDate = FHIRDate('2005-12-13')  # Correctly using FHIRDate

    # -----------------------------
    # 2. Physical Attributes
    # -----------------------------

    # Height Extension
    height_extension = Extension()
    height_extension.url = 'http://example.org/fhir/StructureDefinition/height'
    height_quantity = Quantity()
    height_quantity.value = 175  # Height value
    height_quantity.unit = 'cm'   # Height unit
    height_quantity.system = 'http://unitsofmeasure.org'
    height_quantity.code = 'cm'
    height_extension.valueQuantity = height_quantity
    patient.extension = [height_extension]

    # Weight Extension
    weight_extension = Extension()
    weight_extension.url = 'http://example.org/fhir/StructureDefinition/weight'
    weight_quantity = Quantity()
    weight_quantity.value = 60   # Weight value
    weight_quantity.unit = 'kg'  # Weight unit
    weight_quantity.system = 'http://unitsofmeasure.org'
    weight_quantity.code = 'kg'
    weight_extension.valueQuantity = weight_quantity
    patient.extension.append(weight_extension)

    # -----------------------------
    # 3. Uploading Patient to FHIR Server
    # -----------------------------

    # Create the patient on the FHIR server
    try:
        created_patient = patient.create(smart.server)
        print(f"Raw response from create(): {created_patient}")

        # Determine if 'created_patient' is a dict or a Patient object
        if isinstance(created_patient, dict):
            patient_id = created_patient.get('id')
            if not patient_id:
                print("Error: Patient ID not found in the response.")
                return
        else:
            patient_id = created_patient.id

        print(f"Patient created with ID: {patient_id}")
    except Exception as e:
        print(f"Error creating patient: {e}")
        return

    # -----------------------------
    # 4. Adding Medical Information
    # -----------------------------

    # 4.1. Conditions
    conditions = [
        {
            'code': {
                'coding': [
                    {
                        'system': 'http://snomed.info/sct',
                        'code': '44054006',  # SNOMED code for Small penis syndrome
                        'display': 'Athsma'
                    }
                ]
            },
            'clinicalStatus': {
                'coding': [
                    {
                        'system': 'http://terminology.hl7.org/CodeSystem/condition-clinical',
                        'code': 'active',
                        'display': 'Active'
                    }
                ]
            },
            'verificationStatus': {
                'coding': [
                    {
                        'system': 'http://terminology.hl7.org/CodeSystem/condition-ver-status',
                        'code': 'confirmed',
                        'display': 'Confirmed'
                    }
                ]
            }
        },
        {
            'code': {
                'coding': [
                    {
                        'system': 'http://snomed.info/sct',
                        'code': '195967001',  # SNOMED code for Hayfever
                        'display': 'Hayfever'
                    }
                ]
            },
            'clinicalStatus': {
                'coding': [
                    {
                        'system': 'http://terminology.hl7.org/CodeSystem/condition-clinical',
                        'code': 'active',
                        'display': 'Active'
                    }
                ]
            },
            'verificationStatus': {
                'coding': [
                    {
                        'system': 'http://terminology.hl7.org/CodeSystem/condition-ver-status',
                        'code': 'confirmed',
                        'display': 'Confirmed'
                    }
                ]
            }
        }
    ]

    for cond in conditions:
        condition = Condition()
        
        # Setting the subject using FHIRReference
        condition.subject = FHIRReference()
        condition.subject.reference = f'Patient/{patient_id}'
        
        # Setting the code using CodeableConcept and Coding
        codeable_concept = CodeableConcept()
        coding = Coding()
        coding.system = cond['code']['coding'][0]['system']
        coding.code = cond['code']['coding'][0]['code']
        coding.display = cond['code']['coding'][0]['display']
        codeable_concept.coding = [coding]
        condition.code = codeable_concept
        
        # Setting clinicalStatus
        clinical_status = CodeableConcept()
        clinical_coding = Coding()
        clinical_coding.system = cond['clinicalStatus']['coding'][0]['system']
        clinical_coding.code = cond['clinicalStatus']['coding'][0]['code']
        clinical_coding.display = cond['clinicalStatus']['coding'][0]['display']
        clinical_status.coding = [clinical_coding]
        condition.clinicalStatus = clinical_status
        
        # Setting verificationStatus
        verification_status = CodeableConcept()
        verification_coding = Coding()
        verification_coding.system = cond['verificationStatus']['coding'][0]['system']
        verification_coding.code = cond['verificationStatus']['coding'][0]['code']
        verification_coding.display = cond['verificationStatus']['coding'][0]['display']
        verification_status.coding = [verification_coding]
        condition.verificationStatus = verification_status

        try:
            condition.create(smart.server)
            print(f"Condition '{cond['code']['coding'][0]['display']}' created.")
        except Exception as e:
            print(f"Error creating condition '{cond['code']['coding'][0]['display']}': {e}")

    # 4.2. Vaccines (Immunizations)
    immunizations = [
        {
            'vaccineCode': {
                'coding': [
                    {
                        'system': 'http://hl7.org/fhir/sid/cvx',
                        'code': '207',  # CVX code for Influenza
                        'display': 'Influenza'
                    }
                ]
            },
            'status': 'completed',
            'date': '2023-10-10'
        },
        {
            'vaccineCode': {
                'coding': [
                    {
                        'system': 'http://hl7.org/fhir/sid/cvx',
                        'code': '208',  # CVX code for Pneumococcal
                        'display': 'Pneumococcal'
                    }
                ]
            },
            'status': 'completed',
            'date': '2023-09-15'
        },
        {
            'vaccineCode': {
                'coding': [
                    {
                        'system': 'http://hl7.org/fhir/sid/cvx',
                        'code': '206',  # CVX code for Tetanus
                        'display': 'Tetanus'
                    }
                ]
            },
            'status': 'completed',
            'date': '2023-08-20'
        }
    ]

    for imm in immunizations:
        immunization = Immunization()
        
        # Setting the patient using FHIRReference
        immunization.patient = FHIRReference()
        immunization.patient.reference = f'Patient/{patient_id}'
        
        # Setting the vaccineCode using CodeableConcept and Coding
        vaccine_codeable_concept = CodeableConcept()
        vaccine_coding = Coding()
        vaccine_coding.system = imm['vaccineCode']['coding'][0]['system']
        vaccine_coding.code = imm['vaccineCode']['coding'][0]['code']
        vaccine_coding.display = imm['vaccineCode']['coding'][0]['display']
        vaccine_codeable_concept.coding = [vaccine_coding]
        immunization.vaccineCode = vaccine_codeable_concept
        
        # Setting status
        immunization.status = imm['status']
        
        # Setting date using FHIRDateTime
        immunization.occurrenceDateTime = FHIRDateTime(imm['date'])

        try:
            immunization.create(smart.server)
            print(f"Immunization '{imm['vaccineCode']['coding'][0]['display']}' created.")
        except Exception as e:
            print(f"Error creating immunization '{imm['vaccineCode']['coding'][0]['display']}': {e}")

    # 4.3. Past Procedures
    procedures = [
        {
            'code': {
                'coding': [
                    {
                        'system': 'http://snomed.info/sct',
                        'code': '80146002',  # SNOMED code for Appendectomy
                        'display': 'Elbow dislocation'
                    }
                ]
            },
            'status': 'completed',
            'date': '2022-05-20'
        },
        {
            'code': {
                'coding': [
                    {
                        'system': 'http://snomed.info/sct',
                        'code': '108252007',  # SNOMED code for Root canal surgery
                        'display': 'Root canal surgery'
                    }
                ]
            },
            'status': 'completed',
            'date': '2021-11-10'
        }
    ]

    for proc in procedures:
        procedure = Procedure()
        
        # Setting the subject using FHIRReference
        procedure.subject = FHIRReference()
        procedure.subject.reference = f'Patient/{patient_id}'
        
        # Setting the code using CodeableConcept and Coding
        procedure_codeable_concept = CodeableConcept()
        procedure_coding = Coding()
        procedure_coding.system = proc['code']['coding'][0]['system']
        procedure_coding.code = proc['code']['coding'][0]['code']
        procedure_coding.display = proc['code']['coding'][0]['display']
        procedure_codeable_concept.coding = [procedure_coding]
        procedure.code = procedure_codeable_concept
        
        # Setting status
        procedure.status = proc['status']
        
        # Setting performedDateTime using FHIRDateTime
        procedure.performedDateTime = FHIRDateTime(proc['date'])

        try:
            procedure.create(smart.server)
            print(f"Procedure '{proc['code']['coding'][0]['display']}' created.")
        except Exception as e:
            print(f"Error creating procedure '{proc['code']['coding'][0]['display']}': {e}")

    # 4.4. Current Medications
    medications = [
        {
            'medicationCodeableConcept': {
                'coding': [
                    {
                        'system': 'http://www.nlm.nih.gov/research/umls/rxnorm',
                        'code': '1049630',  # RxNorm code for Salbutamol
                        'display': 'Salbutamol'
                    }
                ]
            },
            'status': 'active',
            'effectiveDateTime': '2023-07-01',
            'dosage': {
                'text': '500mg twice a day',
                'timing': {
                    'repeat': {
                        'frequency': 2,
                        'period': 1,
                        'periodUnit': 'd'
                    }
                },
                'doseQuantity': {
                    'value': 500,
                    'unit': 'mg',
                    'system': 'http://unitsofmeasure.org',
                    'code': 'mg'
                }
            }
        },
        {
            'medicationCodeableConcept': {
                'coding': [
                    {
                        'system': 'http://www.nlm.nih.gov/research/umls/rxnorm',
                        'code': '860975',  # RxNorm code for Lisinopril
                        'display': 'Lisinopril'
                    }
                ]
            },
            'status': 'active',
            'effectiveDateTime': '2023-07-01',
            'dosage': {
                'text': '10mg once a day',
                'timing': {
                    'repeat': {
                        'frequency': 1,
                        'period': 1,
                        'periodUnit': 'd'
                    }
                },
                'doseQuantity': {
                    'value': 10,
                    'unit': 'mg',
                    'system': 'http://unitsofmeasure.org',
                    'code': 'mg'
                }
            }
        }
    ]

    for med in medications:
        medication_statement = MedicationStatement()
        
        # Set subject reference
        medication_statement.subject = FHIRReference()
        medication_statement.subject.reference = f'Patient/{patient_id}'
        
        # Set medication code
        medication_codeable_concept = CodeableConcept()
        medication_coding = Coding()
        medication_coding.system = med['medicationCodeableConcept']['coding'][0]['system']
        medication_coding.code = med['medicationCodeableConcept']['coding'][0]['code']
        medication_coding.display = med['medicationCodeableConcept']['coding'][0]['display']
        medication_codeable_concept.coding = [medication_coding]
        medication_statement.medicationCodeableConcept = medication_codeable_concept
        
        medication_statement.status = med['status']
        medication_statement.effectiveDateTime = FHIRDateTime(med['effectiveDateTime'])

        # Create dosage
        dosage = Dosage()
        dosage.text = med['dosage']['text']
        
        # Fix: Create proper TimingRepeat object
        timing = Timing()
        repeat = TimingRepeat()
        repeat.frequency = med['dosage']['timing']['repeat']['frequency']
        repeat.period = med['dosage']['timing']['repeat']['period']
        repeat.periodUnit = med['dosage']['timing']['repeat']['periodUnit']
        timing.repeat = repeat
        dosage.timing = timing
        
        # Set doseQuantity
        dose_quantity = Quantity()
        dose_quantity.value = med['dosage']['doseQuantity']['value']
        dose_quantity.unit = med['dosage']['doseQuantity']['unit']
        dose_quantity.system = med['dosage']['doseQuantity']['system']
        dose_quantity.code = med['dosage']['doseQuantity']['code']
        dosage.doseQuantity = dose_quantity
        
        medication_statement.dosage = [dosage]

        try:
            medication_statement.create(smart.server)
            print(f"Medication '{med['medicationCodeableConcept']['coding'][0]['display']}' created.")
        except Exception as e:
            print(f"Error creating medication '{med['medicationCodeableConcept']['coding'][0]['display']}': {e}")

    # 4.5. Blood Test Results (Laboratory Observations)
    blood_tests = [
        {
            'date': '2023-11-15',
            'category': 'Complete Blood Count (CBC)',
            'components': [
                {
                    'code': '718-7',
                    'display': 'Hemoglobin',
                    'value': 14.2,
                    'unit': 'g/dL',
                    'reference_range': '13.5-17.5',
                    'interpretation': 'normal'
                },
                {
                    'code': '789-8',
                    'display': 'Red Blood Cells',
                    'value': 4.8,
                    'unit': 'x10^12/L',
                    'reference_range': '4.5-5.9',
                    'interpretation': 'normal'
                },
                {
                    'code': '6690-2',
                    'display': 'White Blood Cells',
                    'value': 7.2,
                    'unit': 'x10^9/L',
                    'reference_range': '4.0-11.0',
                    'interpretation': 'normal'
                },
                {
                    'code': '777-3',
                    'display': 'Platelets',
                    'value': 250,
                    'unit': 'x10^9/L',
                    'reference_range': '150-450',
                    'interpretation': 'normal'
                }
            ]
        },
        {
            'date': '2023-11-15',
            'category': 'Comprehensive Metabolic Panel (CMP)',
            'components': [
                {
                    'code': '2345-7',
                    'display': 'Glucose',
                    'value': 95,
                    'unit': 'mg/dL',
                    'reference_range': '70-100',
                    'interpretation': 'normal'
                },
                {
                    'code': '2160-0',
                    'display': 'Creatinine',
                    'value': 0.9,
                    'unit': 'mg/dL',
                    'reference_range': '0.6-1.2',
                    'interpretation': 'normal'
                },
                {
                    'code': '3094-0',
                    'display': 'Blood Urea Nitrogen',
                    'value': 15,
                    'unit': 'mg/dL',
                    'reference_range': '7-20',
                    'interpretation': 'normal'
                },
                {
                    'code': '2093-3',
                    'display': 'Cholesterol',
                    'value': 180,
                    'unit': 'mg/dL',
                    'reference_range': '< 200',
                    'interpretation': 'normal'
                }
            ]
        },
        {
            'date': '2023-11-15',
            'category': 'Thyroid Function Tests',
            'components': [
                {
                    'code': '3016-3',
                    'display': 'TSH',
                    'value': 2.5,
                    'unit': 'mIU/L',
                    'reference_range': '0.4-4.0',
                    'interpretation': 'normal'
                },
                {
                    'code': '3026-2',
                    'display': 'T4 (Thyroxine)',
                    'value': 1.2,
                    'unit': 'ng/dL',
                    'reference_range': '0.8-1.8',
                    'interpretation': 'normal'
                },
                {
                    'code': '3051-0',
                    'display': 'T3 (Triiodothyronine)',
                    'value': 120,
                    'unit': 'ng/dL',
                    'reference_range': '80-200',
                    'interpretation': 'normal'
                }
            ]
        }
    ]

    for test in blood_tests:
        for component in test['components']:
            observation = Observation()
            
            # Set subject reference
            observation.subject = FHIRReference()
            observation.subject.reference = f'Patient/{patient_id}'
            
            # Set category
            category = CodeableConcept()
            category_coding = Coding()
            category_coding.system = 'http://terminology.hl7.org/CodeSystem/observation-category'
            category_coding.code = 'laboratory'
            category_coding.display = 'Laboratory'
            category.coding = [category_coding]
            category.text = test['category']
            observation.category = [category]
            
            # Set code (what is being measured)
            code = CodeableConcept()
            code_coding = Coding()
            code_coding.system = 'http://loinc.org'
            code_coding.code = component['code']
            code_coding.display = component['display']
            code.coding = [code_coding]
            observation.code = code
            
            # Set value
            value_quantity = Quantity()
            value_quantity.value = component['value']
            value_quantity.unit = component['unit']
            value_quantity.system = 'http://unitsofmeasure.org'
            value_quantity.code = component['unit']
            observation.valueQuantity = value_quantity
            
            # Set status
            observation.status = 'final'
            
            # Set effective date/time
            observation.effectiveDateTime = FHIRDateTime(test['date'])
            
            # Set reference range
            reference_range = ObservationReferenceRange()
            reference_range.text = component['reference_range']
            observation.referenceRange = [reference_range]
            
            # Set interpretation
            interpretation = CodeableConcept()
            interpretation_coding = Coding()
            interpretation_coding.system = 'http://terminology.hl7.org/CodeSystem/v3-ObservationInterpretation'
            interpretation_coding.code = component['interpretation']
            interpretation_coding.display = component['interpretation'].capitalize()
            interpretation.coding = [interpretation_coding]
            observation.interpretation = [interpretation]

            try:
                observation.create(smart.server)
                print(f"Blood test result '{component['display']}' created.")
            except Exception as e:
                print(f"Error creating blood test result '{component['display']}': {e}")

    print("All patient data uploaded successfully.")

if __name__ == "__main__":
    create_patient()

================
File: Django_app/chatbot/middleware.py
================
from django.middleware.csrf import CsrfViewMiddleware

class CustomCsrfMiddleware(CsrfViewMiddleware):
    def process_view(self, request, callback, callback_args, callback_kwargs):
        if request.path == '/chatbot/chat/':
            return None  # Skip CSRF check for this path
        return super().process_view(request, callback, callback_args, callback_kwargs)

================
File: Django_app/chatbot/models.py
================
# Models for your app
# chatbot/models.py
from django.db import models

class Patient(models.Model):
    name = models.CharField(max_length=255)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15)
    discharge_date = models.DateTimeField(null=True, blank=True)  # New field

    def __str__(self):
        return f"{self.name} ({self.email})"

================
File: Django_app/chatbot/new_intent_test.py
================
import asyncio
import json
import os
import sys
import logging
import django
from django.conf import settings

# Add the Django_app directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Configure Django settings
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
django.setup()

from chatbot.views.services.intent_service import detect_intent

# Configure logging for better clarity
logging.basicConfig(level=logging.DEBUG)

async def run_tests():
    # A variety of test inputs simulating different user queries:
    test_messages = [
        "I would like to book an appointment next Monday at 2pm",
        "Show me my upcoming appointments",
        "I have severe chest pain and difficulty breathing",
        "What are the side effects of my current medication?",
        "Can I see my medical records?",
        "Explain my blood test results from last month",
        "How do I manage my diabetes?",
        "I want to cancel my appointment on December 9th",
        "What screenings should I get at age 45?",
        "help",
        "delete context"
    ]

    # Context simulation
    dummy_context = {
        'booking_state': None,
        'last_intent': None,
        'conversation_history': []
    }

    for message in test_messages:
        print(f"\n--- Testing message: '{message}' ---")
        intent_data = await detect_intent(message, dummy_context)
        print("Detected Intent Data:")
        print(json.dumps(intent_data, indent=2))

if __name__ == '__main__':
    asyncio.run(run_tests())

================
File: Django_app/chatbot/tasks.py
================
from celery import shared_task
from chatbot.views.services.fhir_service import get_fhir_client
from chatbot.views.services.preventive_care_reminder_service import PreventiveCareReminderService, send_sms
import logging

logger = logging.getLogger('chatbot')

@shared_task
def process_preventive_care_reminders():
    try:
        fhir_client = get_fhir_client()
        reminder_service = PreventiveCareReminderService(fhir_client, send_sms)
        reminder_service.process_reminders()
        logger.info("Preventive care reminders processed successfully.")
    except Exception as e:
        logger.error(f"Error processing preventive care reminders: {e}")
# chatbot/tasks.py
from celery import shared_task
from chatbot.views.services.medication_service import (
    MedicationAdherenceReminderService,
    get_fhir_client,
    send_sms,
)

@shared_task
def process_medication_reminders_task():
    """
    Celery task to process medication adherence and refill reminders.
    This task instantiates the service and runs the process_medication_reminders() method.
    """
    fhir_client = get_fhir_client()
    reminder_service = MedicationAdherenceReminderService(fhir_client, send_sms)
    reminder_service.process_medication_reminders()

================
File: Django_app/chatbot/test_sms.py
================
# test_sms.py
from twilio.rest import Client
import os

# Your Twilio Account SID and Auth Token
account_sid = 'your_account_sid'
auth_token = 'your_auth_token'

client = Client(account_sid, auth_token)

message = client.messages.create(
    body="Test message",
    from_='+14243532443',  # Your Twilio number
    to='+393341913506'     # Your UK number
)

print(f"Message SID: {message.sid}")

================
File: Django_app/chatbot/upload_test_results.py
================
import json
from datetime import datetime, timedelta, timezone
from fhirclient import client
from fhirclient.models.patient import Patient
from fhirclient.models.observation import Observation, ObservationReferenceRange
from fhirclient.models.diagnosticreport import DiagnosticReport
from fhirclient.models.fhirdate import FHIRDate
from fhirclient.models.fhirdatetime import FHIRDateTime
from fhirclient.models.fhirinstant import FHIRInstant  # Correct import
from fhirclient.models.fhirreference import FHIRReference
from fhirclient.models.quantity import Quantity
from fhirclient.models.codeableconcept import CodeableConcept
from fhirclient.models.coding import Coding
from fhirclient.models.organization import Organization
from fhirclient.models.practitioner import Practitioner
from fhirclient.models.address import Address
from fhirclient.models.humanname import HumanName
from fhirclient.models.reference import Reference

# -----------------------------
# Configuration
# -----------------------------

settings = {
    'app_id': 'anna_test_results_uploader',
    'api_base': 'http://localhost:8080/fhir'  # Replace with your FHIR server URL
}

smart = client.FHIRClient(settings=settings)
PATIENT_ID = '48837'  # Replace with your actual Patient ID

# Test dates (most recent to oldest) with full datetime and timezone, without microseconds
TEST_DATES = {
    'recent': (datetime.now(timezone.utc) - timedelta(days=7)).replace(microsecond=0).isoformat(),
    'previous': (datetime.now(timezone.utc) - timedelta(days=180)).replace(microsecond=0).isoformat(),
    'baseline': (datetime.now(timezone.utc) - timedelta(days=365)).replace(microsecond=0).isoformat()
}

# -----------------------------
# Reference Data
# -----------------------------

LAB_INFO = {
    'name': 'Rome Medical Laboratory',
    'address': {
        'line': ['Via Roma 123'],
        'city': 'Rome',
        'country': 'Italy',
        'postalCode': '00184'
    },
    # 'id': 'lab001'  # Removed to let server assign ID
}

PRACTITIONER_INFO = {
    'name': {
        'given': ['Maria'],
        'family': 'Rossi'
    },
    # 'id': 'pract001',  # Removed to let server assign ID
    'qualification': 'MD Clinical Pathologist'
}

# -----------------------------
# Test Definitions
# -----------------------------

CBC_PANEL = {
    'hemoglobin': {
        'code': '718-7',
        'display': 'Hemoglobin [Mass/volume] in Blood',
        'unit': 'g/dL',
        'reference_range': {'low': 12.0, 'high': 15.5},
        'values': {'recent': 13.5, 'previous': 13.2, 'baseline': 13.8}
    },
    'wbc': {
        'code': '6690-2',
        'display': 'Leukocytes [#/volume] in Blood by Automated count',
        'unit': '10^3/uL',
        'reference_range': {'low': 4.5, 'high': 11.0},
        'values': {'recent': 6.8, 'previous': 7.2, 'baseline': 6.5}
    },
    'platelets': {
        'code': '777-3',
        'display': 'Platelets [#/volume] in Blood by Automated count',
        'unit': '10^3/uL',
        'reference_range': {'low': 150, 'high': 450},
        'values': {'recent': 250, 'previous': 265, 'baseline': 280}
    }
}

METABOLIC_PANEL = {
    'glucose': {
        'code': '2345-7',
        'display': 'Glucose [Mass/volume] in Blood',
        'unit': 'mg/dL',
        'reference_range': {'low': 70, 'high': 100},
        'values': {'recent': 90, 'previous': 88, 'baseline': 85}
    },
    'creatinine': {
        'code': '2160-0',
        'display': 'Creatinine [Mass/volume] in Serum or Plasma',
        'unit': 'mg/dL',
        'reference_range': {'low': 0.7, 'high': 1.3},
        'values': {'recent': 0.9, 'previous': 0.85, 'baseline': 0.88}
    },
    'potassium': {
        'code': '2823-3',
        'display': 'Potassium [Moles/volume] in Serum or Plasma',
        'unit': 'mmol/L',
        'reference_range': {'low': 3.5, 'high': 5.0},
        'values': {'recent': 4.2, 'previous': 4.0, 'baseline': 4.1}
    }
}

LIPID_PANEL = {
    'cholesterol': {
        'code': '2093-3',
        'display': 'Cholesterol [Mass/volume] in Serum or Plasma',
        'unit': 'mg/dL',
        'reference_range': {'low': 0, 'high': 200},
        'values': {'recent': 170, 'previous': 175, 'baseline': 180}
    },
    'triglycerides': {
        'code': '2571-8',
        'display': 'Triglycerides [Mass/volume] in Serum or Plasma',
        'unit': 'mg/dL',
        'reference_range': {'low': 0, 'high': 150},
        'values': {'recent': 120, 'previous': 130, 'baseline': 125}
    },
    'hdl': {
        'code': '2085-9',
        'display': 'HDL Cholesterol',
        'unit': 'mg/dL',
        'reference_range': {'low': 40, 'high': 60},
        'values': {'recent': 45, 'previous': 43, 'baseline': 44}
    }
}

# -----------------------------
# Helper Functions
# -----------------------------

def create_enhanced_observation(patient, test_info, test_date, test_type):
    """Create an enhanced Observation with more metadata."""
    observation = Observation()
    
    # Basic information
    observation.status = 'final'
    
    # Category
    category_coding = Coding()
    category_coding.system = "http://terminology.hl7.org/CodeSystem/observation-category"
    category_coding.code = "laboratory"
    
    category = CodeableConcept()
    category.coding = [category_coding]
    observation.category = [category]
    
    # Code
    code_coding = Coding()
    code_coding.system = "http://loinc.org"
    code_coding.code = test_info['code']
    code_coding.display = test_info['display']
    
    code = CodeableConcept()
    code.coding = [code_coding]
    observation.code = code
    
    # Subject (using FHIRReference)
    observation.subject = FHIRReference({'reference': f'Patient/{patient.id}'})
    
    # Effective date (using FHIRDateTime)
    observation.effectiveDateTime = FHIRDateTime(test_date)
    
    # Value (using Quantity)
    value_quantity = Quantity()
    value_quantity.value = test_info['values'][test_type]
    value_quantity.unit = test_info['unit']
    value_quantity.system = 'http://unitsofmeasure.org'
    value_quantity.code = test_info['unit']
    observation.valueQuantity = value_quantity
    
    # Reference ranges (using ObservationReferenceRange)
    reference_range = ObservationReferenceRange()
    
    low_quantity = Quantity()
    low_quantity.value = test_info['reference_range']['low']
    low_quantity.unit = test_info['unit']
    reference_range.low = low_quantity
    
    high_quantity = Quantity()
    high_quantity.value = test_info['reference_range']['high']
    high_quantity.unit = test_info['unit']
    reference_range.high = high_quantity
    
    observation.referenceRange = [reference_range]
    
    return observation

def create_enhanced_diagnostic_report(patient, observations, code, test_date, lab_org_id, practitioner_id):
    """Create an enhanced DiagnosticReport with more metadata."""
    report = DiagnosticReport()
    
    # Basic information
    report.status = 'final'
    
    # Category with proper CodeableConcept
    category_coding = Coding()
    category_coding.system = "http://terminology.hl7.org/CodeSystem/v2-0074"
    category_coding.code = "LAB"
    
    category = CodeableConcept()
    category.coding = [category_coding]
    report.category = [category]
    
    # Code with proper CodeableConcept
    code_coding = Coding()
    code_coding.system = "http://loinc.org"
    code_coding.code = code['coding'][0]['code']
    code_coding.display = code['coding'][0]['display']
    
    code_concept = CodeableConcept()
    code_concept.coding = [code_coding]
    report.code = code_concept
    
    # Subject and dates
    report.subject = FHIRReference({'reference': f'Patient/{patient.id}'})
    report.effectiveDateTime = FHIRDateTime(test_date)
    report.issued = FHIRInstant(test_date)  # Correct assignment
    
    # Results
    report.result = [FHIRReference({'reference': f'Observation/{obs.id}'}) for obs in observations]
    
    # Performer
    report.performer = [
        FHIRReference({'reference': f'Organization/{lab_org_id}'}),
        FHIRReference({'reference': f'Practitioner/{practitioner_id}'})
    ]
    
    # Conclusion
    report.conclusion = "All results within normal range."
    
    return report

def upload_test_series(patient, panel_data, panel_name, test_date, date_type, lab_org_id, practitioner_id):
    """Upload a series of tests as Observations and a DiagnosticReport."""
    try:
        observations = []
        for test_name, test_info in panel_data.items():
            try:
                observation = create_enhanced_observation(patient, test_info, test_date, test_type=date_type)
                observation_response = observation.create(smart.server)
                # Extracting the ID from the response
                if isinstance(observation_response, dict):
                    obs_id = observation_response.get('id')
                else:
                    obs_id = observation_response.id
                if not obs_id:
                    raise ValueError("No ID returned for Observation.")
                print(f"Uploaded {panel_name} Observation: {test_name} with ID {obs_id}")
                # Assign the ID back to the observation for referencing
                observation.id = obs_id
                observations.append(observation)
            except Exception as e:
                print(f"Error creating observation for {test_name}: {str(e)}")
                continue
        
        if observations:  # Only create report if we have observations
            # Define proper LOINC codes for panels
            panel_loinc_codes = {
                'CBC': '57021-8',        # Complete Blood Count
                'METABOLIC': '24323-8',  # Basic Metabolic Panel
                'LIPID': '5768-6'        # Lipid Panel
            }
            
            if panel_name not in panel_loinc_codes:
                print(f"Unknown panel name: {panel_name}. Skipping DiagnosticReport creation.")
                return
            
            # Create the code structure for the diagnostic report
            report_code = {
                'coding': [{
                    'system': 'http://loinc.org',
                    'code': panel_loinc_codes[panel_name],
                    'display': f'{panel_name} Panel Results'
                }]
            }
            
            report = create_enhanced_diagnostic_report(
                patient=patient,
                observations=observations,
                code=report_code,
                test_date=test_date,
                lab_org_id=lab_org_id,
                practitioner_id=practitioner_id
            )
            report_response = report.create(smart.server)
            # Extracting the ID from the response
            if isinstance(report_response, dict):
                report_id = report_response.get('id')
            else:
                report_id = report_response.id
            if not report_id:
                raise ValueError("No ID returned for DiagnosticReport.")
            print(f"Uploaded {panel_name} DiagnosticReport with ID {report_id}")
    except Exception as e:
        print(f"Error in upload_test_series for {panel_name}: {str(e)}")

def get_patient(patient_id):
    """Retrieve a patient by ID from the FHIR server."""
    try:
        patient = Patient.read(patient_id, smart.server)
        if patient:
            print(f"Found patient: {patient.id}")
            return patient
        else:
            print(f"No patient found with ID: {patient_id}")
            return None
    except Exception as e:
        print(f"Error retrieving patient: {str(e)}")
        return None

def create_or_get_organization():
    """Create lab organization if it doesn't exist, or get existing one."""
    try:
        # Search for existing organization by name
        search = Organization.where(struct={'name': LAB_INFO['name']})
        results = search.perform(smart.server)
        if results and results.entry:
            org = results.entry[0].resource
            print(f"Found existing lab organization: {org.id}")
            return org.id
        else:
            # Create new organization if it doesn't exist
            org = Organization()
            org.name = LAB_INFO['name']
            
            # Create proper Address object
            address = Address()
            address.line = [LAB_INFO['address']['line'][0]]
            address.city = LAB_INFO['address']['city']
            address.country = LAB_INFO['address']['country']
            address.postalCode = LAB_INFO['address']['postalCode']
            
            org.address = [address]  # Set as list of Address objects
            
            try:
                org_response = org.create(smart.server)
                if isinstance(org_response, dict):
                    org_id = org_response.get('id')
                else:
                    org_id = org_response.id
                if not org_id:
                    raise ValueError("No ID returned for Organization.")
                print(f"Created new lab organization with ID: {org_id}")
                return org_id
            except Exception as e:
                print(f"Error creating organization: {str(e)}")
                return None
    except Exception as e:
        print(f"Error searching for organization: {str(e)}")
        return None

def create_or_get_practitioner():
    """Create practitioner if doesn't exist, or get existing one."""
    try:
        # Search for existing practitioner by family name
        search = Practitioner.where(struct={'family': PRACTITIONER_INFO['name']['family']})
        results = search.perform(smart.server)
        if results and results.entry:
            # Further check for given name
            for entry in results.entry:
                pract = entry.resource
                given_names = pract.name[0].given
                if PRACTITIONER_INFO['name']['given'][0] in given_names:
                    print(f"Found existing practitioner: {pract.id}")
                    return pract.id
            # If no exact match, proceed to create
        # Create new practitioner if it doesn't exist
        pract = Practitioner()
        
        # Create proper HumanName object
        name = HumanName()
        name.given = PRACTITIONER_INFO['name']['given']
        name.family = PRACTITIONER_INFO['name']['family']
        
        pract.name = [name]  # Set as list of HumanName objects
        
        # Optionally, add qualifications if needed
        # Skipping qualifications for simplicity
        
        try:
            pract_response = pract.create(smart.server)
            if isinstance(pract_response, dict):
                pract_id = pract_response.get('id')
            else:
                pract_id = pract_response.id
            if not pract_id:
                raise ValueError("No ID returned for Practitioner.")
            print(f"Created new practitioner with ID: {pract_id}")
            return pract_id
        except Exception as e:
            print(f"Error creating practitioner: {str(e)}")
            return None
    except Exception as e:
        print(f"Error searching for practitioner: {str(e)}")
        return None

def main():
    """Main function to upload test results."""
    # Create or get Lab Organization
    lab_org_id = create_or_get_organization()
    if not lab_org_id:
        print("Failed to create or retrieve lab organization. Exiting.")
        return
    
    # Create or get Practitioner
    practitioner_id = create_or_get_practitioner()
    if not practitioner_id:
        print("Failed to create or retrieve practitioner. Exiting.")
        return
    
    # Get patient
    patient = get_patient(PATIENT_ID)
    if not patient:
        print("Patient retrieval failed. Exiting.")
        return
    
    # Upload each panel for each date
    for date_type, test_date in TEST_DATES.items():
        print(f"\nUploading {date_type} test results from {test_date}")
        upload_test_series(
            patient=patient,
            panel_data=CBC_PANEL,
            panel_name='CBC',
            test_date=test_date,
            date_type=date_type,
            lab_org_id=lab_org_id,
            practitioner_id=practitioner_id
        )
        upload_test_series(
            patient=patient,
            panel_data=METABOLIC_PANEL,
            panel_name='METABOLIC',
            test_date=test_date,
            date_type=date_type,
            lab_org_id=lab_org_id,
            practitioner_id=practitioner_id
        )
        upload_test_series(
            patient=patient,
            panel_data=LIPID_PANEL,
            panel_name='LIPID',
            test_date=test_date,
            date_type=date_type,
            lab_org_id=lab_org_id,
            practitioner_id=practitioner_id
        )

if __name__ == "__main__":
    main()

================
File: Django_app/chatbot/urls.py
================
# chatbot/urls.py - FIXED
from django.urls import path
from .views.api.endpoints import chat

# IMPORTANT: This file was edited at:
print("URLS FIXED: Using only existing endpoints")

urlpatterns = [
    # Chat endpoint - only include endpoints that exist
    path('chat/', chat, name='chat'),
]

================
File: Django_app/.cursorignore
================
venv
data
target
hapi-fhir-jpaserver-starter 
.env

================
File: Django_app/.env
================
SECRET_KEY=8c4(4agto%gi&k)e9h7cf*8e3h!_%d!hj*yxs3fp-h+llshr@&
OPENAI_API_KEY=sk-ZUwuXVlTh4hG6P-1nHRBSXyivgYyJVkRDIhVwc-RYJT3BlbkFJ22hOphcF46v8xUMASYVm7THxlHkVkAPXUSAQTtO5AA
FHIR_SERVER_URL=http://localhost:8080/fhir
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
DATABASE_URL=sqlite:///db.sqlite3
DEBUG=True
TWILIO_ACCOUNT_SID=ACc605dd9117454d3bc83fa12e4ad5e047
TWILIO_AUTH_TOKEN=20b3ac5d29260bc36ad0a8f86ed36277
TWILIO_PHONE_NUMBER=+14243532443
DJANGO_SETTINGS_MODULE="anna_project.settings"

================
File: Django_app/application.yaml
================
spring:
  datasource:
    url: 'jdbc:h2:file:./target/database/h2'
    username: sa
    password: null
    driverClassName: org.h2.Driver
  jpa:
    properties:
      hibernate.dialect: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update
    database-platform: org.hibernate.dialect.H2Dialect
    show-sql: true  # This will help us see what's happening with the database
  h2:
    console:
      enabled: true  # Enables H2 console for debugging

hapi:
  fhir:
    server_address: http://localhost:8080/fhir
    default_encoding: JSON
    fhir_version: R4
    enable_repository_validating_interceptor: false
    persistence_unit_name: HAPI_PU
    schema_update_mode: update  # Explicitly set schema update mode
    validation:
      enabled: false  # Disable validation during initial setup

================
File: Django_app/custom_asgi.py
================
"""
Custom ASGI application that directly maps chat endpoint to our handler
"""
import os
import json
from django.http import JsonResponse
from django.core.asgi import get_asgi_application

# Set Django settings
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')

# Get the default Django ASGI application
django_application = get_asgi_application()

# Custom chat handler
async def custom_chat_handler(scope, receive, send):
    """Custom handler for chat endpoint"""
    
    if scope["type"] == "http" and scope["path"] == "/chatbot/chat/":
        print("CUSTOM: Handling chat request")
        
        # Process the request
        request_body = b""
        while True:
            message = await receive()
            request_body += message.get("body", b"")
            if not message.get("more_body", False):
                break
        
        # Parse the request body
        try:
            data = json.loads(request_body)
            user_id = data.get("user_id", "unknown")
            user_message = data.get("message", "")
            
            # Send a test response
            response = {
                "response": f"Custom handler processed: '{user_message}' from user {user_id}",
                "handler": "custom_asgi.py"
            }
            
            # Send a response back
            await send({
                "type": "http.response.start",
                "status": 200,
                "headers": [
                    [b"content-type", b"application/json"],
                ],
            })
            
            await send({
                "type": "http.response.body",
                "body": json.dumps(response).encode(),
            })
            return
        except Exception as e:
            print(f"CUSTOM: Error handling request: {str(e)}")
            # On error, let Django handle it
            pass
    
    # For all other paths, use the default Django application
    await django_application(scope, receive, send)

# ASGI application to be served by Uvicorn
application = custom_chat_handler

================
File: Django_app/debug_init.py
================
"""
Debug script to trace what's happening during ChatHandler initialization
"""
import os
import sys
import django
import inspect
import asyncio

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
django.setup()

# Mock missing modules
import sys
from unittest.mock import MagicMock

# Mock presidio_analyzer
class MockPresidioAnalyzer:
    class AnalyzerEngine:
        def analyze(self, *args, **kwargs):
            return []
        def __init__(self, *args, **kwargs):
            pass

sys.modules['presidio_analyzer'] = MockPresidioAnalyzer

# Mock spacy
class MockSpacy:
    def load(self, *args, **kwargs):
        return MagicMock()

sys.modules['spacy'] = MockSpacy()

# Mock sentence_transformers
class MockSentenceTransformer:
    def __init__(self, *args, **kwargs):
        pass
    def encode(self, *args, **kwargs):
        import numpy as np
        return np.zeros(10)  # Return a dummy embedding

class MockSentenceTransformers:
    SentenceTransformer = MockSentenceTransformer

sys.modules['sentence_transformers'] = MockSentenceTransformers

# Mock transformers
class MockTransformers:
    def pipeline(self, *args, **kwargs):
        def classifier(*args, **kwargs):
            return {"labels": ["general"], "scores": [0.9]}
        return classifier

sys.modules['transformers'] = MockTransformers()

# Now we can import ChatHandler and patch the translate_to_english method
from chatbot.views.handlers.chat_handler import ChatHandler

# Save the original method
original_translate_to_english = ChatHandler.translate_to_english

# Replace with a non-async version that doesn't return a coroutine
def patched_translate_to_english(self, text):
    print(f"PATCHED translate_to_english called with: {text}")
    return text  # Simply return the original text

# Apply the patch
ChatHandler.translate_to_english = patched_translate_to_english

async def main():
    """Test ChatHandler initialization"""
    print("Starting debug script")
    
    # Create a mock session
    session_data = {
        'user_id': 'test_user',
        'phone_number': '1234567890',
        'patient': None,
        'conversation_history': []
    }
    
    user_message = "Hello, this is a test"
    user_id = "test_user"
    
    try:
        print("Creating ChatHandler instance")
        handler = ChatHandler(session_data, user_message, user_id)
        print("ChatHandler instance created successfully")
        
        print("Initializing ChatHandler")
        await handler.initialize()
        print("ChatHandler initialized successfully")
    except Exception as e:
        print(f"ERROR: {type(e).__name__}: {str(e)}")
        import traceback
        print(traceback.format_exc())
    finally:
        # Restore original method
        ChatHandler.translate_to_english = original_translate_to_english
    
    print("Debug script completed")

if __name__ == "__main__":
    asyncio.run(main())

================
File: Django_app/docker-compose.yml
================
version: '3.8'
services:
  hapi-fhir:
    image: hapiproject/hapi:latest
    ports:
      - "8080:8080"  # HAPI FHIR API port only; removed port 8000 mapping
    volumes:
      - ./data/hapi:/data/hapi
    environment:
      - spring.datasource.url=jdbc:h2:/data/hapi/database;AUTO_SERVER=TRUE
      - spring.datasource.username=admin
      - spring.datasource.password=admin
      - spring.datasource.driverClassName=org.h2.Driver
      - hapi.fhir.allow_external_references=true
      - hapi.fhir.expunge_enabled=true
      - hapi.fhir.allow_multiple_delete=true
      - REDIS_HOST=redis     # Connect to the 'redis' service
      - REDIS_PORT=6379      # Default Redis port
      - REDIS_DB=0           # Default Redis DB
      - DEBUG=True          # Set to False in production
      - SECRET_KEY=your-secret-key # Replace with a strong secret key!
    user: "1000:1000"
    restart: unless-stopped
    depends_on:
      - redis

  redis:
    image: redis:latest
    ports:
      - "6379:6379"  # Expose port 6379 (optional, for external access/debugging)
    volumes:
      - redis-data:/data  # Persist Redis data
    restart: unless-stopped

volumes:
  hapi-data:
  redis-data:

================
File: Django_app/fhir_client_module.py
================
import logging
import requests
import json
from django.conf import settings  # Import Django settings
from datetime import datetime, timedelta

logger = logging.getLogger('chatbot')

class FHIRClient:
    """
    A client to interact with a FHIR server.
    """

    def __init__(self, base_url=None):
        """
        Initialize the FHIR client with the base URL.
        If base_url is not provided, use settings.FHIR_SERVER_URL
        """
        if base_url is None:
            base_url = settings.FHIR_SERVER_URL  # Use Django settings
        self.base_url = base_url.rstrip('/')
        self.headers = {
            "Accept": "application/fhir+json",
            "Content-Type": "application/fhir+json"
        }
        logger.debug(f"FHIRClient initialized with base URL: {self.base_url}")

    def search(self, resource_type, params=None):
        """
        Search for resources of a specific type with optional query parameters.

        :param resource_type: The FHIR resource type to search (e.g., 'Patient').
        :param params: A dictionary of query parameters.
        :return: JSON response from the FHIR server or None if an error occurs.
        """
        url = f"{self.base_url}/{resource_type}"
        logger.debug(f"Searching for {resource_type} with params: {params} at URL: {url}")
        try:
            response = requests.get(url, headers=self.headers, params=params, timeout=10)
            response.raise_for_status()
            logger.debug(f"Search successful for {resource_type}")
            data = response.json()
            logger.debug(f"Search response: {json.dumps(data, indent=2)}")
            return data
        except requests.exceptions.HTTPError as http_err:
            logger.error(f"HTTP error during search for {resource_type}: {http_err} - Response: {response.text}")
        except requests.exceptions.Timeout:
            logger.error(f"Timeout occurred during search for {resource_type}")
        except requests.exceptions.RequestException as req_err:
            logger.error(f"Request exception during search for {resource_type}: {req_err}")
        except Exception as e:
            logger.error(f"Unexpected error during search for {resource_type}: {e}", exc_info=True)
        return None

    def read(self, resource_type, resource_id):
        """
        Read a specific resource by type and ID.

        :param resource_type: The FHIR resource type (e.g., 'Patient').
        :param resource_id: The ID of the resource.
        :return: JSON response from the FHIR server or None if an error occurs.
        """
        url = f"{self.base_url}/{resource_type}/{resource_id}"
        logger.debug(f"Reading {resource_type} with ID: {resource_id} at URL: {url}")
        try:
            response = requests.get(url, headers=self.headers, timeout=10)
            response.raise_for_status()
            logger.debug(f"Read successful for {resource_type} ID: {resource_id}")
            data = response.json()
            logger.debug(f"Read response: {json.dumps(data, indent=2)}")
            return data
        except requests.exceptions.HTTPError as http_err:
            logger.error(f"HTTP error during read for {resource_type} ID {resource_id}: {http_err} - Response: {response.text}")
        except requests.exceptions.Timeout:
            logger.error(f"Timeout occurred during read for {resource_type} ID {resource_id}")
        except requests.exceptions.RequestException as req_err:
            logger.error(f"Request exception during read for {resource_type} ID {resource_id}: {req_err}")
        except Exception as e:
            logger.error(f"Unexpected error during read for {resource_type} ID {resource_id}: {e}", exc_info=True)
        return None

    def create(self, resource_type, resource_data):
        """
        Create a new resource on the FHIR server.

        :param resource_type: The FHIR resource type to create (e.g., 'Patient').
        :param resource_data: A dictionary representing the resource.
        :return: JSON response from the FHIR server or None if an error occurs.
        """
        url = f"{self.base_url}/{resource_type}"
        logger.debug(f"Creating {resource_type} with data: {json.dumps(resource_data, indent=2)} at URL: {url}")
        try:
            response = requests.post(url, headers=self.headers, json=resource_data, timeout=10)
            response.raise_for_status()
            logger.debug(f"Creation successful for {resource_type}")
            data = response.json()
            logger.debug(f"Creation response: {json.dumps(data, indent=2)}")
            return data
        except requests.exceptions.HTTPError as http_err:
            logger.error(f"HTTP error during creation of {resource_type}: {http_err} - Response: {response.text}")
        except requests.exceptions.Timeout:
            logger.error(f"Timeout occurred during creation of {resource_type}")
        except requests.exceptions.RequestException as req_err:
            logger.error(f"Request exception during creation of {resource_type}: {req_err}")
        except Exception as e:
            logger.error(f"Unexpected error during creation of {resource_type}: {e}", exc_info=True)
        return None

    def update(self, resource_type, resource_id, resource_data):
        """
        Update an existing resource on the FHIR server.

        :param resource_type: The FHIR resource type to update (e.g., 'Patient').
        :param resource_id: The ID of the resource to update.
        :param resource_data: A dictionary representing the updated resource.
        :return: JSON response from the FHIR server or None if an error occurs.
        """
        url = f"{self.base_url}/{resource_type}/{resource_id}"
        logger.debug(f"Updating {resource_type} ID: {resource_id} with data: {json.dumps(resource_data, indent=2)} at URL: {url}")
        try:
            response = requests.put(url, headers=self.headers, json=resource_data, timeout=10)
            response.raise_for_status()
            logger.debug(f"Update successful for {resource_type} ID: {resource_id}")
            data = response.json()
            logger.debug(f"Update response: {json.dumps(data, indent=2)}")
            return data
        except requests.exceptions.HTTPError as http_err:
            logger.error(f"HTTP error during update of {resource_type} ID {resource_id}: {http_err} - Response: {response.text}")
        except requests.exceptions.Timeout:
            logger.error(f"Timeout occurred during update of {resource_type} ID {resource_id}")
        except requests.exceptions.RequestException as req_err:
            logger.error(f"Request exception during update of {resource_type} ID {resource_id}: {req_err}")
        except Exception as e:
            logger.error(f"Unexpected error during update of {resource_type} ID {resource_id}: {e}", exc_info=True)
        return None

    def delete(self, resource_type, resource_id):
        """
        Delete a resource from the FHIR server.

        :param resource_type: The FHIR resource type to delete (e.g., 'Patient').
        :param resource_id: The ID of the resource to delete.
        :return: True if deletion was successful, False otherwise.
        """
        url = f"{self.base_url}/{resource_type}/{resource_id}"
        logger.debug(f"Deleting {resource_type} ID: {resource_id} at URL: {url}")
        try:
            response = requests.delete(url, headers=self.headers, timeout=10)
            response.raise_for_status()
            logger.debug(f"Deletion successful for {resource_type} ID: {resource_id}")
            return True
        except requests.exceptions.HTTPError as http_err:
            logger.error(f"HTTP error during deletion of {resource_type} ID {resource_id}: {http_err} - Response: {response.text}")
        except requests.exceptions.Timeout:
            logger.error(f"Timeout occurred during deletion of {resource_type} ID {resource_id}")
        except requests.exceptions.RequestException as req_err:
            logger.error(f"Request exception during deletion of {resource_type} ID {resource_id}: {req_err}")
        except Exception as e:
            logger.error(f"Unexpected error during deletion of {resource_type} ID {resource_id}: {e}", exc_info=True)
        return False


# Add this new function to your existing code
def find_patient_by_email_or_phone(identifier):
    """
    Find a patient by their email or phone number using telecom search.
    
    :param identifier: Email or phone number to search for
    :return: Patient resource or None if not found
    """
    logger.debug(f"Searching for patient with identifier: {identifier}")
    fhir_client = FHIRClient()
    
    # Clean the identifier
    clean_identifier = identifier.strip().lower()
    
    # Try email first
    if '@' in clean_identifier:
        search_params = {
            "telecom": f"email|{clean_identifier}"
        }
        logger.debug(f"Searching by email with params: {search_params}")
        patient_bundle = fhir_client.search("Patient", search_params)
        
        if patient_bundle and 'entry' in patient_bundle and patient_bundle['entry']:
            logger.debug("Patient found by email")
            return patient_bundle['entry'][0]['resource']
    
    # Try phone number
    search_params = {
        "telecom": f"phone|{clean_identifier}"
    }
    logger.debug(f"Searching by phone with params: {search_params}")
    patient_bundle = fhir_client.search("Patient", search_params)
    
    if patient_bundle and 'entry' in patient_bundle and patient_bundle['entry']:
        logger.debug("Patient found by phone")
        return patient_bundle['entry'][0]['resource']
    
    # If no patient found, try searching in identifier system
    search_params = {
        "identifier": clean_identifier
    }
    logger.debug(f"Searching by identifier with params: {search_params}")
    patient_bundle = fhir_client.search("Patient", search_params)
    
    if patient_bundle and 'entry' in patient_bundle and patient_bundle['entry']:
        logger.debug("Patient found by identifier")
        return patient_bundle['entry'][0]['resource']
    
    logger.debug("No patient found with provided identifier")
    return None


def find_patient_by_identifier(identifier):
    """
    Find a patient by their phone number or email.

    :param identifier: The phone number or email to search for.
    :return: Patient resource as a dictionary or None if not found.
    """
    logger.debug(f"Attempting to find patient with identifier: {identifier}")
    fhir_client = FHIRClient()

    # Determine if the identifier is an email or phone number
    if "@" in identifier:
        search_params = {"email": identifier}
    else:
        search_params = {"phone": identifier}

    logger.debug(f"Search parameters: {search_params}")
    patient_bundle = fhir_client.search("Patient", search_params)

    if patient_bundle and 'entry' in patient_bundle and len(patient_bundle['entry']) > 0:
        patient = patient_bundle['entry'][0]['resource']
        logger.debug(f"Patient found: {json.dumps(patient, indent=2)}")
        return patient
    else:
        logger.info(f"No patient found with identifier: {identifier}")
        return None

def get_full_medical_record(patient_id):
    """
    Retrieve the full medical record for a patient.

    :param patient_id: The ID of the patient.
    :return: Dictionary containing all relevant resources or None.
    """
    logger.debug(f"Retrieving full medical record for Patient ID: {patient_id}")
    fhir_client = FHIRClient()

    resources = {}
    # Retrieve Conditions
    conditions = fhir_client.search("Condition", {"patient": patient_id})
    resources['conditions'] = conditions

    # Retrieve Medications
    medications = fhir_client.search("MedicationStatement", {"patient": patient_id})
    resources['medications'] = medications

    # Retrieve Immunizations
    immunizations = fhir_client.search("Immunization", {"patient": patient_id})
    resources['immunizations'] = immunizations

    # Retrieve Procedures
    procedures = fhir_client.search("Procedure", {"patient": patient_id})
    resources['procedures'] = procedures

    # Retrieve Appointments
    appointments = fhir_client.search("Appointment", {"patient": patient_id})
    resources['appointments'] = appointments

    # Add more resources as needed

    logger.debug(f"Full medical record retrieved: {json.dumps(resources, indent=2)}")
    return resources

def get_patient_data(field, patient_id):
    """
    Retrieve specific data for a patient based on the field.

    :param field: The data field to retrieve (e.g., 'height', 'weight', 'conditions', 'medications', 'vaccines').
    :param patient_id: The ID of the patient.
    :return: Formatted string with the requested data or an appropriate message.
    """
    fhir_client = FHIRClient()
    response = ""

    if field == "height":
        observations = fhir_client.search("Observation", {"patient": patient_id, "code": "8302-2"})
        if observations and 'entry' in observations and len(observations['entry']) > 0:
            height = observations['entry'][0]['resource']['valueQuantity']['value']
            response = f"Your height is {height} cm."
        else:
            response = "Height information is not available."

    elif field == "weight":
        observations = fhir_client.search("Observation", {"patient": patient_id, "code": "29463-7"})
        if observations and 'entry' in observations and len(observations['entry']) > 0:
            weight = observations['entry'][0]['resource']['valueQuantity']['value']
            response = f"Your weight is {weight} kg."
        else:
            response = "Weight information is not available."

    elif field == "conditions":
        conditions = fhir_client.search("Condition", {"patient": patient_id, "clinical-status": "active"})
        if conditions and 'entry' in conditions and len(conditions['entry']) > 0:
            condition_list = [entry['resource']['code']['text'] for entry in conditions['entry'] if 'text' in entry['resource']['code']]
            if not condition_list:
                # Fallback to coding display if text is missing
                condition_list = [entry['resource']['code']['coding'][0].get('display', 'Unknown') for entry in conditions['entry']]
            response = "You have the following conditions: " + ", ".join(condition_list) + "."
        else:
            response = "No active conditions found."

    elif field == "medications":
        medications = fhir_client.search("MedicationStatement", {"patient": patient_id, "status": "active"})
        if medications and 'entry' in medications and len(medications['entry']) > 0:
            medication_list = []
            for entry in medications['entry']:
                med = entry['resource'].get('medicationCodeableConcept', {})
                text = med.get('text')
                if text:
                    medication_list.append(text)
                else:
                    # Fallback to coding display if text is missing
                    coding = med.get('coding', [])
                    if coding:
                        medication_list.append(coding[0].get('display', 'Unknown'))
            response = "You are currently taking the following medications: " + ", ".join(medication_list) + "."
        else:
            response = "No active medications found."

    elif field == "vaccines":
        immunizations = fhir_client.search("Immunization", {"patient": patient_id})
        if immunizations and 'entry' in immunizations and len(immunizations['entry']) > 0:
            vaccine_list = []
            for entry in immunizations['entry']:
                vaccine = entry['resource'].get('vaccineCode', {})
                text = vaccine.get('text')
                if text:
                    vaccine_list.append(text)
                else:
                    # Fallback to coding display if text is missing
                    coding = vaccine.get('coding', [])
                    if coding:
                        vaccine_list.append(coding[0].get('display', 'Unknown'))
            response = "You have received the following vaccines: " + ", ".join(vaccine_list) + "."
        else:
            response = "No immunizations found."

    elif field == "practitioner":
        # Retrieve the practitioner's details linked to the patient
        # Assuming each patient has a general practitioner referenced
        patient = fhir_client.read("Patient", patient_id)
        if patient and 'generalPractitioner' in patient:
            practitioner_ref = patient['generalPractitioner'][0]['reference']
            practitioner_id = practitioner_ref.split('/')[-1]
            practitioner = fhir_client.read("Practitioner", practitioner_id)
            if practitioner:
                practitioner_name = f"{practitioner['name'][0]['given'][0]} {practitioner['name'][0]['family']}"
                response = f"Your practitioner is Dr. {practitioner_name}."
            else:
                response = "Your practitioner information is not available."
        else:
            response = "Your practitioner information is not available."

    elif field == "appointments":
        appointments = fhir_client.search("Appointment", {"patient": patient_id, "status": "booked"})
        if appointments and 'entry' in appointments and len(appointments['entry']) > 0:
            appointment_list = []
            for entry in appointments['entry']:
                appt = entry['resource']
                practitioner_ref = next((p['actor']['reference'] for p in appt['participant'] if p['actor']['reference'].startswith('Practitioner/')), None)
                if practitioner_ref:
                    practitioner_id = practitioner_ref.split('/')[-1]
                    practitioner = fhir_client.read("Practitioner", practitioner_id)
                    practitioner_name = f"{practitioner['name'][0]['given'][0]} {practitioner['name'][0]['family']}" if practitioner else "Unknown"
                else:
                    practitioner_name = "Unknown"

                appt_time = appt['start']
                appointment_list.append(f"Appointment with Dr. {practitioner_name} at {appt_time}")

            response = "Your upcoming appointments:\n" + "\n".join(appointment_list)
        else:
            response = "You have no upcoming appointments."

    else:
        response = "I'm not sure how to help with that."

    logger.debug(f"Retrieved data for field '{field}': {response}")
    return response

def set_appointment(patient_id, date_str, time_str, reason):
    """
    Create an appointment for a patient.

    :param patient_id: The ID of the patient.
    :param date_str: The date of the appointment (YYYY-MM-DD).
    :param time_str: The time of the appointment (HH:MM).
    :param reason: The reason for the appointment.
    :return: Confirmation message or an error message.
    """
    fhir_client = FHIRClient()
    
    # Retrieve patient to find their general practitioner
    patient = fhir_client.read("Patient", patient_id)
    if not patient or 'generalPractitioner' not in patient:
        return "Unable to find your general practitioner. Please contact your healthcare provider directly."

    practitioner_ref = patient['generalPractitioner'][0]['reference']
    practitioner_id = practitioner_ref.split('/')[-1]

    # Check practitioner's availability
    # For simplicity, we'll assume that the practitioner has a Schedule resource
    schedules = fhir_client.search("Schedule", {"actor": practitioner_ref})
    if not schedules or 'entry' not in schedules or len(schedules['entry']) == 0:
        return "No available schedules found for your practitioner."

    # For demonstration, pick the first schedule
    schedule = schedules['entry'][0]['resource']
    schedule_id = schedule['id']

    # Check existing appointments for the practitioner at the desired time
    existing_appts = fhir_client.search("Appointment", {
        "practitioner": practitioner_id,
        "start": f"{date_str}T{time_str}:00Z"
    })

    if existing_appts and 'entry' in existing_appts and len(existing_appts['entry']) > 0:
        return "Your practitioner is not available at the requested time. Please choose another time."

    # Create the appointment
    start_datetime = f"{date_str}T{time_str}:00Z"
    end_time = (datetime.strptime(time_str, "%H:%M") + timedelta(hours=1)).strftime("%H:%M")
    end_datetime = f"{date_str}T{end_time}:00Z"

    appointment = {
        "resourceType": "Appointment",
        "status": "booked",
        "description": reason,
        "start": start_datetime,
        "end": end_datetime,
        "participant": [
            {
                "actor": {
                    "reference": f"Patient/{patient_id}"
                },
                "status": "accepted"
            },
            {
                "actor": {
                    "reference": f"Practitioner/{practitioner_id}"
                },
                "status": "accepted"
            }
        ],
        "basedOn": [
            {
                "reference": f"Schedule/{schedule_id}"
            }
        ]
    }

    created_appt = fhir_client.create("Appointment", appointment)
    if created_appt:
        appt_id = created_appt.get('id', 'Unknown')
        return f"Appointment booked with Practitioner ID: {practitioner_id} on {start_datetime} (Appointment ID: {appt_id})."
    else:
        return "Failed to book the appointment. Please try again later."

def cancel_appointment(appointment_id):
    """
    Cancel an existing appointment.

    :param appointment_id: The ID of the appointment to cancel.
    :return: Confirmation message or an error message.
    """
    fhir_client = FHIRClient()
    success = fhir_client.delete("Appointment", appointment_id)
    if success:
        return f"Appointment ID: {appointment_id} has been successfully canceled."
    else:
        return "Failed to cancel the appointment. Please try again later."

def get_practitioner(patient_id):
    """
    Retrieve the practitioner's details linked to the patient.

    :param patient_id: The ID of the patient.
    :return: Practitioner details or None.
    """
    fhir_client = FHIRClient()
    patient = fhir_client.read("Patient", patient_id)
    if patient and 'generalPractitioner' in patient:
        practitioner_ref = patient['generalPractitioner'][0]['reference']
        practitioner_id = practitioner_ref.split('/')[-1]
        practitioner = fhir_client.read("Practitioner", practitioner_id)
        return practitioner
    return None

def get_appointment_availability(practitioner_id, date_str, time_str):
    """
    Check if the practitioner is available at the specified date and time.

    :param practitioner_id: The ID of the practitioner.
    :param date_str: The date of the appointment (YYYY-MM-DD).
    :param time_str: The time of the appointment (HH:MM).
    :return: True if available, False otherwise.
    """
    fhir_client = FHIRClient()
    start_datetime = f"{date_str}T{time_str}:00Z"
    existing_appts = fhir_client.search("Appointment", {
        "practitioner": practitioner_id,
        "start": start_datetime
    })

    if existing_appts and 'entry' in existing_appts and len(existing_appts['entry']) > 0:
        return False
    return True

================
File: Django_app/find_messages.py
================
#!/usr/bin/env python
"""
This script searches for the text "Async chat view works" in all Python files in the current directory and subdirectories.
"""
import os
import re
import sys

def search_file(file_path, pattern):
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            if pattern in content:
                print(f"FOUND in {file_path}")
                # Find the line containing the pattern
                lines = content.split('\n')
                for i, line in enumerate(lines):
                    if pattern in line:
                        print(f"  Line {i+1}: {line.strip()}")
    except:
        pass  # Ignore files that can't be read

def search_directory(directory, pattern):
    print(f"Searching in {directory}...")
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Search in Python, JavaScript, HTML, and JSON files
            if file.endswith(('.py', '.js', '.html', '.json', '.txt')):
                file_path = os.path.join(root, file)
                search_file(file_path, pattern)

if __name__ == "__main__":
    current_dir = os.getcwd()
    patterns = [
        "Async chat view works",
        "\"message\": \"Async chat view works\"",
        "JsonResponse({\"message\": \"Async chat view works\"})",
        "message.*Async.*works"
    ]
    
    for pattern in patterns:
        print(f"\nSearching for '{pattern}' in {current_dir} and subdirectories...")
        search_directory(current_dir, pattern)
    
    print("\nSearch completed.")

================
File: Django_app/manage.py
================
"""Django's command-line utility for administrative tasks."""
import os
import sys

def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Ensure it's installed and available on your PYTHONPATH environment variable. "
            "Did you forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)

if __name__ == '__main__':
    main()

================
File: Django_app/requirements.txt
================
alembic==1.13.3
blinker==1.8.2
click==8.1.7
Flask==3.0.3
Flask-Migrate==3.1.0
Flask-SQLAlchemy==3.1.1
itsdangerous==2.2.0
Jinja2==3.1.4
Mako==1.3.5
MarkupSafe==3.0.1
python-dotenv>=0.19.0
SQLAlchemy==2.0.35
typing_extensions==4.12.2
Werkzeug==3.0.4
requests>=2.26.0
fhirclient>=4.2.1
twilio>=7.0.0
openai>=0.27.0
dateparser
django>=3.2,<4.0
djangorestframework>=3.12.0
redis>=4.0.0
celery>=5.2.0
aioredis>=2.0.0
python-dateutil>=2.8.2
pytz>=2021.3
uvicorn>=0.15.0
starlette>=0.27.0
presidio-analyzer==2.2.357
langdetect==1.0.9
sentence-transformers==2.2.2
huggingface-hub==0.20.3
transformers==4.30.0

================
File: Django_app/test_chat_view.py
================
# Django_app/chatbot/management/commands/test_chat_view.py
from django.core.management.base import BaseCommand
from chatbot.views.api.endpoints import chat  # Import your chat view
from django.http import HttpRequest
import asyncio

class Command(BaseCommand):
    help = 'Tests the chat view function directly'

    def handle(self, *args, **options):
        print("--- Testing chat view function DIRECTLY ---")
        
        # Create a mock HttpRequest (minimal for testing)
        request = HttpRequest()
        request.method = 'POST'  # Assuming your chat view is for POST requests

        try:
            # Call the chat view function DIRECTLY (as a coroutine)
            loop = asyncio.get_event_loop()
            response = loop.run_until_complete(chat(request))

            print("\n--- Chat View Function Response: ---")
            print(f"Type of response: {type(response)}") # Debug: Check response type
            print(f"Response Content: {response.content.decode()}") # Decode content for printing

        except Exception as e:
            print("\n--- Error during chat view function execution: ---")
            import traceback
            traceback.print_exc()

================
File: Django_app/test_django.py
================
#!/usr/bin/env python
# Simple script to test Django configuration

import os
import sys
import django

def main():
    print(f"Python version: {sys.version}")
    print(f"Django version: {django.__version__}")
    
    # Check Django settings path
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
    print(f"DJANGO_SETTINGS_MODULE: {os.environ.get('DJANGO_SETTINGS_MODULE')}")
    
    # Try to setup Django
    try:
        django.setup()
        print("Django setup successful!")
    except Exception as e:
        print(f"Django setup failed: {e}")
        return
    
    # Check installed apps
    try:
        from django.conf import settings
        print(f"Installed Apps: {settings.INSTALLED_APPS}")
    except Exception as e:
        print(f"Error getting settings: {e}")
    
    # Check URL configuration
    try:
        from django.urls import resolve, get_resolver
        print("URL patterns:")
        resolver = get_resolver()
        for pattern in resolver.url_patterns:
            print(f"  - {pattern}")
    except Exception as e:
        print(f"Error checking URLs: {e}")

if __name__ == "__main__":
    main()

================
File: Django_app/test_endpoint.py
================
"""
Simple test script to test the chat endpoint
"""
import requests
import json

def test_chat():
    """Test the chat endpoint"""
    print("Testing chat endpoint...")
    
    url = "http://localhost:8000/chatbot/chat/"
    headers = {"Content-Type": "application/json"}
    data = {
        "user_id": "test_user",
        "message": "Hello, this is a test message"
    }
    
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        print(f"Status code: {response.status_code}")
        print(f"Response: {response.text}")
    except Exception as e:
        print(f"Error: {str(e)}")

if __name__ == "__main__":
    test_chat()

================
File: Django_app/test_explicit.py
================
import requests
import json

def test_explicit():
    url = "http://localhost:8000/chatbot/chat/"
    headers = {'Content-Type': 'application/json'}
    data = {'user_id': 'test', 'message': 'Hello from test'}
    
    print(f"DEBUG: Sending request to {url}")
    
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        print(f"DEBUG: Response status code: {response.status_code}")
        print(f"DEBUG: Response content: {response.text}")
        return response.json()
    except Exception as e:
        print(f"Error: {e}")
        return {"error": str(e)}

if __name__ == "__main__":
    result = test_explicit()
    print(f"Result: {result}")

================
File: Django_app/test_handler.py
================
import asyncio
import os
import django
import sys

# Set up Django
sys.path.append('/Users/rodrigoagag/Desktop/ANNA')
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'anna_project.settings')
django.setup()

from chatbot.views.handlers.chat_handler import ChatHandler

async def test_handler():
    print("Starting test...")
    session_data = {'conversation_history': []}
    
    print("Creating handler...")
    handler = ChatHandler(session_data, "Hello")
    
    print("Handler created, now initializing...")
    await handler.initialize()
    
    print("Handler initialized successfully.")
    return handler

if __name__ == "__main__":
    asyncio.run(test_handler())

================
File: .gitignore
================
.envDjango_app/hapi-fhir-jpaserver-starter/
# Ignore virtual environments
venv/
.venv_anna/

# Ignore data and build directories
data/
target/

# Ignore specific project directories
hapi-fhir-jpaserver-starter/

# Ignore all log files
**/*.log

# Ignore temporary files and directories
tmp/
*.tmp

# Ignore specific files if needed
specific_file_to_ignore.txt

# Ignore all markdown files in docs directory
docs/**/*.md

# Commented out patterns are not applied
# node_modules/Django_app/.venv_anna/
Django_app/app.log

================
File: .repomixignore
================
# Ignore virtual environments
venv/
.venv_anna/

# Ignore data and build directories
data/
target/

# Ignore specific project directories
hapi-fhir-jpaserver-starter/

# Ignore all log files
**/*.log

# Ignore temporary files and directories
tmp/
*.tmp

# Ignore specific files if needed
specific_file_to_ignore.txt

# Ignore all markdown files in docs directory
docs/**/*.md

# Commented out patterns are not applied
# node_modules/

================
File: CLAUDE.md
================
# ANNA Project Guidelines

## About ANNA
ANNA is a healthcare chatbot for patient assistance that:
- Processes natural language input to identify user intents with regex and AI
- Provides access to medical records and FHIR healthcare data
- Handles appointment scheduling and management
- Conducts symptom analysis with severity assessment and guidance
- Retrieves and explains lab results and medications
- Supports multiple languages via translation services

## Commands
- Start server: `uvicorn anna_project.asgi:application --reload`
- Run tests: `python manage.py test`
- Run specific test: `python manage.py test test_chat_view`
- Run chatbot client: `python Django_app/chatbot/chat_client.py`
- Celery worker: `celery -A anna_project worker --loglevel=info`

## Architecture
- **Handlers**: Process messages via ChatHandler (core), SymptomGuidanceHandler, AppointmentHandler
- **Services**: Provide business logic (FHIRService, LanguageService, IntentService)
- **API Endpoints**: Django view functions in endpoints.py that handle HTTP requests
- **Session Management**: Redis-based user sessions with context tracking
- **FHIR Integration**: Healthcare data access with fhirclient library

## Code Style
- **Imports**: Standard lib  Django  Third-party  Local (with comment separators)
- **Formatting**: 4-space indentation, ~100 char line limit
- **Naming**: snake_case (files/vars), PascalCase (classes), verb_noun (functions)
- **Patterns**: Thorough error handling with try/except and logging
- **Async**: Uses Django async with Uvicorn, `sync_to_async` for synchronous code
- **Logging**: Named loggers with appropriate levels (debug/info/error)
- **Security**: Input validation, secure session handling, healthcare data sensitivity
- **Testing**: Each major component has dedicated test files

================
File: play.py
================
try:
    name = input("whats my name")
    if name == "Rodrigo":
        print ("from 1 -50")
    else: print("negative")
except:
    if name == "John":
     print("error")
    else: print("fuck off")

================
File: product.txt
================
### **Anna: AI-Powered Medical Chatbot for Medicare Advantage (MA) Plans**

Anna is an AI-driven medical chatbot designed to enhance patient engagement, streamline operations, and optimize STAR ratings for Medicare Advantage (MA) plans. It operates primarily through SMS, providing hyper-personalized and contextualized medical support. Below is a detailed breakdown of Annas key components, functionalities, business model, and compliance considerations.

---

## **1. Key Functionalities**
Anna is built to support MA plans by automating patient interactions in a way that drives improved health outcomes and financial incentives. The main functionalities include:

### **1.1 Preventive Care Reminders**
- Notifies patients about upcoming screenings (e.g., mammograms, colonoscopies).
- Reminds patients about annual wellness visits and necessary vaccinations (e.g., flu shots).
- Educates patients on the importance of preventive care based on their medical history.

### **1.2 Medication Adherence Tracking**
- Sends refill reminders based on prescription schedules.
- Asks patients whether they have taken their medication and follows up if missed.
- Flags non-adherence issues for care managers to intervene.

### **1.3 Appointment Reminders & Scheduling**
- Sends SMS reminders about upcoming doctor visits.
- Offers rescheduling options and integrates with healthcare provider calendars.
- Ensures patients follow through with check-ups and specialist referrals.

### **1.4 Yearly Check-Up Prompts**
- Encourages Medicare Advantage beneficiaries to schedule their Annual Wellness Visit (AWV).
- Provides easy access to booking systems via SMS links.

### **1.5 Post-Appointment Follow-Ups**
- Sends post-visit questionnaires to assess patient satisfaction.
- Ensures that post-appointment care instructions are understood and followed.
- Detects potential complications and escalates cases to healthcare providers.

### **1.6 Hyper-Personalized & Contextualized Medical Advice**
- Uses patient data to provide relevant health information and guidance.
- Leverages AI-driven insights to customize interactions.
- Ensures compliance with CMS (Centers for Medicare & Medicaid Services) communication guidelines.

---

## **2. Integration & Technology Stack**
Anna is designed to integrate seamlessly with existing healthcare infrastructures, ensuring smooth adoption by MA plans. 

### **2.1 EHR & CMS Integration**
- **FHIR (Fast Healthcare Interoperability Resources)**: Enables seamless integration with Electronic Health Records (EHR) like Epic.
- **CMS API**: Ensures that Anna can pull and report data relevant for Medicare Advantage STAR ratings.

### **2.2 AI & NLP (Natural Language Processing)**
- **GPT-4**: Powers Annas conversational AI, making interactions feel natural and human-like.
- **Contextual Understanding**: Ensures messages are relevant to the patients medical history and care plan.

### **2.3 Communication Channels**
- **Twilio for SMS**: Facilitates secure and scalable patient communication.
- **AWS for Hosting**: Ensures reliability and HIPAA compliance.

---

## **3. Compliance & Security**
Since Anna handles sensitive patient data, strict compliance with healthcare regulations is essential.

### **3.1 HIPAA Compliance**
- Encrypts patient data in transit and at rest.
- Implements access controls and audit logs.
- Ensures PHI (Protected Health Information) is securely managed.

### **3.2 CMS Compliance**
- Aligns communication with CMS marketing and outreach guidelines.
- Focuses on permissible engagement strategies to improve MA plan STAR ratings.

### **3.3 Data Privacy & Security Measures**
- Role-based access control (RBAC).
- Secure authentication mechanisms for patient verification.
- Anonymization techniques for AI training data.

---

## **4. Business Model**
Anna's revenue model is designed around its impact on healthcare efficiency and outcomes.

### **4.1 SaaS Fees**
- MA plans pay a subscription fee based on the number of enrolled members.

### **4.2 Success Fees from CMS Bonuses**
- MA plans receive higher CMS reimbursements based on improved STAR ratings.
- Anna earns a percentage of the increased revenue tied to these improvements.

### **4.3 Transaction Fees**
- A small fee per SMS interaction or patient engagement session.

---

## **5. Target Clients**
Anna is built specifically for **regional and national Medicare Advantage (MA) plans**, with the goal of helping them:
1. Improve **STAR ratings** (which directly impact revenue).
2. Reduce **administrative burdens** through automation.
3. Increase **patient adherence** to preventive and ongoing care.

Other potential customers include:
- **Value-Based Care Providers**: Organizations focused on patient outcomes.
- **ACOs (Accountable Care Organizations)**: Groups that benefit from proactive patient engagement.
- **Chronic Care Management (CCM) Programs**: Entities managing high-risk patient populations.

---

## **6. Competitive Advantage**
Anna differentiates itself from other patient engagement solutions through:
- **Deep AI integration** for hyper-personalized medical advice.
- **Focus on SMS**, making it accessible to elderly patients who may not use apps.
- **Seamless EHR & CMS API integration** to ensure effortless data flow.
- **STAR rating optimization**, which directly translates into financial gains for MA plans.

---

## **Conclusion**
Anna is more than just a chatbotit is a **strategic tool** for Medicare Advantage plans to improve patient engagement, increase revenue, and enhance health outcomes. With its AI-driven automation, regulatory compliance, and business model aligned with MA plan incentives, Anna stands out as a **next-generation healthcare engagement platform**.

================
File: test_async.py
================
import asyncio

async def test_func():
    await asyncio.sleep(0.1)
    return "Hello"

print(f"Is test_func async? {asyncio.iscoroutinefunction(test_func)}")

async def main():
    result = await test_func()
    print(result)

if __name__ == "__main__":
    asyncio.run(main())



================================================================
End of Codebase
================================================================
